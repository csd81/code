# **8. Introduction to Templates in C++**

This presentation introduces the concept of **templates** in C++. Templates enable the creation of generic functions and classes that work with any data type. Instead of writing multiple versions of the same function or class for different types, templates allow developers to write one version that works for all compatible types. This lecture covers template syntax, usage examples, and highlights how templates enhance code reusability and flexibility. It also provides an overview of the **Standard Template Library (STL)**, focusing on containers like `vector` and `string`.

**TL;DR (English):**

This lecture covers the motivation and roles behind using **C++ templates**, explains how to create **generic functions and classes**, introduces the **C++ syntax** for templates with **examples**, and explores the **Standard Template Library (STL)**—focusing on **`vector`** and **`string`**. The session ends with a summary of the key concepts.



**Slide 3 TL;DR (English):**

In OOP, objects from one class can take on roles from another class.
**Delegation** means an object passes a task to another object it knows — e.g., a warehouse manager tells a forklift driver to move goods. This requires a reference from the first object to the second.

**Slide 4 TL;DR (English):**

**Compatibility** means the object itself has the necessary capabilities — e.g., the warehouse manager is also certified to drive a forklift and can do the task alone. This is possible if class A inherits from class B and B's methods are accessible.

**Slide 5 TL;DR (English):**

With **templates**, a role can be performed by different types, even if they're not inherently compatible.
Instead of requiring all types to meet all conditions up front (like every worker having a forklift license), checks are done during compilation.
C++ generates a separate version of the code for each used type.
**Typical use:** building general-purpose containers.

**Slide 6 – Translation (English): Introduction to Templates**

Templates allow the definition of functions or classes where certain parameters or variables can have different types in each call.

* You can say that a template function or class receives not only values as parameters, but also types.

* Once the types are provided to a template, it behaves like a regular function or class.


**Slide 7 – Translation (English): Motivation for Using Template Functions**

If an algorithm (e.g., sorting) can be applied to different types of elements, we used to define a separate function for each type.

* We made use of polymorphism,

* but this introduces a **risk of error**: if the algorithm changes, every version of the function must be updated individually.


8. This slide demonstrates **how templates simplify code reuse** when the same logic is needed for multiple data types.

### Without Template:

You must write **separate functions** for each type:

```cpp
int min(int a, int b) { return (a < b) ? a : b; }
long min(long a, long b) { return (a < b) ? a : b; }
char min(char a, char b) { return (a < b) ? a : b; }
```

Even though the logic is identical, you have to duplicate the code for every type (`int`, `long`, `char`, etc.).

### With Template:

You define **a single generic function**:

```cpp
template <typename T1>
T1 min(T1 a, T1 b) {
    return (a < b) ? a : b;
}
```

Now, the compiler will **generate the appropriate version** of the function automatically when you call `min()` with different types.

#### Benefits:

* No code duplication
* Easier maintenance (change logic once)
* Type-safe and flexible

Would you like a live code example in C++?


### Explanation: Defining Template Functions in C++

In C++, **template functions** allow writing generic code that works with any type. Here's how they are defined:

---

### Syntax:

```cpp
template <typename T1, typename T2, ...>
returnType functionName(type1 var1, type2 var2, ...) {
    // function body
}
```

---

### Key Points:

* **`template` keyword** starts the declaration.
* Inside angle brackets `< >`, you list the **template parameters**, e.g., `typename T1`.

  * You can use `class` instead of `typename`; they mean the same here.

    ```cpp
    template <class T>  // same as typename T
    ```
* The template type (like `T1`) can be used anywhere in the function as a **placeholder for a real type**:

  * Return type
  * Function parameters
  * Inside the function body

---

### Example:

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

This creates a generic `add()` function that works for any type supporting the `+` operator (e.g., `int`, `double`, `std::string`).

---

### Readability Tip:

Place a line break after the `template<...>` line to make code easier to read and understand.

### Slide 10 Explanation: Template Function Example – `mySwap`

This example shows **how to write and use a template function** to swap two values of any type.

---

### Code Breakdown:

```cpp
template<typename T1>
void mySwap(T1& a, T1& b) {
    T1 c;
    c = a;
    a = b;
    b = c;
}
```

#### What it does:

* Swaps the values of `a` and `b` using a temporary variable `c`.
* Works for any type `T1` that:

  * Has a **default constructor** (to create `c`)
  * Supports the **assignment operator (`=`)**

---

### `main()` Function:

```cpp
int main() {
    int x = 3, y = 2;
    mySwap<int>(x, y);  // Explicit template call
    return 0;
}
```

* Here, `x` and `y` are integers.
* `mySwap<int>(x, y)` tells the compiler to **generate a version of `mySwap` where `T1 = int`**.
* After the function call, the values of `x` and `y` are swapped.

---

### Summary:

✅ **Generic swap** for any type
✅ Requires that the type has a **default constructor** and **assignment support**
✅ Demonstrates how **templates increase code reuse**

Would you like to see the swapped result printed in this example?

**Slide 11 TL;DR (English): Types of Template Parameters in C++**

* **Type parameter**: e.g., `typename T1` – any simple or complex data type
* **Non-type constant parameter**: e.g., `int k` – treated like a regular parameter, but must be constant at compile time (often used for array sizes)
* **Template template parameter**: e.g., `template<typename A> class E` – a template that takes another template class as a parameter.




### Slide 12 Explanation: Mixed Template Example in C++
```cpp
#include <iostream>
using namespace std;
template <typename T, int size>
void print() {
 T store[size]; // static array of T
 for (int idxI=0; idxI<size; idxI++) {
    store[idxI]=idxI;
    cout << store[idxI] << ',';
 }
}
int main() {
 const int d=3;
 print<double, d>(); // d is const
 print<int, 7>();
 return 0;
}
```

This example demonstrates how to use **both a type and a non-type template parameter** in a single function.

---

### Code Breakdown:

```cpp
template <typename T, int size>
void print() {
    T store[size];  // Creates a static array of 'size' elements of type T
    for (int idxI = 0; idxI < size; idxI++) {
        store[idxI] = idxI;       // Fill array with 0, 1, 2, ...
        cout << store[idxI] << ','; // Print each value
    }
}
```

#### Template parameters:

* `T` — the **type** of elements in the array (e.g., `int`, `double`)
* `size` — a **non-type constant integer** that sets the array size at compile time

---

### `main()` Function:

```cpp
const int d = 3;
print<double, d>();  // Calls the template with T = double, size = 3
print<int, 7>();     // Calls the template with T = int, size = 7
```

* The `print<double, d>()` call creates a `double[3]` array.
* The `print<int, 7>()` call creates an `int[7]` array.
* Both are filled with values from 0 to `size - 1` and printed.

---

### Key Points:

✅ Shows **combining type and constant template parameters**
✅ Useful for **fixed-size arrays**
✅ Requires `size` to be a **compile-time constant**

Would you like the output this program produces?


**Slide 13 – English Translation: Assumed Properties of Template Parameters (C++)**

* With a template parameter, we can create an object.
* If we want to use a member variable, method, or operator of that object, we **assume** the type provides it.
* If the substituted type **does not have** the required feature, the compiler will raise an error.

  * Example: in `mySwap`, the type must support **assignment**.
  * Example: in `min`, the type must support the **comparison operator (`<`)**.

> ⚠️ Important: In a template class, the substituted type **doesn’t need to have all possible features**, only the ones actually **used in the called functions**.


### Létező és nem létező képességek (C++)
```cpp
class a {
public: int id;
};
class b {
public: void kiir();
};
template <typename T1, typename T2>
void reach() {
T1 first;
T2 second;
first.id=23;
// second.print();
// error: print is not a member in b
(second -> T2 -> b)
}

int main() {
reach<a, b>();
return 0;
}
```


### Explanation of the Code:

This example demonstrates a **template function** using two different types, and it also shows what can go wrong when a template **assumes a capability** that doesn't exist in the substituted type.

---

### Code Walkthrough:

```cpp
class a {
public:
    int id;
};
```

* A simple class `a` with a public integer member `id`.

```cpp
class b {
public:
    void kiir();  // a method named kiir (not used in this example)
};
```

* Class `b` has a method called `kiir()`, but **does NOT** have a method called `print()`.

---

### Template Function:

```cpp
template <typename T1, typename T2>
void reach() {
    T1 first;
    T2 second;

    first.id = 23; // OK: class a has an 'id' member

    // second.print();  // This line would cause a compilation error
    // because class b does not have a 'print()' method.
}
```

* This function creates one object each of type `T1` and `T2`.
* `first.id = 23;` is valid if `T1` has an `id` member — which is true for `a`.
* The commented line `second.print();` **would cause a compile-time error** because `b` has no `print()` method.

  * Even though `b` has `kiir()`, it’s not relevant because the code tries to call a method named `print()`.

---

### `main()` Function:

```cpp
int main() {
    reach<a, b>();  // Substitutes a for T1 and b for T2
    return 0;
}
```

* This works **only because** the `print()` line is **commented out**.
* If it were active, the compiler would fail when generating the version of `reach<a, b>()`.

---

### Purpose of This Example:

To show that:
✅ Templates **assume** certain capabilities in the substituted types
❌ If the type **doesn’t match the assumption**, it results in a **compilation error**
➡️ The error only appears when the template is instantiated (i.e., when used)

---

Would you like to see this concept visualized with error output or a working fix?





### Slide 15 – Explanation: `typename` in C++

In templates, the `typename` keyword is required to clarify that a dependent name refers to a **type**, not a value or member.

---

### Problem:

In this example:

```cpp
template<class T> class X {
    typename T::Y m_y; // T::Y is a type
};
```

* `T` is a **template parameter** (a type).
* `T::Y` depends on `T`, so the compiler can’t know if `Y` is:

  * a type (e.g., a `typedef` or `using` alias), or
  * something else (e.g., a static member variable).

Without `typename`, the compiler **assumes it’s a value**, which leads to an error if `Y` is actually a type.

---

### Solution:

Use `typename` to **tell the compiler explicitly**:

> “T::Y is a type.”

---

### Summary:

✅ Use `typename` before dependent types in templates (e.g., `T::Y`)
❌ Not needed for non-dependent names (e.g., `int`, `std::string`)

---

Would you like to see a full working example with such a class?


**Slide 16 – English Translation: Calling Template Functions in C++**

* A specific function is generated **only when** a template function is first called with a particular set of template parameters.
* If the template function is called again with the **same parameters**, the **previously generated version** is reused.
* If it's called with **different parameters**, a **new version** is generated.

🔍 **Syntax checking** of the template function happens **at the moment it's instantiated**, not when it’s defined.







**Slide 17 – English Translation: Calling Template Functions (C++)**

* **Syntax:**
  `functionName<T1, T2, ...>(p1, p2, ...);`

* The **template parameters** must be placed **between angle brackets (`<>`)** directly after the function name, and **before** the function arguments.

* Template parameters can also include **constants**, not just types.







**Slide 19 – English Translation: Calling Template Functions with Type Deduction (C++)**

* Often, template parameters appear in the types of function arguments.

* This allows the compiler to **deduce the template parameters automatically** from the arguments.

* So, **you can omit the template parameters** in the function call:

  * You can specify the first few explicitly and let the compiler deduce the rest.

* ⚠️ For **reference types**, the deduced template type must exactly match the function argument type.

  * Example: `mySwap<double>(x, y);` will **fail** if `x` is an `int`.

* ⚠️ **Overloaded template operators** can **only** be called using **type deduction**, not by explicitly specifying template parameters.

```cpp
#include <iostream>
using namespace std;
template< typename T1, typename T2>
void print(T1 a, T2 b) {
cout << a << endl;
cout << b << endl;
}
int main() {
int x=3;
double y=2;
print<int>(x, y); // <int, double>
print(x, y); // <int, double>
print<double>(x, y); // <double, double>, implicit type conversion of parameter 1
return 0;
}
```

### Explanation of the Code

This example shows how to **call a function template** in different ways, demonstrating **explicit and implicit template parameter usage**, and what happens when type conversion occurs.

---

### Code Breakdown

#### 1. **Template Function Definition**:

```cpp
template< typename T1, typename T2>
void print(T1 a, T2 b) {
    cout << a << endl;
    cout << b << endl;
}
```

* A function template `print` with two **template type parameters**: `T1` and `T2`.
* It takes two parameters `a` and `b`, and prints them.

---

#### 2. **Main Function**:

```cpp
int main() {
    int x = 3;
    double y = 2;
```

#### a. **Explicit template parameters**:

```cpp
    print<int>(x, y); // T1 = int, T2 deduced as double
```

* T1 is explicitly set to `int`, and `T2` is **deduced from `y`**, which is a `double`.

#### b. **Implicit template parameters (deduction)**:

```cpp
    print(x, y); // T1 = int, T2 = double
```

* Compiler deduces both `T1` and `T2` from the function arguments.
* `x` is `int`, `y` is `double`, so the result is the same as above.

#### c. **Mismatched explicit type**:

```cpp
    print<double>(x, y); // T1 = double, T2 deduced as double
```

* Here, `T1` is **explicitly set to double**, but `x` is an `int`.
* The compiler converts `x` from `int` to `double` implicitly.
* Now both parameters are treated as `double`.

---

### Output:

```
3
2
3
2
3
2
```

(Last one is technically `3.0` and `2.0`, but console output might not show decimals unless set.)

---

### Key Concepts:

* ✅ Templates can deduce types automatically.
* ✅ You can specify some or all template parameters.
* ⚠️ Be careful with **type conversions** when explicitly setting template parameters.

Would you like to see this extended with a third type or an overload?













**Slide 20 – English Translation: Generating Template Functions (C++)**

* You can declare a template function **without calling it**, like this:

  ```cpp
  template returnType functionName<T1, T2, ...>(param1, param2, ...);
  ```

* This is useful when you're building **library (.lib) files**:

  * You might not use the template function in your current code,
  * but another **module** that links to the library **will use it**.

⚠️ In such cases, **the compiler needs to see the full template definition** in order to generate the correct version during linking.






**Slide 21 – English Translation: Specialization of Template Functions (C++)**

* A **template function** defines a **family of functions** for different types.
* You can specify that **certain versions** of the function behave differently.

  * To do this, you provide a **special implementation** (a new function body) for specific type(s).

This is called **template specialization** and is useful when a particular type needs custom handling.






**Slide 22 – English Translation: Specializing Template Functions (C++)**

* **Syntax for full specialization**:

  ```cpp
  template<>
  returnType functionName<ConcreteType1, ConcreteType2>(param1, param2, ...) {
      // custom implementation
  }
  ```

* `T1`, `T2`, etc., must be **concrete types** (e.g., `int`, `char*`, not template parameters).

* ⚠️ **Partial specialization** (e.g., specializing only `T1` while keeping `T2` generic) is **not allowed** for functions.

* ✅ If the template parameters can be **deduced from the function arguments**, the `<T1, T2, ...>` part can be **omitted** in the call.




```cpp
#include <iostream>
using namespace std;
template<typename T1, typename T2>
void print(T1 a, T2 b) {
cout << a << endl;
cout << b << endl;
}
template<>
void print<char*, char*>(char* a, char*
b) {
cout << "string:" << a << endl;
cout << "string:" << b << endl;
}

// ---- MAIN
int main() {
int x=3;
double y=2;
char t[]="Toto", k[]="Kansas";
print(x, y);
print(t, k); // a speciális függvény hívódik meg
return 0;
}
```

### Explanation of the Code: Template Function Specialization Example

This code demonstrates **template function specialization** in C++. It shows how a general template can have a **custom implementation** for a specific type combination.

---

### 1. **General Template Function**:

```cpp
template<typename T1, typename T2>
void print(T1 a, T2 b) {
    cout << a << endl;
    cout << b << endl;
}
```

* This is a generic function that prints any two values.
* Works for types like `int`, `double`, etc.

---

### 2. **Specialized Version for `char*`**:

```cpp
template<>
void print<char*, char*>(char* a, char* b) {
    cout << "string:" << a << endl;
    cout << "string:" << b << endl;
}
```

* This is a **specialization** of the `print` function for when **both parameters are `char*` (C-style strings)**.
* It adds `"string:"` before each output to distinguish it from default printing.

---

### 3. **Main Function**:

```cpp
int main() {
    int x = 3;
    double y = 2;
    char t[] = "Toto", k[] = "Kansas";
```

#### a. `print(x, y);`

* Calls the **generic template version**: `T1 = int`, `T2 = double`.

#### b. `print(t, k);`

* `t` and `k` are `char[]`, which decay to `char*` when passed to functions.
* So this matches the **specialized version**:

  ```cpp
  print<char*, char*>(t, k);
  ```
* The specialized version is called, and it adds `"string:"` before the output.

---

### 4. **Output**:

```
3
2
string:Toto
string:Kansas
```

---

### Summary:

✅ Shows **default vs. specialized behavior**
✅ Useful when you want a **custom version** for specific types (like strings)
✅ Ensures better formatting or behavior for certain data types

Would you like to see a version for `std::string` too?


**Slide 24 – English Translation: Overloading Template Functions (C++)**

* Template functions can be **overloaded**, just like regular functions.

  * You can overload a template with:

    * another **template function**, or
    * a **non-template (regular) function**.

* To avoid ambiguity between overloaded versions, it's recommended to **explicitly specify template parameters** when calling.

* ⚠️ Different compilers may resolve overloads **differently**.

* ✅ Typically, **non-template functions take precedence** over template functions when both match.


```cpp
#include <iostream>
using namespace std;
template<class T> void f(T x, T y) {
cout << "Template" << endl;
}
void f(int w, int z) {
cout << "Non-template" << endl;
}
int main() {
f( 1 , 2 ); // non-template
f('a', 'b'); // template
// f(1 , 'b'); /* ibm compiler calls non template, ms halt with error */
f<int>(1 , 'b'); // template (there is template para.)
return 0;
}

```


### Explanation: Template Function Overloading Example

This code illustrates how **template functions** and **non-template (regular) functions** can coexist and be **overloaded**, and how the compiler decides which one to call.

---

### 1. **Template Function Definition**:

```cpp
template<class T> void f(T x, T y) {
    cout << "Template" << endl;
}
```

* Generic function that works with any type `T`, as long as both arguments are of the **same type** (`T`).
* If the types differ (e.g., `int` and `char`), it won’t match automatically unless you force it.

---

### 2. **Non-template Function Definition**:

```cpp
void f(int w, int z) {
    cout << "Non-template" << endl;
}
```

* Regular function that matches **only if both arguments are `int`**.

---

### 3. **Main Function Calls**:

```cpp
int main() {
    f(1, 2);           // Matches regular function (int, int)
```

* ✅ This calls the **non-template** version.
* Non-template functions take **priority** when an exact match is found.

```cpp
    f('a', 'b');       // Matches template function (char, char)
```

* ✅ No matching non-template function for `char`, so the **template** is used with `T = char`.

```cpp
    // f(1, 'b');      // Ambiguous: int and char → different types
```

* ❌ Commented out because it's **ambiguous**.

  * Some compilers (like IBM's) might convert `'b'` to `int` and call the non-template.
  * Others (like MSVC) might raise an error because **types differ** and no exact match exists.

```cpp
    f<int>(1, 'b');    // Forces template version with T = int
```

* ✅ Here, you **explicitly tell** the compiler to use the template with `T = int`.
* `'b'` (a `char`) is **converted to `int`**, so both arguments match `T = int`.

---

### Output:

```
Non-template
Template
Template
```

---

### Key Takeaways:

* 🧠 **Non-template functions have higher precedence** if they match exactly.
* ⚠️ Mixed-type arguments may cause ambiguity unless:

  * You use **explicit template arguments** (`f<int>(...)`), or
  * You ensure both parameters are the same type.
* ✅ Templates are flexible, but compiler behavior **can vary** across platforms.

Would you like a version with three overloaded options (template, non-template, partial)?


**Slide 26 – English Translation: Templates vs. Macros and `void*` Parameters**

* Before templates existed, it was still possible to write functions that worked with different types.

---

### 1. **Parameterized Macros**:

* Used preprocessor macros (e.g., `#define`) to mimic generic functions.
* **Drawbacks**:

  * Code may be **evaluated multiple times**, leading to bugs or inefficiency.
  * **Hard to debug** and lacks type safety.

---

### 2. **`void*` Parameters**:

* Functions used `void*` to accept any pointer type.
* **Problems**:

  * **No type information** is preserved.
  * **No type checking** at compile time.
  * **Can't use type-specific features** (like constructors, operators, or destructors).

---

### Templates solve these issues:

✅ Type safety
✅ Supports operators, constructors, destructors
✅ Easier to debug and maintain than macros or `void*`-based code

Would you like to see a comparative example using all three approaches?


**Slide 27 – English Translation: Template Classes**

* Template classes are typically used to represent **data structures**, where the type of stored data is a **template parameter**.

  * Examples: **queue**, **stack**, **tree**, etc.

---

### Key Points:

* In template classes, **type deduction is not possible** — you **must specify** the template parameters.

* The class **name always includes** the template parameters (outside the class definition):

  ```cpp
  className<T1, T2, ...> obj;
  ```

* This rule applies **everywhere**, except in the **class definition itself**.

---

✅ Template classes allow reusable and type-safe containers
❌ But require **explicit type specification** when used

Would you like a full example of a `Stack<T>` class?



**Slide 28 – English Translation: Creating Template Classes**

* **C++ syntax** for defining a template class:

  ```cpp
  template <typename T1, typename T2, ...>
  class className {
      // class members and methods
  };
  ```

* When **creating an object**, you must **explicitly specify** the types:

  ```cpp
  className<int, double> obj(1, 2.0);
  ```

---

✅ This lets you create a single class that works with many different type combinations.
⚠️ Template parameters must always be provided when **instantiating** the class.










```cpp
template <class T, int i>

class TempClass {
public:
    TempClass() {arraysize=i;}
    ~TempClass() {}
int MemberSet(T a, int b) {}
private:
    T Tarray[i];
    int arraysize;
};

int main() {
    TempClass<double, 6> obj;
    return 0;
}
```

### Explanation of the Code: Template Class with Type and Constant Parameters

This example shows how to define and use a **C++ template class** that takes both:

* a **type parameter** (`T`)
* a **non-type constant parameter** (`int i`)

---

### 1. **Class Definition:**

```cpp
template <class T, int i>
class TempClass {
```

* `T`: the type of elements in the internal array (e.g., `double`)
* `i`: the size of the array, known at **compile time**

#### Members:

```cpp
T Tarray[i];          // Fixed-size array of type T
int arraysize;
```

* `Tarray`: statically allocated array of type `T` with `i` elements
* `arraysize`: stores the value of `i`

#### Constructor:

```cpp
TempClass() { arraysize = i; }
```

* Sets `arraysize` to the template constant `i` when an object is created

#### Destructor:

```cpp
~TempClass() {}
```

* Empty destructor — included for completeness or future use

#### Member Function (incomplete):

```cpp
int MemberSet(T a, int b) {}
```

* Declares a method that takes a value of type `T` and an `int`, but its body is **missing** (so it doesn't return a value yet, which would cause a warning or error during compilation).

---

### 2. **Usage in `main()`**:

```cpp
int main() {
    TempClass<double, 6> obj;
    return 0;
}
```

* Creates an object `obj` where:

  * `T = double`
  * `i = 6`
* Internally, `Tarray` becomes `double[6]`

---

### Summary:

✅ Shows how to use **mixed template parameters** (type + constant)
✅ Statically allocates an array using a compile-time constant
⚠️ The `MemberSet` function is incomplete — would need to define its body and return an `int`

Would you like a working version of `MemberSet()` added to make this class usable?


**Slide 30 – TL;DR (English): Notes**

* Clearly document what **capabilities** template parameters are expected to have.
* **Thorough testing** is even more important than with regular functions.
* In C++, a **template class can't be split** into `.h` and `.cpp` files because the compiler needs the full definition to generate code.

  * Template code is typically **written entirely in headers**.





**Slide 31 – English Translation: Default Template Parameters (C++)**

* Default values for template parameters are **allowed only in class templates**, not in function templates.
* **Syntax:**

  ```cpp
  template<typename T1 = defaultType>
  ```
* Default parameters must be placed at the **end of the parameter list**.

 
  
```cpp
template<typename T1, typename T2 = double,
int size=3> class X2 {
int store[size];
T1 a;
T2 b;
};
int main() {
X2<int> x2;
return 0;
}
```


### Explanation of the Code: Template Class with Default Parameters

This C++ code demonstrates how to define and use a **template class** with **default template parameters**.

---

### 1. **Template Class Definition**

```cpp
template<typename T1, typename T2 = double, int size = 3>
class X2 {
    int store[size];  // Fixed-size array
    T1 a;             // Member of type T1
    T2 b;             // Member of type T2 (default is double)
};
```

#### Template Parameters:

* `T1`: required type (no default)
* `T2`: optional, defaults to `double`
* `size`: optional, defaults to `3`

So, this class can be used in multiple ways:

* `X2<int>` → `T1 = int`, `T2 = double`, `size = 3`
* `X2<char, float>` → `T1 = char`, `T2 = float`, `size = 3`
* `X2<long, char, 10>` → `T1 = long`, `T2 = char`, `size = 10`

---

### 2. **Main Function**

```cpp
int main() {
    X2<int> x2;
    return 0;
}
```

* Creates an instance of `X2` with only `T1 = int` specified.
* The defaults are applied:

  * `T2 = double`
  * `size = 3`
* So internally:

  ```cpp
  int store[3];
  int a;
  double b;
  ```

---

### Summary:

✅ Shows how to define **default template parameters**
✅ Reduces code repetition for common cases
⚠️ Only the **last** template parameters can have default values

Would you like to add constructors or print methods to see it in action?





# Standard Template Library

**Slide – English Translation: Standard Template Library (STL)**

* In **1990**, Alex Stepanov and Meng Lee at **Hewlett Packard Laboratories** extended the C++ language with a library of **class and function templates**, which they named the **STL** (Standard Template Library).
* In **1994**, the STL was officially accepted as part of the **ANSI/ISO C++ standard**.


**Slide – English Translation: Standard Template Library (STL)**

* The STL consists of **three core components**:

  * **Containers**: General-purpose class templates for data storage.
  * **Algorithms**: General-purpose function templates for operating on containers.
  * **Iterators**: General-purpose “smart” pointers that:

    * Simplify the use of containers
    * Provide an interface for STL algorithms

* During standardization, **`string` (character sequences)** was also included as a **special type of container**.


**Slide – English Translation: Advantages of STL Containers**

* STL containers offer a **wide variety of data structures**.
* Their **time and space complexity** is well-defined and predictable.
* Container sizes can **automatically grow and shrink** as needed.
* STL provides **built-in algorithms** to process the data in containers.
* STL includes **iterators**, which make containers and algorithms both **flexible and efficient**.


**Slide – English Translation: Types of STL Containers**

* **Sequence containers**: Store elements in a **fixed order** (e.g., `vector`, `list`).
* **Associative containers**: Store elements **sorted by content** (e.g., `set`, `map`).
* **Container adaptors**: Built on top of the above containers to provide **specialized interfaces** (e.g., `stack`, `queue`).



**Slide – English Translation: Sequential STL Containers**

Sequential containers (also called **sequence containers**) maintain the **order of elements** as they are inserted. Examples include:

* **`vector`** – dynamic array
* **`list`** – doubly linked list

These containers are ideal when the **sequence matters** and you need **predictable iteration order**.



### Explanation: **STL `vector` Basics**

The `vector` is one of the most commonly used **sequence containers** in the Standard Template Library (STL). It behaves like a **dynamic array** that can grow or shrink in size.

---

### ✅ **1. Including the vector header:**

```cpp
#include <vector>
using namespace std;
```

* You must include `<vector>` to use the `vector` class.
* `using namespace std;` allows you to write `vector` instead of `std::vector`.

---

### ✅ **2. Creating a vector:**

```cpp
vector<int> v(5, 10);
```

* Creates a `vector` named `v` of type `int`.
* It has **5 elements**, each initialized to **10**.
* General syntax:

  ```cpp
  vector<type> name(size, initial_value);
  ```

---

### ✅ **3. Accessing elements:**

#### a. **Using `[]` operator:**

```cpp
v[0];  // Access the first element (index starts at 0)
```

* Fast, but **no bounds checking** — undefined behavior if index is out of range.

#### b. **Using `.at(index)`:**

```cpp
v.at(0);  // Also accesses the first element
```

* Performs **bounds checking**.
* Throws an `std::out_of_range` exception if you try to access an invalid index.

---

### ⚠️ Example:

```cpp
vector<int> v(3, 1); // {1, 1, 1}
cout << v[5];        // undefined behavior (no error, but invalid)
cout << v.at(5);     // throws std::out_of_range
```

---

### Summary:

* `vector` = dynamic array
* `[]` is fast but unsafe
* `.at()` is safer but slightly slower (due to error checking)

Would you like to see how to add, remove, or resize vector elements next?


### Explanation: **STL `vector` – Common Operations**

These are frequently used methods to manipulate the contents of a `vector` in C++.

---

### ✅ 1. **Reassign All Elements**

```cpp
v.assign(count, value);
```

* Replaces the vector’s contents with `count` copies of `value`.
* Example:

  ```cpp
  vector<int> v;
  v.assign(4, 7);  // v = {7, 7, 7, 7}
  ```

---

### ✅ 2. **Resize the Vector**

```cpp
v.resize(new_size);
```

* Changes the number of elements in the vector.
* If the new size is **larger**, default-initialized elements are added.
* If **smaller**, excess elements are removed.
* Example:

  ```cpp
  v.resize(10);  // Expand or shrink to 10 elements
  ```

---

### ✅ 3. **Add Element to the End**

```cpp
v.push_back(value);
```

* Adds a new element to the **end** of the vector.
* Example:

  ```cpp
  v.push_back(5);  // Adds 5 at the end
  ```

---

### ✅ 4. **Remove Last Element**

```cpp
v.pop_back();
```

* Removes the **last** element of the vector.
* Example:

  ```cpp
  v.pop_back();  // Removes last element
  ```

---

### Summary Table:

| Operation        | Purpose                                |
| ---------------- | -------------------------------------- |
| `assign(n, val)` | Replaces all elements with `n` × `val` |
| `resize(n)`      | Adjusts vector size to `n`             |
| `push_back(val)` | Adds `val` to the end                  |
| `pop_back()`     | Removes last element                   |

Would you like examples for inserting or deleting elements at specific positions too?


### Explanation: **STL `vector` – Inserting and Erasing Elements**

You can insert or remove elements from **any position** in a `vector` using iterators.

---

### ✅ 1. **Insert an Element**

```cpp
vector_name.insert(position, value);
```

* Inserts `value` **before** the given position.
* The `position` is given using an **iterator**, like `begin() + index`.

**Example:**

```cpp
vector<int> v = {1, 2, 3};
v.insert(v.begin() + 1, 99);  // v = {1, 99, 2, 3}
```

---

### ✅ 2. **Erase an Element**

```cpp
vector_name.erase(position);
```

* Removes the element **at** the given position.

**Example:**

```cpp
v.erase(v.begin() + 2);  // Removes the 3rd element
```

---

### ✅ 3. **How to Specify the Position**

* `v.begin()` → iterator to the **first** element
* `v.begin() + n` → iterator to the **(n+1)th** element
* `v.end()` → iterator **after** the last element
* `v.end() - n` → iterator to the **nth element from the end**

**Example:**

```cpp
v.insert(v.end() - 1, 77);  // Insert before last element
v.erase(v.end() - 1);       // Remove last element
```

---

### Summary:

| Operation          | Description                           |
| ------------------ | ------------------------------------- |
| `insert(pos, val)` | Insert `val` before `pos`             |
| `erase(pos)`       | Remove element at `pos`               |
| `begin() + n`      | Iterator to position `n` (0-based)    |
| `end() - n`        | Iterator to n-th element from the end |

Would you like to see an example using a loop and `insert()`/`erase()` dynamically?



### Explanation: **STL `vector` – Insert and Erase at Beginning or End**

These are common operations for modifying the **start** or **end** of a `vector` using iterators.

---

### ✅ 1. **Insert at the Beginning**

```cpp
vector_name.insert(vector_name.begin(), value);
```

* Inserts `value` **before the first element**.

**Example:**

```cpp
vector<int> v = {2, 3};
v.insert(v.begin(), 1);  // v = {1, 2, 3}
```

---

### ✅ 2. **Insert at the End**

```cpp
vector_name.insert(vector_name.end(), value);
```

* Inserts `value` **at the end** (same as `push_back()`).

**Example:**

```cpp
v.insert(v.end(), 4);  // v = {1, 2, 3, 4}
```

---

### ✅ 3. **Erase the First Element**

```cpp
vector_name.erase(vector_name.begin());
```

* Removes the **first element**.

**Example:**

```cpp
v.erase(v.begin());  // v = {2, 3, 4}
```

---

### ✅ 4. **Erase the Last Element**

```cpp
vector_name.erase(--vector_name.end());
```

* `vector_name.end()` points **past the last element**, so `--vector_name.end()` targets the **last** one.
* Removes the **last element**.

**Example:**

```cpp
v.erase(--v.end());  // v = {2, 3}
```

---

### Summary:

| Action              | Code                        |
| ------------------- | --------------------------- |
| Insert at beginning | `v.insert(v.begin(), val);` |
| Insert at end       | `v.insert(v.end(), val);`   |
| Erase first element | `v.erase(v.begin());`       |
| Erase last element  | `v.erase(--v.end());`       |

Would you like a full working code snippet showing these four operations in sequence?




### Explanation: **STL `vector` – Size and Special Case for `bool`**

---

### ✅ 1. **Getting the Size of a Vector**

```cpp
v.size();
```

* Returns the **number of elements** currently stored in the vector.
* Type: `size_t` (unsigned integer)
* Example:

  ```cpp
  vector<int> v = {1, 2, 3};
  cout << v.size();  // Output: 3
  ```

---

### ✅ 2. **Special Case: `vector<bool>`**

* Although declared like other vectors:

  ```cpp
  vector<bool> flags(8, true);
  ```
* Internally, **`vector<bool>` is optimized** to **store each `bool` as a single bit**, not a full byte or `int`.

  * This saves memory: 8 values can fit in 1 byte.
  * But it behaves differently from other vectors:

    * **Access returns a proxy object**, not a reference to a `bool`.
    * Some operations (like taking address of an element) are restricted.

---

### Summary:

| Feature        | Usage             | Notes                                  |
| -------------- | ----------------- | -------------------------------------- |
| Size of vector | `v.size()`        | Returns element count                  |
| `vector<bool>` | Optimized storage | Stores booleans as bits (space-saving) |

Would you like to compare `vector<bool>` vs `vector<char>` memory usage in a sample program?



```cpp
template <class_Tp, class_alloc=allocator <_Tp> >
// a második sablon paraméternek van
// alapértelmezett értéke
class vector:protected _Vector base <_Tp, _Alloc>{
private:
typdef vector<_Tp, _Alloc c> vector_type;
public:
typdef _Tp value_type;
typdef value_type* pointer;
typdef const value_type* const _pointer;
```

### Explanation: **Types Defined Inside the STL `vector` Class**

The `vector` class in the STL defines several **type aliases** (typedefs) to make working with its internal types easier and more consistent.

---

### ✅ Template Declaration:

```cpp
template <class _Tp, class _Alloc = allocator<_Tp> >
```

* `_Tp`: the type of elements stored in the vector (e.g., `int`, `double`)
* `_Alloc`: the **allocator type**, defaulting to `allocator<_Tp>`

---

### ✅ Class Definition Snippet:

```cpp
class vector : protected _Vector_base<_Tp, _Alloc> {
```

* `vector` inherits from an internal helper base class that manages memory allocation.

---

### ✅ Type Definitions (Typedefs):

Inside the class, these aliases are defined to simplify type handling:

```cpp
typedef _Tp value_type;
```

* `value_type` is an alias for the type stored in the vector (e.g., `int` if `vector<int>`).

```cpp
typedef value_type* pointer;
```

* `pointer` is a pointer to the stored type (e.g., `int*`).

```cpp
typedef const value_type* const_pointer;
```

* `const_pointer` is a **pointer to a const value\_type** (e.g., `const int*`).

These typedefs are useful in **generic programming** and **iterator implementation**, where the actual type isn't known ahead of time.

---

### Summary Table:

| Typedef         | Meaning                  | Example (`vector<int>`) |
| --------------- | ------------------------ | ----------------------- |
| `value_type`    | Type of stored element   | `int`                   |
| `pointer`       | Pointer to element       | `int*`                  |
| `const_pointer` | Pointer to const element | `const int*`            |

Would you like a practical example using `value_type` or `pointer` in custom code?


### Explanation: **STL `vector` Iterator**

The STL `vector` class defines its own **iterator type** to allow traversal of elements using standard syntax like in a loop.

---

### ✅ Internal Typedef:

```cpp
typedef __gnu_cxx::_normal_iterator<pointer, vector_type> iterator;
```

This defines the `iterator` type used by `vector`. Here's what it means:

* **`__gnu_cxx::_normal_iterator`**:
  An internal implementation of an iterator in GNU's libstdc++ (used by GCC).

* **Template parameters**:

  * `pointer`: typically `T*` — a pointer to the vector's element type.
  * `vector_type`: the specific instantiation of the vector (e.g., `vector<int>`).

So the resulting `iterator` behaves like a **pointer with enhanced capabilities**, enabling:

* Increment (`++it`)
* Dereference (`*it`)
* Comparison (`it != end()`)

---

### ✅ Usage Example:

```cpp
vector<int>::iterator it;
for (it = v.begin(); it != v.end(); ++it) {
    cout << *it << endl;
}
```

---

### Summary:

| Feature        | Description                                   |
| -------------- | --------------------------------------------- |
| `iterator`     | A typedef for a random-access iterator        |
| Implementation | Based on `__gnu_cxx::_normal_iterator` in GCC |
| Purpose        | Enables safe and flexible element traversal   |

Would you like to see a custom function that accepts a `vector<int>::iterator`?






### Explanation: **Accessing Type Aliases in STL `vector`**

STL container classes like `vector` define several **internal type aliases** (typedefs) to make generic programming easier.

---

### ✅ Syntax:

```cpp
ClassName<Type>::TypeName
```

* This accesses a type (like `value_type` or `iterator`) defined **inside** a class template (e.g., `vector`).

---

### ✅ Examples:

```cpp
vector<int>::value_type
```

* Refers to the type stored in the vector → `int`.

```cpp
vector<int>::pointer
```

* A pointer to the stored type → `int*`.

```cpp
vector<int>::const_pointer
```

* A pointer to a constant stored type → `const int*`.

```cpp
vector<int>::iterator
```

* An **iterator** type that can traverse elements of `vector<int>` — behaves like a smart `int*`.

---

### Why is this useful?

These typedefs are especially helpful in **template/generic code**, where the exact type (e.g., `int`, `double`, etc.) isn’t known in advance.

**Example usage in code:**

```cpp
vector<float>::value_type x = 3.14f;  // x is float
vector<string>::iterator it;
```

Would you like a function that prints the type info using these typedefs?




### Slide 48 – Explanation: **Most Important Operators for STL Iterators**

STL iterators (like those in `vector`) behave similarly to pointers and support common operations to navigate and access elements.

---

### ✅ Common Operators for an Iterator `p`:

| Operator      | Description                                   |
| ------------- | --------------------------------------------- |
| `++p` / `p++` | Move to the **next** element (prefix/postfix) |
| `--p` / `p--` | Move to the **previous** element              |
| `*p`          | Access the **value** the iterator points to   |

---

### ✅ Example:

For a `vector<int>::iterator p`:

```cpp
vector<int> v = {10, 20, 30};
vector<int>::iterator p = v.begin();

cout << *p;   // Output: 10
++p;
cout << *p;   // Output: 20
```

* The type of `p` is:
  `__normal_iterator<int*, vector<int>>` (in GCC/libstdc++)

* The result of `*p` is equivalent to dereferencing an `int*`, so it gives an `int`.

---

### Summary:

* STL iterators behave like **smart pointers**.
* They support **increment, decrement, and dereferencing**.
* Knowing these operators is key to using `for` loops and algorithms with STL containers.

Would you like to see a live iterator loop example over a `vector`?





### Explanation: **Iterator Access Functions in STL `vector`**

STL vectors provide built-in functions to access iterators that help you navigate through the elements.

---

### ✅ 1. `v.begin()`

* Returns an **iterator to the first element** of the vector.
* Example:

  ```cpp
  *v.begin();  // Value of the first element
  ```

---

### ✅ 2. `v.end()`

* Returns an **iterator to one past the last element**.
* It does **not** point to a valid element — it's used as a stopping condition in loops.
* To get the **last element**, you must **decrement** it:

  ```cpp
  *(--v.end());  // Value of the last element
  ```

---

### ✅ More Examples:

```cpp
*(v.begin())       // First element
*(++v.begin())     // Second element
*(--v.end())       // Last element
```

---

### Summary:

| Function    | Description                        |
| ----------- | ---------------------------------- |
| `v.begin()` | Iterator to the **first element**  |
| `v.end()`   | Iterator **past the last element** |
| `*it`       | Access the value at iterator `it`  |

Would you like a full `for` loop example using `begin()` and `end()`?




### Explanation: **Traversing a `vector` Using an Iterator (Example)**

This function demonstrates how to **iterate through a `vector<int>`** using an explicit iterator and print its contents.

---

### ✅ Code Breakdown:

```cpp
void Print(const vector<int> &v) {
    for (vector<int>::iterator i = v.begin();  // start at first element
         i != v.end();                          // stop just after last element
         i++) {                                 // move to next element
        cout << *i << ',';                      // print the value pointed to by iterator
    }
    cout << endl;
}
```

* `vector<int>::iterator i`: declares an iterator `i` that works with a `vector<int>`.
* `v.begin()` gives the starting iterator (first element).
* `v.end()` gives an iterator past the last element (loop stops before it).
* `*i` dereferences the iterator to access the actual value.

---

### ✅ Example Usage:

```cpp
vector<int> nums = {10, 20, 30};
Print(nums);  // Output: 10,20,30,
```

---

### Summary:

* This is the **manual, iterator-based** way to loop through a vector.
* Safer and more generic than using indices — especially for non-random-access containers like `list`.

Would you like the same example rewritten with a range-based `for` loop or with `auto`?


**Slide 51 – English Translation: STL `vector` Properties**

* A `vector` is truly an **array**:

  * It stores elements of the **same type in a contiguous block of memory**.

---

### ✅ Advantages:

* **Fast access by index** (like `v[i]`)
* **Efficient memory management**
* **Fast insertion/removal at the end** (`push_back`, `pop_back`)

---

### ❌ Disadvantages:

* **Slow insertion/removal** at positions **other than the end**
* **Slow search by value**, since it requires a **linear scan**

---

STL `vector` is ideal when:

* You need fast random access
* Most insertions/removals happen at the end

Not ideal when:

* You need frequent insertions/removals in the middle or beginning (use `list` or `deque` instead)

Would you like a comparison between `vector`, `list`, and `deque`?




### Explanation: **STL `string` Basics**

The C++ Standard Template Library provides the `std::string` class to handle **text data** conveniently, built on top of dynamic memory management.

---

### ✅ 1. **Include and Namespace**

```cpp
#include <string>
using namespace std;
```

* You must include the `<string>` header.
* `using namespace std;` lets you write `string` instead of `std::string`.

---

### ✅ 2. **Key Properties**

* `std::string` offers **intelligent memory management**, similar to `vector`.

  * It grows and shrinks dynamically as needed.
  * It handles memory allocation and deallocation automatically.

---

### ✅ 3. **Multiple Constructors**

You can create a string in several ways:

| Constructor  | Example              | Description                           |
| ------------ | -------------------- | ------------------------------------- |
| Default      | `string s;`          | Empty string                          |
| From `char`  | `string s(1, 'a');`  | One character: `"a"`                  |
| From `char*` | `string s("hello");` | From C-style string (null-terminated) |
| Copy         | `string s2(s1);`     | Copy from another string              |

---

### Summary:

* `std::string` is a high-level, flexible text container.
* Offers easy construction, assignment, and manipulation like `+`, `=`, `.length()`, etc.
* Internally manages memory like `vector`.

Would you like a demo comparing `string` with `char*` operations?



### Explanation: **STL `string` Constructors**

The `std::string` class provides multiple constructors to create strings in different ways.

---

### ✅ 1. **Copy Constructor**

```cpp
string::string(const string &);
```

* Creates a **copy** of an existing `string`.
* Example:

  ```cpp
  string s1 = "hello";
  string s2(s1);  // s2 = "hello"
  ```

---

### ✅ 2. **Character Repetition Constructor**

```cpp
string::string(int count, char ch);
```

* Creates a string with **`count` copies** of the character `ch`.
* Example:

  ```cpp
  string s(5, 'x');  // s = "xxxxx"
  ```

---

### ✅ 3. **C-string Constructor**

```cpp
string::string(char*);
```

* Converts a **C-style string (`char*`)** into an `std::string`.
* Example:

  ```cpp
  char text[] = "world";
  string s(text);  // s = "world"
  ```

---

### Summary Table:

| Constructor             | Example             | Result       |
| ----------------------- | ------------------- | ------------ |
| `string(const string&)` | `string s2(s1);`    | Copy of `s1` |
| `string(int, char)`     | `string s(3, 'a');` | `"aaa"`      |
| `string(char*)`         | `string s("hi");`   | `"hi"`       |

Would you like to see how these compare when printing or using with `+` and `+=`?




### Explanation: **STL `string` Operators**

`std::string` supports several overloaded operators for assigning and concatenating string values. These make it behave much like built-in types, but with added flexibility.

---

### ✅ Assignment (`=`) Operators

You can assign a new value to a `std::string` using:

* Another `string`
* A single `char`
* A C-style string (`char*`)

**Examples:**

```cpp
string s;

// Assign from another string
s = string("hello");

// Assign a single character
s = 'A';        // s = "A"

// Assign from a C-style string
s = "world";    // s = "world"
```

---

### ✅ Concatenation (`+` and `+=`) Operators

You can concatenate strings using `+` or append with `+=`. These also work with:

* Another `string`
* A `char`
* A C-style string (`char*`)

**Examples:**

```cpp
string s1 = "hello";

// Using +
string s2 = s1 + " world";  // s2 = "hello world"
string s3 = s1 + '!';       // s3 = "hello!"

// Using +=
s1 += " there";             // s1 = "hello there"
s1 += '?';                  // s1 = "hello there?"
```

---

### Summary:

| Operation | Supports                  | Example       |
| --------- | ------------------------- | ------------- |
| `=`       | `string`, `char`, `char*` | `s = "text";` |
| `+`       | `string`, `char`, `char*` | `s + "world"` |
| `+=`      | `string`, `char`, `char*` | `s += '!';`   |

Would you like to see edge cases (e.g. chaining, empty strings, or mixing types)?








### Explanation: **STL `string` Index Operator**

Just like `vector`, the `std::string` class allows character access using **indexing**.

---

### ✅ 1. `s[i]` — Subscript Operator

```cpp
string s = "hello";
char c = s[1];  // 'e'
```

* Returns the **i-th character** in the string (0-based).
* ⚠️ **No bounds checking** — accessing out-of-range indices leads to **undefined behavior** (may crash or give garbage).

---

### ✅ 2. `s.at(i)` — Safe Access

```cpp
char c = s.at(1);  // 'e'
```

* Returns the **i-th character**, just like `s[i]`.
* ✅ **Performs bounds checking**:

  * If `i` is out of range, it throws a `std::out_of_range` exception.

**Example:**

```cpp
try {
    string s = "abc";
    char x = s.at(5);  // throws exception
} catch (out_of_range& e) {
    cout << "Index error: " << e.what() << endl;
}
```

---

### Summary:

| Access Method | Bounds Checked? | Safe to Use? | Throws on Error             |
| ------------- | --------------- | ------------ | --------------------------- |
| `s[i]`        | ❌ No            | ⚠️ Risky     | ❌ No                        |
| `s.at(i)`     | ✅ Yes           | ✅ Safe       | ✅ Yes (`std::out_of_range`) |

Would you like to see a loop example comparing `s[i]` vs `s.at(i)`?






```cpp
#include<iostream>
#include<string>
using namespace std;
int main(){
string s1(1,'a');
//1 db a
string s2 ("szó"); // szó
string s3 (s2);
// szó
cout<<"s1:"<<s1<<endl<<"s2:"
<<s2<<endl<<"s3:"<<s3<<endl;

```

### Explanation: C++ `std::string` Constructor Example

This code demonstrates how to use different **constructors of the `std::string` class** and print the results.

---

### ✅ Code Breakdown:

```cpp
#include <iostream>
#include <string>
using namespace std;
```

* Includes the necessary libraries for I/O and `std::string`.

---

```cpp
string s1(1, 'a');
```

* Uses the **`string(int, char)` constructor**.
* Creates a string `s1` with **1 copy** of the character `'a'`.
* `s1 = "a"`

---

```cpp
string s2("szó");
```

* Uses the **C-style string constructor** (`char*`).
* Initializes `s2` with the literal `"szó"` (Hungarian for "word").
* `s2 = "szó"`

---

```cpp
string s3(s2);
```

* Uses the **copy constructor**.
* Copies the content of `s2` into `s3`.
* `s3 = "szó"`

---

```cpp
cout << "s1:" << s1 << endl
     << "s2:" << s2 << endl
     << "s3:" << s3 << endl;
```

* Prints the values of all three strings.

---

### ✅ Output:

```
s1:a
s2:szó
s3:szó
```

---

### Summary of Constructors Used:

| Code             | Constructor Type     | Result  |
| ---------------- | -------------------- | ------- |
| `string(1, 'a')` | Character repetition | `"a"`   |
| `string("szó")`  | C-string constructor | `"szó"` |
| `string(s2)`     | Copy constructor     | `"szó"` |

Would you like to add string concatenation or manipulation next?




```cpp
s1='h'; s2="word"; s3=s1; // h
s1=s1+'2';
// h2
s2=s2+"word2"; // wordword2
s3=s1+s2;
// h2worsword2
s3=s2[0];
// s3 legyen az s2 első karaktere: w
s3+=s1[1]; // w2 lesz benne
cout<<endl<<"s1:"<<s1<<endl
<<"s2:"<<s2<<endl<<"s3:"<<s3<<endl;
return 0;
} // main()

```

### Explanation: C++ `std::string` Manipulation Example

This code demonstrates **basic string operations** like assignment, concatenation, indexing, and appending using `std::string`.

---

### ✅ Initial Setup:

```cpp
s1 = 'h';           // s1 = "h"
s2 = "word";        // s2 = "word"
s3 = s1;            // s3 = "h"
```

* Assigns a **char** `'h'` to `s1` → becomes `"h"` (automatically converted to string)
* `s2` gets the string literal `"word"`
* `s3` copies `s1`, so it also becomes `"h"`

---

### ✅ Concatenation:

```cpp
s1 = s1 + '2';      // s1 = "h2"
```

* Appends the character `'2'` to `"h"`

```cpp
s2 = s2 + "word2";  // s2 = "wordword2"
```

* Concatenates `"word2"` to `"word"`

```cpp
s3 = s1 + s2;       // s3 = "h2wordword2"
```

* Combines the new `s1` and `s2` into `s3`

---

### ✅ Character Access and Append:

```cpp
s3 = s2[0];         // s3 = "w"
```

* Gets the first character of `s2` (which is `'w'`) and assigns it to `s3`

```cpp
s3 += s1[1];        // s3 = "w2"
```

* Appends the **second character of `s1`** (which is `'2'`) to `s3`

---

### ✅ Final Output:

```cpp
cout << "s1:" << s1 << endl
     << "s2:" << s2 << endl
     << "s3:" << s3 << endl;
```

#### Output:

```
s1:h2
s2:wordword2
s3:w2
```

---

### Summary:

| Statement      | Result          |
| -------------- | --------------- |
| `s1 = 'h';`    | `"h"`           |
| `s1 + '2'`     | `"h2"`          |
| `s2 + "word2"` | `"wordword2"`   |
| `s3 = s1 + s2` | `"h2wordword2"` |
| `s3 = s2[0]`   | `"w"`           |
| `s3 += s1[1]`  | `"w2"`          |

Would you like to see this extended to work with user input or longer strings?


```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
string s1(1,'a'); // 1 db a
string s2 ("szó"); // szó
string s3 (s2); // szó
cout << "s1:"<< s1 << endl << "s2:" << s2<< endl << "s3:" << s3 << endl;
s1='h'; s2="word"; s3=s1; // h
s1=s1+'2';
// h2
s2=s2+"word2"; // wordword2
s3=s1+s2; // h2worsword2
s3=s2[0]; // s3 legyen az s2 első karaktere: w
s3+=s1[1]; // w2 lesz benne
cout << endl << "s1:" << s1 << endl << "s2:" << s2 << endl << "s3:" << s3 << endl;
return 0;
} // main()
```


### ✅ Full Explanation: C++ `std::string` Constructor and Manipulation Example

This program demonstrates how to create and manipulate `std::string` objects using different **constructors**, **assignments**, **concatenations**, and **indexing** operations.

---

### ✅ Full Code:

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1(1, 'a');         // Create string s1 = "a" (1 copy of 'a')
    string s2("szó");          // Create string s2 = "szó" (Hungarian: "word")
    string s3(s2);             // Copy s2 into s3 => s3 = "szó"

    cout << "s1:" << s1 << endl
         << "s2:" << s2 << endl
         << "s3:" << s3 << endl;

    // Modify the strings
    s1 = 'h';                  // Assigns single char → becomes "h"
    s2 = "word";               // Reassigns s2 to "word"
    s3 = s1;                   // Copies "h" into s3

    s1 = s1 + '2';             // Appends '2' → s1 = "h2"
    s2 = s2 + "word2";         // Concatenates "word2" → s2 = "wordword2"
    s3 = s1 + s2;              // s3 = "h2wordword2"

    s3 = s2[0];                // s3 = first character of s2 → "w"
    s3 += s1[1];               // Append second char of s1 ('2') → s3 = "w2"

    cout << endl
         << "s1:" << s1 << endl
         << "s2:" << s2 << endl
         << "s3:" << s3 << endl;

    return 0;
}
```

---

### ✅ Program Output:

```
s1:a
s2:szó
s3:szó

s1:h2
s2:wordword2
s3:w2
```

---

### ✅ What This Teaches:

| Concept                   | Example Code              | Result                            |
| ------------------------- | ------------------------- | --------------------------------- |
| Constructor: 1 char       | `string(1, 'a')`          | `"a"`                             |
| Constructor: C-string     | `string("szó")`           | `"szó"`                           |
| Copy constructor          | `string s3(s2)`           | `s3 = s2`                         |
| Char assignment to string | `s1 = 'h'`                | `"h"`                             |
| Concatenation with char   | `s1 = s1 + '2'`           | `"h2"`                            |
| Concatenation with C-str  | `s2 = s2 + "word2"`       | `"wordword2"`                     |
| Concatenation of strings  | `s3 = s1 + s2`            | `"h2wordword2"`                   |
| Indexing and appending    | `s3 = s2[0]; s3 += s1[1]` | `"w2"` (first char + second char) |

---

Would you like this rewritten using modern C++ features like `auto` and range-based loops?




# Summary

---

## Lecture Summary: C++ Templates, STL, Vector, and String

### Introduction and Motivation

The lecture began by highlighting the necessity of generic programming. In software development, programmers frequently encounter scenarios where the same logic or data structure needs to handle different data types. Traditionally, this required repetitive code and cumbersome maintenance. Templates in C++ provide a powerful solution, allowing developers to write generic and reusable code that works efficiently across multiple data types without redundancy.

### Roles and Objects in Object-Oriented Programming (OOP)

Before diving into templates, the lecture briefly revisited key OOP concepts:

* **Delegation:** An object passes responsibilities to another object that it knows or references. For instance, a warehouse manager delegates the task of transporting goods to a forklift operator. This delegation requires explicit references or pointers to other objects.

* **Compatibility via Inheritance:** An object might inherit necessary skills from a base class, enabling it to fulfill multiple roles directly. For example, if the warehouse manager also has forklift certification (inherits the forklift driver's capabilities), he can perform tasks independently.

### Templates in Object-Oriented Design

Templates elegantly generalize this role assignment by allowing objects to fulfill roles without explicit type compatibility or inheritance. Instead of enforcing strict type constraints, templates check at compile-time whether the provided types fulfill the necessary capabilities. Templates thus allow a more flexible and robust implementation of functionality.

### Introducing Templates in C++

Templates in C++ allow the definition of functions and classes where parameters and variables can differ by type at every invocation. A template can thus be seen as a general blueprint, accepting not just values but types as parameters. After instantiating the template with concrete types, it behaves exactly like any conventional class or function.

### Motivation for Template Functions

Historically, writing generic algorithms, such as sorting or min/max functions, required implementing separate functions for each data type. This approach leveraged polymorphism but was error-prone: modifications required multiple redundant edits. Templates eliminate this issue by providing one generic implementation that the compiler can adapt to any provided type, automatically generating specialized versions of the function or class at compile-time.

### Defining Template Functions

Template functions in C++ follow a clear syntax:

```cpp
template <typename T>
T min(T a, T b) {
    return (a < b) ? a : b;
}
```

Here, `typename T` defines a generic placeholder. When calling `min(5, 7)` or `min(5.2, 3.8)`, the compiler generates specific versions tailored to the types provided (`int`, `double`, etc.). This ensures type safety and maintains performance.

### Template Parameters and Their Types

Templates accept several kinds of parameters:

* **Type parameters (`typename` or `class`)**: Allow any type substitution, whether simple (int, char) or complex (classes).

* **Non-type template parameters**: Constant values known at compile time, often used to define array sizes or other compile-time constraints.

* **Template template parameters**: Templates accepting other templates as parameters, useful for meta-programming.

An example with mixed parameters was provided:

```cpp
template <typename T, int size>
void print() {
    T array[size];
    for (int i = 0; i < size; ++i) {
        array[i] = i;
        cout << array[i] << ',';
    }
}
```

### Assumptions about Template Parameters

Templates assume certain capabilities of their parameters. For instance, a template function for swapping values assumes the presence of assignment operators. If the provided type lacks these capabilities, compilation errors occur. Therefore, clear documentation and robust error-checking are crucial.

### Template Specialization and Overloading

Sometimes, the general template implementation doesn't suffice for certain types. Specialization enables writing custom behavior for specific type combinations:

```cpp
template <>
void print<char*, char*>(char* a, char* b) {
    cout << "string: " << a << ", " << b << endl;
}
```

Overloading template functions alongside regular functions is also possible. Non-template functions typically take precedence due to exact type matching, but explicit template parameter specification can force template selection when needed.

### Templates vs. Macros and void\*

Prior to templates, macros (`#define`) and generic pointers (`void*`) were common generic mechanisms. However, macros lacked type checking, caused multiple evaluations, and were notoriously difficult to debug. `void*` lacked type information, forcing manual typecasting and risking runtime errors. Templates provide a clean, type-safe, compile-time-checked solution, greatly improving maintainability and safety.

---

## Standard Template Library (STL)

The lecture then shifted focus to the Standard Template Library (STL), a crucial extension of C++ that emerged in 1990 through the work of Alex Stepanov and Meng Lee at Hewlett Packard Labs. By 1994, STL became part of the ANSI/ISO C++ standard.

### Components of STL

STL consists primarily of three parts:

* **Containers**: General-purpose data structures to store elements (`vector`, `list`, `set`, etc.).
* **Algorithms**: Generic functions for operating on containers (sorting, searching, etc.).
* **Iterators**: Abstractions that provide a uniform interface for traversing containers.

Additionally, the `string` class was standardized as a specialized container due to its frequent usage.

---

## STL Containers: vector

### Overview and Properties

The `vector` is a dynamic array container, holding elements in contiguous memory. Its advantages include:

* Fast, constant-time access via indexing (`v[i]`)
* Automatic memory management (expansion/shrinking)
* Efficient appending/removal at the end (`push_back`, `pop_back`)

Disadvantages of `vector` include:

* Slow insertion and removal at arbitrary positions
* Linear-time complexity for searching by content

### Common vector Operations

* Creating vectors: `vector<int> v(5, 1);` creates a vector with five elements initialized to 1.
* Accessing elements: `v[i]` (no bounds checking), `v.at(i)` (with bounds checking, throws exception).
* Inserting and deleting elements: `insert`, `erase`, `push_back`, and `pop_back` methods.
* Size management: `v.size()` returns element count, `resize` adjusts the vector size.

---

## STL Containers: string

The `std::string` class provides efficient management of character sequences, combining the benefits of dynamic arrays with convenient manipulation.

### Constructors and Assignment

Common constructors include:

* Default: `string s;`
* Repeated characters: `string s(5, 'a');` → "aaaaa"
* C-string: `string s("hello");`
* Copy constructor: `string s2(s1);`

Assignment operations accept characters, C-strings, or other strings. Concatenation and modification are easy using `+` and `+=` operators.

### Element Access and Indexing

The `string` class supports indexing similar to vectors. It offers:

* Subscript operator (`s[i]`): fast but unsafe (no bounds checking).
* `at(i)` method: safe access with bounds checking and exception throwing.

### Example Usage

The lecture provided examples demonstrating how strings can be manipulated and combined effectively, highlighting the ease of use and robustness of `std::string`.

---

## Iterators and Traversal

Iterators in STL containers like `vector` and `string` abstract away the underlying storage details. Typical iterator operations include increment (`++`), decrement (`--`), and dereferencing (`*`). Iterators are extensively used with STL algorithms and for-loops:

```cpp
for(vector<int>::iterator it = v.begin(); it != v.end(); ++it)
    cout << *it << endl;
```

---

## Important Lecture Notes and Best Practices

The lecture emphasized several critical points for working effectively with templates and STL:

* Always document assumed capabilities for template parameters clearly.
* Test templates thoroughly, as compilation errors may occur only when templates are instantiated.
* Template classes must be defined entirely within header files (`.h`), as splitting across headers and source files (`.cpp`) isn't feasible due to compilation requirements.
* Use default template parameters wisely to simplify class interfaces.

---

## Conclusion

Templates and the STL revolutionized how generic programming is performed in C++, providing powerful tools for type-safe, efficient, and reusable code. Containers such as `vector` and `string` exemplify these strengths, offering developers robust, easy-to-use abstractions for everyday programming tasks. Understanding these concepts and how to apply them effectively is essential for any advanced C++ programmer.

 