5.1.1.
#include <iostream> using namespace std;
const int DEFAULT_STACK_SIZE=5;
class stack { private: int elemnum, store[DEFAULT_STACK_SIZE];
bool isFull();
public: void Init() {elemnum=0;} bool isEmpty();
bool Push(const int n);
bool Pop(int &n);
};
bool stack::isFull() { return elemnum==DEFAULT_STACK_SIZE;
} bool stack::isEmpty() { return elemnum==0;
} bool stack::Push(const int n) { if (isFull()) return false;
store[elemnum++]=n;
return true;
} bool stack::Pop(int &n) { if (isEmpty()) return false;
n=store[--elemnum];
return true;
} int main() { stack *s=new stack;
s->Init();
char c;
int n;
do { cout<<"(p)ush\np(o)p\n(e)xit\n";
cout<<"Enter your selection : ";
cin>>c;
if (c=='p') { cout<<"Enter a number: ";
cin>>n;
if (s->Push(n)) cout<<"OK!\n";
} if (c=='o') { if (s->Pop(n)) cout<<n<<'\n';
} } while (c!='e');
delete s;
return 0;
} 
5.1.1. Készítsen egy verem osztályt, amely statikus, 5 nagyságú egész tömbben tárol értékeket! valósítsa meg a következő metódusokat: init, push, pop, isFull, isEmpty! Ötlet: egyértelműen definiálja, hogy a verem mutató az első szabad elemre vagy az utolsó használt elemre mutat-e! 
5.1.2.
#include <iostream> using namespace std;
const int DEFAULT_SIZE=1;
class stack { private: int elemnum, *store, size;
bool isFull();
public: void Init() {elemnum=0;
store=new int[DEFAULT_SIZE];
size=DEFAULT_SIZE;
} void increaseSize() { size*=2;
cout << "increasing size -> " << size << endl;
int* temp=new int[size];
for (int i=0;i<elemnum;i++) { temp[i]=store[i];
} delete[] store;
store=temp;
};
} bool isEmpty();
bool Push(const int n);
bool Pop(int &n);
bool stack::isFull() { return elemnum==size;
} bool stack::isEmpty() { return elemnum==0;
} bool stack::Push(const int n) { store[elemnum++]=n;
if (elemnum==size) { increaseSize();
} return true;
} bool stack::Pop(int &n) { if (isEmpty()) return false;
n=store[--elemnum];
return true;
} int main() { stack *s=new stack;
s->Init();
char c;
int n;
do { cout<<"(p)ush\np(o)p\n(e)xit\n";
cout<<"Enter your selection : ";
cin>>c;
if (c=='p') { cout<<"Enter a number:";
cin>>n;
if (s->Push(n)) cout<<"OK!\n";
} if (c=='o') { if (s->Pop(n)) cout<<n<<'\n';
} } while (c!='e');
delete s;
return 0;
} 
5.1.2. Valósítsa meg a vermet dinamikus tömbbel! Ha betelt a tömb, foglaljon le egy nagyobbat 5.2. Verem
5.2.1.
#include <stdio.h>
#include <stdlib.h> struct TElement { struct TElement * prev;
int Value;
};
struct TStack { struct TElement * Head;
int Count;
};
void InitStack(struct TStack * S) { S->Head = NULL;
S->Count = 0;
} void Push(struct TStack * S, int A) { struct TElement * Element = (struct TElement *)malloc(sizeof(struct TElement));
Element->Value = A;
if (S->Head == NULL) { Element->prev = NULL;
S->Head = Element;
} else { Element->prev = S->Head;
S->Head = Element;
} S->Count++;
} int Pop(struct TStack * S) { int res = 0;
if (S->Head != NULL) { struct TElement * E = S->Head;
res = E->Value;
S->Head = E->prev;
free(E);
E = NULL;
S->Count--;
} return res;
} void FreeStack(struct TStack * S) { while (S->Head != NULL) Pop(S);
} int main(int argc, char * argv[]) { int num;
struct TStack Stack;
InitStack(&Stack);
do { } printf("Type a number: ");
scanf("%d", &num);
if (num != 0) Push(&Stack, num);
} while (num != 0);
while (Stack.Count) printf("%d\n", Pop(&Stack));
FreeStack(&Stack);
return 0;

5.2.1. Írjon programot, amely számokat olvas be a billentyűzetről addig, amíg a beolvasott szám nem 0! Tárolja a számokat egy veremben, amit láncolt listával valósítson meg. A 0 gépelése után a program olvassa ki a számokat a veremből, és írja a képernyőre! Valósítsa meg a push és pop függvényeket, valamint a lista felszabadítását! Példa: Type a number: 1 Type a number: 5 Type a number: 7 Type a number: 0 7 5 1 5.3. Sor
5.3.1.
#include <stdio.h>
#include <stdlib.h> struct TElement { struct TElement * next;
int Value;
};
struct TQueue { struct TElement * Head;
struct TElement * Last;
int Count;
};
void InitQueue(struct TQueue * Q) { Q->Head = NULL;
Q->Last = NULL;
Q->Count = 0;
} void Push(struct TQueue * Q, int A) { struct TElement * Element = (struct TElement *)malloc(sizeof(struct TElement));
Element->Value = A;
Element->next = NULL;
if (Q->Head == NULL) { Q->Head = Element;
Q->Last = Element;
} else { Q->Last->next = Element;
Q->Last = Element;
} Q->Count++;
} int Pop(struct TQueue * Q) { int res = 0;
if (Q->Head != NULL) { struct TElement * E = Q->Head;
res = E->Value;
Q->Head = E->next;
free(E);
E = NULL;
Q->Count--;
} } return res;
void FreeQueue(struct TQueue * Q) { while (Q->Head != NULL) Pop(Q);
} int main(int argc, char * argv[]) { int num;
struct TQueue Queue;
InitQueue(&Queue);
do { printf("Type a number: ");
scanf("%d", &num);
if (num != 0) Push(&Queue, num);
} while (num != 0);
while (Queue.Count) printf("%d\n", Pop(&Queue));
FreeQueue(&Queue);
return 0;
} 
5.3.1. Írjon programot, amely számokat olvas be a billentyűzetről addig, amíg a beolvasott szám nem 0! Tárolja ezeket egy sorban, amit láncolt listával valósíts meg! A 0 gépelése után a program olvassa ki a számokat a sorból, és írja a képernyőre! Valósítsa meg a push és pop függvényeket, valamint a lista felszabadítását! Példa: Type a number: 10 Type a number: 43 Type a number: 2 Type a number: 5 Type a number: 0 2 5 5.4. Fordított lengyelforma
5.4.1. Egy matematikai kifejezést felírhatunk úgynevezett fordított lengyelformában is. Például a 3 + 4 kifejezés ebben az alakban így néz ki: 3 4 +. Fordított lengyelformában nincs szükség zárójelekre, és a műveletek precedenciájára sem kell ügyelni, mert azt már figyelembe vettük akkor, amikor meghatároztuk ezt a formát. A fordított lengyelformában lévő kifejezés egy verem segítségével értékelhető ki. Balról jobbra olvassuk a kifejezést, ha szám következik, akkor azt berakjuk a verembe, ha műveleti jel, akkor kiveszünk a veremből 2 elemet, elvégezzük rajtuk a műveletet, majd az eredményt visszahelyezzük a verembe. A (2 + 5) * 3 - 9 / (2 + 1) kifejezés fordított lengyelformában: 2 5 + 3 * 9 2 1 + / -. Az algoritmus az alábbi táblázatban lévő lépéseket hajtja végre a kifejezés kiértékeléséhez. Írjon programot, amely beolvas egy matematikai kifejezést fordított lengyel formában, majd az ismertetett módszer szerint megoldja azt! Lépés 0 1 2 Verem tartalma Kifejezés 2 2 5 2 5 + 3 * 9 2 1 + / 5 + 3 * 9 2 1 + / + 3 * 9 2 1 + / - 3 7 3 * 9 2 1 + / - 4 7 3 * 9 2 1 + / - 5 9 2 1 + / - 6 7 8 21 9 21 9 2 21 9 2 1 2 1 + / 1 + / + / - 9 21 9 3 / - 21 3 - Művelet Verembe(2) Verembe(5) a = Veremből b = Veremből Verembe (b + a) Verembe(3) a = Veremből b = Veremből Verembe(b*a) Verembe(9) Verembe(2) Verembe(1) a = Veremből b = Veremből Verembe(b+a) a = Veremből b = Veremből Verembe(b/a) a = Veremből b = Veremből Verembe(b-a) 5.5. Várólista
5.4.1.
#include <stdio.h>
#include <stdlib.h> typedef struct Verem { struct Verem * kovetkezo;
int adat;
} Verem;
void verembe(Verem ** verem, int adat) { Verem * uj = (Verem*)malloc(sizeof(Verem));
uj->adat = adat;
uj->kovetkezo = *verem;
*verem = uj;
} int verembol(Verem ** verem) { if (*verem == NULL) { return 0;
} int adat = (*verem)->adat;
Verem * kovetkezo = (*verem)->kovetkezo;
free(*verem);
*verem = kovetkezo;
return adat;
} int main() { const char * kifejezes[] = {"2", "5", "+", "3", "*", "9", "2", "1", "+", "/", "-"};
Verem * verem = NULL;
int index;
int meret = sizeof(kifejezes) / sizeof(const char*);
for (index = 0;
index < meret;
index++) { if (kifejezes[index][0] == '+') { int a = verembol(&verem);
int b = verembol(&verem);
verembe(&verem, a + b);
} else if (kifejezes[index][0] == '-') { int a = verembol(&verem);
int b = verembol(&verem);
verembe(&verem, b - a);
} else if (kifejezes[index][0] == '*') { int a = verembol(&verem);
int b = verembol(&verem);
verembe(&verem, a * b);
} else if (kifejezes[index][0] == '/') { int a = verembol(&verem);
int b = verembol(&verem);
verembe(&verem, b / a);
} else { verembe(&verem, atoi(kifejezes[index]));
} } int eredmeny = verembol(&verem);
printf("Az eredmeny: %d\n", eredmeny);
return EXIT_SUCCESS;
} 
5.5.1.-5.5.2.
#include <stdio.h>
#include <stdlib.h> typedef struct Sor { struct Sor * kovetkezo;
int adat;
} Sor;
void sorba(Sor ** sor, int adat) { Sor * uj = (Sor*) malloc(sizeof (Sor));
uj->adat = adat;
uj->kovetkezo = NULL;
if (*sor == NULL) { *sor = uj;
return;
} Sor * temp = *sor;
while (temp->kovetkezo != NULL) { temp = temp->kovetkezo;
} temp->kovetkezo = uj;
} int sorbol(Sor ** sor) { if (*sor == NULL) { return 0;
} int adat = (*sor)->adat;
Sor * kovetkezo = (*sor)->kovetkezo;
free(*sor);
*sor = kovetkezo;
return adat;
} void ujAzonosito(Sor ** sor) { int azonosito;
Sor * temp;
do { azonosito = rand() % 1000;
temp = *sor;
while (temp != NULL && temp->adat != azonosito) { temp = temp->kovetkezo;
} } while (temp != NULL);
printf("Uj azonosito: %d\n", azonosito);
sorba(sor, azonosito);
} void nKivesz(Sor ** sor, int n) { int index;
for (index = 0;
index < n && *sor != NULL;
index++) { printf("Az %d. azonosito: %d\n", index + 1, sorbol(sor));
} } int main() { Sor * sor = NULL;
int menu;
do { printf("Beszuras: 1\n");
printf("Kivesz: 2\n");
printf("Tobbet kivesz: 3\n");
printf("Kilepes: 4\n");
scanf("%d", &menu);
if (menu == 1) { ujAzonosito(&sor);
} if (menu == 2) { if (sor != NULL) printf("A kovetkezo azonosito: %d\n", sorbol(&sor));
else printf("Nincs tobb varakozo!\n");
} if (menu == 3) { int mennyi;
printf("Mennyi azonositot szedjunk ki? ");
scanf("%d", &mennyi);
nKivesz(&sor, mennyi);
} } while (menu != 4);
while (sor != NULL) { sorbol(&sor);
} } return EXIT_SUCCESS;

5.5.1. Egy fővárosi hivatalban az ügyfeleknek rendszerint várakozni kell. Minden újonnan érkező személy kap egy azonosítót és az embereket ezen azonosítók alapján szólítják. A kiszolgálás érkezési sorrendben történik. Írjon programot, amely segít a hivatal személyzetének a következő kiszolgálandó ügyfél azonosítójának megállapításában! Valósítsa meg a sor adatszerkezetet, ahol a beszúrás művelet létrehoz egy új azonosítót, kiírja a képernyőre és hozzáadja a sorhoz! A kivesz művelet kiveszi a sorból egy elemet és az azonosítót kiírja a képernyőre. Menü segítségével lehessen választani a beszúrás és a kivesz műveletek között! 
5.5.2. Előfordulhat, hogy egyszerre több embert tudnak kiszolgálni. Bővítse ki a programot az N_kivesz művelettel, amely N darab elemet vesz ki a sorból és kiírja a megfelelő azonosítókat! 5.6. Nyomtatók A fővárosi Könyvkötészeti- és Borászati Főiskola Szőlőtermesztési Tanszékén egy hálózati nyomtatót használ mindenki. Minden nyomtatási feladat bekerül egy nyomtatási sorba. A tanszéken az emberek nem egyenrangúak, a fontossági sorrendet az egyes személyeknek a szervezeti hierarchián belüli pozíciója szabja meg. A következő fokozatokat különböztetjük meg: tanszékvezető, professzorok, docensek, adjunktusok és tanársegédek. Például, ha a nyomtatási sor elején van 2 feladat docensektől, majd utána 3 tanársegédektől, akkor, ha egy adjunktus elindít egy nyomtatást, akkor az a docensek feladatai után, a tanársegédeké előtt jelenik meg a sorban. Az azonos hierarchia szinten lévő emberek nyomtatása érkezési sorrend alapján történik
5.6.1.-5.6.2.
#include <stdio.h>
#include <stdlib.h> typedef enum Rang { PROFESSZOR, DOCENS, ADJUNKTUS, TANARSEGED } Rang;
typedef struct Sor { struct Sor * kovetkezo;
int adat;
Rang rang;
} Sor;
void beszuras(Sor ** sor, int adat, Rang rang) { Sor * uj = (Sor*) malloc(sizeof (Sor));
uj->adat = adat;
uj->rang = rang;
uj->kovetkezo = NULL;
if (*sor == NULL) { *sor = uj;
return;
} Sor * temp = *sor;
Sor * prev = NULL;
while (temp != NULL && temp->rang <= rang) { prev = temp;
temp = temp->kovetkezo;
} uj->kovetkezo = temp;
if (prev == NULL) { *sor = uj;
} else { prev->kovetkezo = uj;
} } int kovetkezo(Sor ** sor) { if (*sor == NULL) { return 0;
} int adat = (*sor)->adat;
Sor * kovetkezo = (*sor)->kovetkezo;
free(*sor);
*sor = kovetkezo;
return adat;
} void megjelenit(Sor * sor) { while (sor != NULL) { printf("Azonosito: %d\trang: ", sor->adat);
switch (sor->rang) { case PROFESSZOR: printf("professzor\n");
break;
case DOCENS: printf("docens\n");
break;
case ADJUNKTUS: printf("adjunktus\n");
break;
case TANARSEGED: printf("tanarseged\n");
} } } sor = sor->kovetkezo;
int main() { Sor * sor = NULL;
int menu;
do { printf("Beszuras: 1\n");
printf("Kivesz: 2\n");
printf("Kilepes: 3\n");
scanf("%d", &menu);
if (menu == 1) { char kod[20];
int azonosito;
printf("Kerem a dokumentum azonositojat: ");
scanf("%d", &azonosito);
printf("Szemelyi kod: ");
scanf("%s", kod);
switch (kod[0]) { case 'P': beszuras(&sor, azonosito, PROFESSZOR);
break;
case 'D': beszuras(&sor, azonosito, DOCENS);
break;
case 'A': beszuras(&sor, azonosito, ADJUNKTUS);
break;
case 'T': beszuras(&sor, azonosito, TANARSEGED);
break;
default: printf("Hibas azonosito!\n");
} if (sor != NULL && rand() % 100 >= 55) { printf("Elkeszult egy nyomtatas, azonositoja: %d\n\n", kovetkezo(&sor));
} megjelenit(sor);
} if (menu == 2) { if (sor != NULL) { printf("A kovetkezo azonosito: %d\n", kovetkezo(&sor));
} else { printf("Nincs tobb dokumentum!\n");
} } } } while (menu != 3);
while (sor != NULL) { kovetkezo(&sor);
} return EXIT_SUCCESS;

5.6.1. Írjon programot, amely kezeli a nyomtatási sort a fenti precedenciáknak megfelelően! Valósítsd meg Beszúrás és Következő műveleteket! Beszúrásnál a dokumentum azonosítóját és a személy rangját kell megadni. Minden nyomtatás elindítása után 45% valószínűséggel rögtön elkészül egy nyomtatás. 
5.6.2. Bővítse ki a programot úgy, hogy minden nyomtatás előtt egy személyhez tartozó kódot kell megadni! Csak akkor lehet nyomtatni, ha a kód helyes. A kódból következik a személy rangja is. Minden nyomtatás elindítása után jelenítse meg a nyomtatási sort! 5.7. Pascal háromszög
5.7.1. Állítsuk elő a Pascal háromszöget a k-dik sorig, sor adatszerkezetet használva! Ötlet:ha az i-dik sora megvan a Pascal háromszögnek, akkor abból megkapjuk a i+1-edik sort a következő képen. Vegyük ki az utolsó elemet a sorból és tároljuk el, adjuk hozzá az új utolsó elemet, majd rakjuk be a sor elejére. Az előző műveleteket összesen (i-1)-szer hajtsuk végre, ezután rakjuk be a sor elejére az „1” elemet. Példa: (1 3 3 1);
utolsó elem ki -> (1 3 3);
összeadás, lista elejére fűzés -> (4 1 3 3);
utolsó elem ki -> (4 1 3);
összeadás, lista elejére fűzés -> (6 4 1 3);
utolsó elem ki -> (6 4 1);
összeadás, lista elejére fűzés -> (4 6 4 1);
’1’-es elem befűzése a lista elejére -> (1 4 6 4 1). 5.8. Periodikus adás
5.7.1.
#include <stdio.h>
#include <stdlib.h> struct row { int value;
struct row *next;
struct row *prev;
struct row *end;
struct row *first;
};
typedef struct row row;
void NewElement(int, row*);
int ElementOut(row*);
int main() { row row1, row2;
int max_level, current_level;
int i, k, x, y;
row1.first = NULL;
row1.end = NULL;
row1.prev = NULL;
row1.next = NULL;
row2.first = NULL;
row2.end = NULL;
row2.prev = NULL;
row2.next = NULL;
printf("How many level do you want to crate in the Pascal's triangle?: ");
scanf("%d", &max_level);
printf("Representing the triangle is nice only before the 13(th) row.\n");
for (i = 0;
i < max_level;
i++) { for (current_level = 0;
current_level <= i;
current_level++) { if (current_level == 0) { NewElement(1, &row1);
NewElement(1, &row2);
} else { if (current_level != i) { x = ElementOut(&row1);
y = row1.end->value;
NewElement(x + y, &row1);
NewElement(x + y, &row2);
} } } } else { x = ElementOut(&row1);
NewElement(x, &row1);
NewElement(x, &row2);
} } for (i = 0;
i <= max_level;
i++) { for (k = max_level;
k > i;
--k) printf(" ");
for (current_level = 0;
current_level < i;
current_level++) { printf("%3d ", ElementOut(&row2));
} printf("\n");
} return 0;
void NewElement(int new_value, row *s) { row* actual;
if (s->first == NULL) { actual = (row*) malloc(sizeof (row));
if (!actual) printf("The actual element wasn't created\n");
actual->next = NULL;
actual->prev = NULL;
actual->value = new_value;
s->first = actual;
s->end = actual;
} else { actual = (row*) malloc(sizeof (row));
if (!actual) printf("The actual element wasn't created\n");
actual->value = new_value;
actual->next = s->first;
actual->prev = NULL;
s->first->prev = actual;
s->first = actual;
} } int ElementOut(row *s) { row *temp;
int value = 0;
if (s->end != NULL) { value = s->end->value;
if (s->end->prev != NULL) { temp = s->end->prev;
} else { temp = NULL;
s->first = NULL;
} free(s->end);
s->end = temp;
} } return value;

5.8.1. Egy rádióadó periodikusan ismétli ugyanazt az adást, minden adás végén egy speciális jelet ad (#). Az adássorozat egy szekvenciális karakter tömbben van, döntsük el egy sor adatszerkezetet használva, hogy volt-e hiba valamelyik adásban! Hiba az adásban: nem mindig ugyanazt a jelsorozatot adta le az adó. 5.9. Zárójelezés
5.8.1.
#include <stdio.h>
#include <stdlib.h>
#include <string.h> struct row { char value[20];
struct row* next;
struct row* prev;
};
void UploadFIFO(char*, char*, struct row**, struct row**);
void InsertElement(char*, struct row**, struct row**);
void List_Check_Remove(char*, struct row**);
char* Check(char*, char*);
int main() { struct row* first = NULL, *end = NULL;
char signal[2000] = "abcdefg#abcdefg#abfdgcdefg#abdfcdefg#abcdfdefg#abcdefg#adfcvbcdefg#abcde fg#abcdefg#aega";
char pattern[20] = "abcdefg";
printf("Recived signal:\n%s\n", signal);
printf("\nChecking recived signal, the sequence pattern is: %s\n", pattern);
printf("Recived expressions between ## tags:\n");
UploadFIFO(pattern, signal, &first, &end);
List_Check_Remove(pattern, &first);
return 0;
} void UploadFIFO(char* pattern, char* signal, struct row** first, struct row** end) { int i = 0, k;
char temp[20];
while (signal[i] != '\0') { if (signal[i] != '#') { temp[0] = signal[i];
for (k = 1;
(signal[i + k] != '#');
++k) { if (signal[i + k] == '\0') break;
temp[k] = signal[i + k];
} temp[k] = '\0';
InsertElement(temp, first, end);
i = i + k;
} ++i;
} } void InsertElement(char* temp, struct row** first, struct row **end) { if (!(*first)) { (*first) = (struct row*)malloc(sizeof (struct row));
(*end) = (*first);
(*first)->prev = NULL;
(*first)->next = NULL;
strcpy((*first)->value, temp);
} else { (*end)->next = (struct row*)malloc(sizeof (struct row));
strcpy((*end)->next->value, temp);
(*end)->next->next = NULL;
(*end)->next->prev = (*end);
(*end) = (*end)->next;
} } void List_Check_Remove(char* pattern, struct row** first) { int i = 1;
struct row* actual = (*first);
while (*first) { printf("%4d. %s-> %s\n",i++, (*first)->value, Check(pattern, (*first)->value));
actual = (*first);
(*first) = (*first)->next;
free(actual);
} } char* Check(char* pattern, char* temp) { if (strcmp(pattern, temp)) return "Wrong";
else return "OK";
} 
5.9.1.
#include <stdio.h>
#include <stdlib.h>
#include <string.h> struct stack { int index;
struct stack* next;
struct stack* prev;
};
int CheckExpression(char*,struct stack**);
void InsertElement(struct stack**, int);
void RemoveElement(struct stack**, int);
int main() { int check;
struct stack* end = NULL;
char expression[100];
printf("Please enter an expression e.g: (a(b(c((d))#))\n");
scanf("%s", expression);
check = CheckExpression(expression, &end);
if (check > 0) printf("Wrong syntax!!! Too few close pharentheses!!!\n");
else if (check < 0) printf("Wrong syntax!!! Cannot be read correctly, too many close pharentheses!!!\n");
else printf("Everything's all right, syntax OK.\n");
return 0;
} int CheckExpression(char* expr, struct stack** end) { int i, i_parentheses = 0;
for (i = 0;
i < strlen(expr);
++i) { if (expr[i] == '(') { InsertElement(end, i_parentheses++);
} else if (expr[i] == ')') { if (i_parentheses == 0) return -1;
else RemoveElement(end, i_parentheses--);
} } return i_parentheses;
} void InsertElement(struct stack** end, int index) { if (!(*end)) { (*end) = (struct stack*)malloc(sizeof (struct stack));
(*end)->next = NULL;
(*end)->prev = NULL;
(*end)->index = index;
} else { (*end)->next = (struct stack*)malloc(sizeof (struct stack));
(*end)->next->prev = (*end);
(*end) = (*end)->next;
(*end)->next = NULL;
(*end)->index = index;
} printf("%d ->\n", (*end)->index);
} void RemoveElement(struct stack** end, int index) { if (*end) { printf("<- %d\n", (*end)->index);
if ((*end)->prev) { (*end) = (*end)->prev;
free((*end)->next);
(*end)->next = NULL;
} else free(*end);
} } 
5.9.1. Kérjünk be egy kifejezést, ami több nyitó és zárójelet tartalmaz! Verem segítségével írjuk ki az összetartozó zárójelpárok indexeit, és közben döntsük el, hogy helyes-e a zárójelezés! 6. Bináris fák feladatai 6.1. Bináris fa szülővel
