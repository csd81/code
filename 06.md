# Abstract Classes & Interfaces (C++)

**TL;DR ‚Äì Slide 3: Interface vs Abstract Class**

* Both define a **base ("parent") type** that can't be instantiated.
* They provide a **common interface** for derived classes.
* **Used for polymorphism** via virtual functions.

**Difference:**

* **Interface** = only pure virtual methods, no implementation at all.
* **Abstract class** = may include some implemented methods, but has at least one pure virtual method.

In short: both are blueprints, but abstract classes can have some code ‚Äî interfaces can't.



**TL;DR ‚Äì Slide 4: Implementing Interfaces & Abstract Classes in C++**

* In C++, abstract classes can contain **pure virtual functions**.
* **Multiple inheritance** is allowed: a class can inherit from more than one base class (or interface).



## Absztrakt oszt√°ly C++-ban

**TL;DR ‚Äì Abstract Class in C++ Example**

```cpp
class Flower {
public:
    virtual void color() = 0; // Pure virtual -> makes Flower abstract
};

class Lily : public Flower {
public:
    void color() {
        cout << "White Lily!!" << endl;
    }
};
```

üîπ `Flower` is an **abstract class** because it has a pure virtual method.
üîπ `Lily` **inherits** from `Flower` and **implements** the `color()` method, so it can be instantiated.
üîπ You can't create `Flower` objects, only derived ones like `Lily`.






**TL;DR ‚Äì Slide 6: Task Definition**

* Goal: build a **quiz system** with different question types (e.g., numeric, multiple choice).
* Need: handle all types **uniformly** (store in one list, summarize results).
* Solution: define a **common interface** (abstract base class) for all question types.





**TL;DR ‚Äì Slide 7: Unified Communication Interface**

* All question types must share a **common base class**.
* This base defines the **shared functions**, e.g.:

  * Get question text
  * Evaluate answer

‚û°Ô∏è Enables consistent handling of different question types.






**TL;DR ‚Äì Slide 8: Unified Communication Interface (cont.)**

* Each question type **inherits from the base `Kerdes` class** and **implements all required methods**.
* They can also have **custom data and methods** (e.g., step-by-step setup, extra parameters).
* But the question list (`KerdesSor`) interacts with them **only through the shared interface**.










Thanks! Here's a quick overview of what each file does in your quiz system project:

---

### üìÑ **Header Files (.h)**

* **`Kerdes.h`**:
  Abstract base class (interface) for all question types.

* **`SzamolosKerdes.h`**:
  Declares a class for numeric questions (derived from `Kerdes`).

* **`ValasztosKerdes.h`**:
  Declares a class for multiple-choice questions (also derived from `Kerdes`).

* **`KerdesSor.h`**:
  Declares the class for a container (`KerdesSor`) that holds and manages multiple questions.

---

### üìÑ **Source Files (.cpp)**

* **`SzamolosKerdes.cpp`**:
  Implements `SzamolosKerdes`, including how to evaluate numeric answers.

* **`ValasztosKerdes.cpp`**:
  Implements `ValasztosKerdes`, including answer choices and evaluation.

* **`KerdesSor.cpp`**:
  Implements the logic for storing questions and running the quiz (`kikerdez()` method).

* **`kerdesek.cpp`**:
  Likely contains the `main()` function that sets up the questions and runs the program.

---

Would you like a diagram or class relationship map for these?


```cpp
// C++ megval√≥s√≠t√°s: kerdes.h
#ifndef KERDES_H_
#define KERDES_H_
#include <string>
using namespace std;
class Kerdes{
public:
    virtual string lekerKerdesSzovege() const=0;  // Virtu√°lis: Nincs implement√°ci√≥!
    virtual double lekerValaszErtek(const string &valasz) const=0; // Virtu√°lis: Nincs implement√°ci√≥!
    virtual ~Kerdes(){} // Virtu√°lis destruktor
};
#endif /* KERDES_H_ */
```

**TL;DR ‚Äì `Kerdes.h` (Abstract Interface)**

```cpp
class Kerdes {
public:
    virtual string lekerKerdesSzovege() const = 0;       // pure virtual
    virtual double lekerValaszErtek(const string&) const = 0; // pure virtual
    virtual ~Kerdes() {}  // virtual destructor
};
```

‚úÖ Defines a **pure interface** (abstract class) for all questions
‚úÖ Contains only **pure virtual functions** (=0), no implementation
‚úÖ Has a **virtual destructor** for safe cleanup via base pointers

Used as a **base class** so all question types (`Szamolos`, `Valasztos`, etc.) implement the same interface.



**TL;DR ‚Äì No `kerdes.cpp` file**

* There's **no `kerdes.cpp`** because `Kerdes` is an **abstract class** with only **pure virtual functions**.
* üîπ No implementation = no need for a `.cpp` file.
* üîπ Only a `.h` header is required to declare the interface.

This is typical for **interface-like** classes in C++.


```cpp
#ifndef SZAMOLOSKERDES_H_
#define SZAMOLOSKERDES_H_

#include "Kerdes.h"
#include <string>
using namespace std;

// Define SzamolosKerdes as a derived class of Kerdes
class SzamolosKerdes : public Kerdes {
private:
    string kerdesSzoveg;     // Stores the question text
    double helyesValasz;     // Stores the correct numerical answer

public:
    // Constructor: initializes question text and correct answer
    SzamolosKerdes(const string& szoveg, const double& valasz);

    // Implements the abstract method to return the question text
    virtual string lekerKerdesSzovege() const override;

    // Implements the abstract method to evaluate the user's answer
    virtual double lekerValaszErtek(const string &valasz) const override;

    // Destructor
    virtual ~SzamolosKerdes();
};

#endif /* SZAMOLOSKERDES_H_ */

// -------------------- Implementation --------------------

#include "SzamolosKerdes.h"

// Constructor: set member variables from parameters
SzamolosKerdes::SzamolosKerdes(const string& szoveg, const double& valasz)
    : kerdesSzoveg(szoveg), helyesValasz(valasz)
{
}

// Destructor: no dynamic memory, so nothing special needed
SzamolosKerdes::~SzamolosKerdes()
{
}

// Return the question text
string SzamolosKerdes::lekerKerdesSzovege() const {
    return kerdesSzoveg;
}

// Evaluate the user's answer string
double SzamolosKerdes::lekerValaszErtek(const string &valasz) const {
    double valaszSzam(stod(valasz));  // Convert string to double (C++11: std::stod)

    // Full score if exact match
    if (valaszSzam == helyesValasz)
        return 1.0;

    // Partial score if within ¬±0.1 tolerance
    else if (-0.1 <= valaszSzam - helyesValasz && valaszSzam - helyesValasz <= 0.1)
        return 0.5;

    // No score otherwise
    else
        return 0.0;
}
```

Here's a detailed explanation of your full `SzamolosKerdes` class and its implementation in C++:

---

### üîí `#ifndef SZAMOLOSKERDES_H_` / `#define SZAMOLOSKERDES_H_` / `#endif`

This is an **include guard**. It prevents the header file from being included multiple times in a single translation unit (which would cause compiler errors due to redefinitions).

---

### üìÑ `#include "Kerdes.h"`

Includes the abstract base class definition that this class will inherit from.

### üìÑ `#include <string>` / `using namespace std;`

Needed for using the `std::string` type without prefixing it with `std::`.

---

### üß± **Class Definition: `SzamolosKerdes`**

```cpp
class SzamolosKerdes : public Kerdes
```

This declares a new class that **inherits** from the abstract base class `Kerdes`. It must implement all pure virtual functions from `Kerdes`.

#### üîê Private Members:

```cpp
string kerdesSzoveg;
double helyesValasz;
```

* `kerdesSzoveg`: stores the text of the question.
* `helyesValasz`: stores the correct numeric answer for comparison.

#### üîì Public Methods:

```cpp
SzamolosKerdes(const string& szoveg, const double& valasz);
```

A **constructor** that initializes the question and its answer.

```cpp
virtual string lekerKerdesSzovege() const override;
```

Implements a **pure virtual function** from `Kerdes`. Returns the question's text.

```cpp
virtual double lekerValaszErtek(const string &valasz) const override;
```

Also implements an abstract method: takes a string answer, converts it to a number, and returns a score (1.0, 0.5, or 0.0).

```cpp
virtual ~SzamolosKerdes();
```

A **virtual destructor**, ensuring that objects can be deleted through base class pointers safely.

---

### üõ†Ô∏è **Implementation Section**

#### üîß Constructor

```cpp
SzamolosKerdes::SzamolosKerdes(const string& szoveg, const double& valasz)
    : kerdesSzoveg(szoveg), helyesValasz(valasz)
```

This uses an **initializer list** to set the private members. It avoids redundant default construction and assignment.

#### ‚ùå Destructor

```cpp
SzamolosKerdes::~SzamolosKerdes() {}
```

No manual memory management is used here, so the destructor remains empty.

#### üì§ `lekerKerdesSzovege`

```cpp
string SzamolosKerdes::lekerKerdesSzovege() const {
    return kerdesSzoveg;
}
```

Just returns the question's text.

#### üìä `lekerValaszErtek`

```cpp
double SzamolosKerdes::lekerValaszErtek(const string &valasz) const {
    double valaszSzam(stod(valasz));
```

* Converts the string answer to a `double` using `std::stod` (C++11 feature).

Then evaluates:

```cpp
if (valaszSzam == helyesValasz)
    return 1.0;
```

* Exact match ‚Üí full score.

```cpp
else if (-0.1 <= valaszSzam - helyesValasz && valaszSzam - helyesValasz <= 0.1)
    return 0.5;
```

* If within a ¬±0.1 margin ‚Üí partial score.

```cpp
else
    return 0.0;
```

* Otherwise ‚Üí no score.

---

### ‚úÖ Summary

This class represents a **numeric question** in a quiz system. It implements an abstract interface to:

* Provide the question text
* Evaluate an answer with some tolerance
  It supports polymorphic use and integrates with other question types that also implement `Kerdes`.

Would you like the base class `Kerdes` or the multiple-choice version (`ValasztosKerdes`) explained next?


Great question!

### üîß Why use `{}` after a constructor with an initializer list?

```cpp
SzamolosKerdes::SzamolosKerdes(const string& szoveg, const double& valasz)
    : kerdesSzoveg(szoveg), helyesValasz(valasz)
{
}
```

The **curly braces `{}` define the constructor body**, even if it's empty.

#### üß† Why it's needed:

* In C++, **every function‚Äîincluding constructors‚Äîmust have a body**, even if it does nothing.
* The **initializer list** (`: kerdesSzoveg(szoveg), helyesValasz(valasz)`) only sets up member variables **before** the body runs.
* The `{}` is where you'd normally put logic or checks, but in this case, it's just empty because there's nothing else to do.

#### ‚ú® So:

You **must** include `{}` even if the constructor does nothing beyond initializing members. Without it, you'd get a **syntax error**.

Let me know if you want to see a case where the constructor body is *not* empty.


Sure! Here's an example where the **constructor body is *not* empty**, so the `{}` contains additional logic:

---

### üîß Example: Constructor With Extra Logic

```cpp
class User {
private:
    string name;
    int age;

public:
    User(const string& n, int a)
        : name(n), age(a)
    {
        // Additional logic in the constructor body
        if (age < 0) {
            cout << "Warning: Age cannot be negative. Setting age to 0." << endl;
            age = 0;
        }
    }
};
```

### üìù What's happening here:

* `: name(n), age(a)` initializes the member variables.
* The body `{ ... }` contains logic **after initialization**, e.g.:

  * Validating or correcting values
  * Printing debug info
  * Logging, setting up resources, etc.

---

So even if you're using an initializer list, you **still need `{}`**, and it's especially useful when you have setup logic that runs **after members are initialized**.

Want an example with dynamically allocated resources too?


Excellent question! Let's break it down:

---

### üî§ `const string& n` ‚Äî Why by reference?

* **`std::string` is a relatively large object** (internally holds a heap-allocated buffer).
* Passing by **const reference**:

  * avoids copying the whole string,
  * improves performance,
  * and `const` ensures the function doesn't modify it.

‚úÖ **Efficient and safe.** This is the standard way to pass strings if you only need to read them.

---

### üî¢ `int a` ‚Äî Why by value?

* **`int` is a small, primitive type** (usually 4 bytes).
* Passing an `int` by value is:

  * cheap,
  * simple,
  * and doesn't involve pointers or references.

‚úÖ There's **no benefit** to passing primitive types like `int`, `char`, `bool`, or `double` by reference *unless* you need to modify them or return a result.

---

### üìå Rule of thumb:

| Type                                                             | How to pass    | Why                                   |
| ---------------------------------------------------------------- | -------------- | ------------------------------------- |
| Big types (like `std::string`, `vector`, custom structs/classes) | `const T&`     | Avoids copying, safe read-only access |
| Small types (like `int`, `char`, `bool`, `double`)               | `T` (by value) | Simple, efficient, no indirection     |

---

Want to see a benchmark or example that demonstrates the performance difference?



```cpp
// -------------------- header --------------------
#ifndef VALASZTOSKERDES_H_
#define VALASZTOSKERDES_H_

#include "Kerdes.h"
#include <string>
using namespace std;

// Derived class representing a multiple-choice question
class ValasztosKerdes : public Kerdes {
private:
    string kerdesSzoveg;           // Stores the question text
    string* valaszok;              // Dynamically allocated array of answer options
    unsigned int valaszokSzama;    // Number of answer options
    string helyesValasz;           // Stores the correct answer

public:
    // Constructor initializes question text
    ValasztosKerdes(const string& szoveg);

    // Adds a new answer option to the list
    void hozzaadValasztas(const string& valasztas);

    // Sets the correct answer
    void beallitHelyesValasz(const string& valasz);

    // Returns the formatted question and options
    virtual string lekerKerdesSzovege() const override;

    // Evaluates the answer and returns score
    virtual double lekerValaszErtek(const string &valasz) const override;

    // Destructor releases dynamically allocated memory
    virtual ~ValasztosKerdes();
};

#endif /* VALASZTOSKERDES_H_ */

// -------------------- Implementation --------------------

#include "ValasztosKerdes.h"

// Constructor: initialize question and empty answer list
ValasztosKerdes::ValasztosKerdes(const string& szoveg)
    : kerdesSzoveg(szoveg), valaszok(0), valaszokSzama(0)
{
}

// Destructor: release memory used by answer array
ValasztosKerdes::~ValasztosKerdes() {
    if (valaszok)
        delete[] valaszok;
}

// Add an answer option to the array
void ValasztosKerdes::hozzaadValasztas(const string& valasztas) {
    string* tobbValasz = new string[valaszokSzama + 1];         // Allocate new array
    for (unsigned int i = 0; i < valaszokSzama; i++)            // Copy old options
        tobbValasz[i] = valaszok[i];
    tobbValasz[valaszokSzama++] = valasztas;                    // Add new option

    string* torlendo = valaszok;                                // Delete old array
    valaszok = tobbValasz;
    if (torlendo)
        delete[] torlendo;
}

// Set the correct answer
void ValasztosKerdes::beallitHelyesValasz(const string& valasz) {
    helyesValasz = valasz;
}

// Return formatted question and answer options
string ValasztosKerdes::lekerKerdesSzovege() const {
    string szoveg;
    szoveg += kerdesSzoveg + '\n';
    for (unsigned int i = 0; i < valaszokSzama; i++)
        szoveg += "  " + valaszok[i] + '\n';
    return szoveg;
}

// Check if given answer matches the correct one
double ValasztosKerdes::lekerValaszErtek(const string &valasz) const {
    if (valasz == helyesValasz)
        return 1.0;
    else
        return 0.0;
}
```

Here‚Äôs a **detailed explanation** of the `ValasztosKerdes` (Multiple-Choice Question) class and its implementation:

---

## üîê Include Guards

```cpp
#ifndef VALASZTOSKERDES_H_
#define VALASZTOSKERDES_H_
...
#endif
```

Prevents the header file from being included multiple times during compilation, avoiding redefinition errors.

---

## üìé Includes & Namespace

```cpp
#include "Kerdes.h"
#include <string>
using namespace std;
```

* `Kerdes.h`: Base abstract class being extended.
* `<string>`: Needed for `std::string`.
* `using namespace std;`: To avoid prefixing `std::`.

---

## üß± Class Definition: `ValasztosKerdes`

```cpp
class ValasztosKerdes : public Kerdes {
```

This class **inherits from the abstract base class `Kerdes`**, and implements its pure virtual methods.

### üîê Private Members

```cpp
string kerdesSzoveg;
string* valaszok;
unsigned int valaszokSzama;
string helyesValasz;
```

* `kerdesSzoveg`: stores the question's text.
* `valaszok`: dynamically allocated array of answer options.
* `valaszokSzama`: current number of answer options.
* `helyesValasz`: the correct answer.

### üîì Public Methods

#### Constructor

```cpp
ValasztosKerdes(const string& szoveg);
```

Initializes the question text and sets up an empty answer list.

#### Add Answer Option

```cpp
void hozzaadValasztas(const string& valasztas);
```

Dynamically resizes the answer array and adds a new choice.

#### Set Correct Answer

```cpp
void beallitHelyesValasz(const string& valasz);
```

Stores the correct answer for later comparison.

#### Return Question Text

```cpp
virtual string lekerKerdesSzovege() const override;
```

Returns the question with its answer options formatted as a string.

#### Evaluate Answer

```cpp
virtual double lekerValaszErtek(const string &valasz) const override;
```

Returns:

* `1.0` if the answer is correct,
* `0.0` otherwise.

#### Destructor

```cpp
virtual ~ValasztosKerdes();
```

Cleans up the dynamically allocated array of answer options.

---

## üß™ Implementation

### Constructor

```cpp
ValasztosKerdes::ValasztosKerdes(const string& szoveg)
    : kerdesSzoveg(szoveg), valaszok(0), valaszokSzama(0) {}
```

* Initializes the question text.
* Sets the answer array to `nullptr` and size to `0`.

### Destructor

```cpp
ValasztosKerdes::~ValasztosKerdes() {
    if (valaszok)
        delete[] valaszok;
}
```

Frees the dynamically allocated answer list to avoid memory leaks.

### Add Answer

```cpp
void ValasztosKerdes::hozzaadValasztas(const string& valasztas) {
    string* tobbValasz = new string[valaszokSzama + 1]; // allocate bigger array
    for (...)                                            // copy old answers
    ...
    delete[] torlendo;                                   // delete old array
}
```

* Allocates a new array with one more slot.
* Copies existing answers.
* Adds the new answer.
* Deletes the old array to prevent memory leaks.

### Set Correct Answer

```cpp
void ValasztosKerdes::beallitHelyesValasz(const string& valasz) {
    helyesValasz = valasz;
}
```

* Just assigns the correct answer string.

### Get Formatted Question

```cpp
string ValasztosKerdes::lekerKerdesSzovege() const {
    string szoveg;
    szoveg += kerdesSzoveg + '\n';
    for (...) szoveg += ...;
    return szoveg;
}
```

* Builds a string with the question and its options.

### Evaluate Answer

```cpp
double ValasztosKerdes::lekerValaszErtek(const string &valasz) const {
    return valasz == helyesValasz ? 1.0 : 0.0;
}
```

* Compares the user‚Äôs answer with the correct one and returns a score.

---

## ‚úÖ Summary

`ValasztosKerdes` is a multiple-choice question class that:

* Inherits a common interface (`Kerdes`)
* Manages its own list of answer options dynamically
* Evaluates answers and returns scores

Would you like me to explain how memory management here could be improved (e.g. using `std::vector`)?

```cpp
// -------------------- header 

#ifndef KERDESSOR_H_
#define KERDESSOR_H_

#include "Kerdes.h"
#include <iostream>
#include <string>
using namespace std;

// A container class that holds multiple questions via base class pointers
class KerdesSor {
private:
    Kerdes **kerdesek;             // Array of pointers to base class (polymorphic storage)
    unsigned int kerdesekSzama;    // Number of questions currently stored

public:
    // Constructor: initializes an empty container
    KerdesSor();

    // Adds a new question to the list
    void hozzaadKerdes(Kerdes* kerdes);

    // Iterates over the questions, displays them, and collects answers
    void kikerdez();

    // Destructor: releases the memory used by the array
    ~KerdesSor();
};

#endif /* KERDESSOR_H_ */

// -------------------- Implementation --------------------

#include "KerdesSor.h"

// Constructor: initialize members
KerdesSor::KerdesSor() : kerdesek(0), kerdesekSzama(0) {}

// Destructor: clean up the dynamic array
KerdesSor::~KerdesSor() {
    if (kerdesek)
        delete[] kerdesek;
}

// Adds a new Kerdes pointer to the array
void KerdesSor::hozzaadKerdes(Kerdes* kerdes) {
    Kerdes** tobbKerdes = new Kerdes*[kerdesekSzama + 1];           // New array with extra space
    for (unsigned int i = 0; i < kerdesekSzama; i++)                // Copy old pointers
        tobbKerdes[i] = kerdesek[i];

    tobbKerdes[kerdesekSzama++] = kerdes;                          // Add new question pointer

    Kerdes** torlendo = kerdesek;                                   // Save old array to delete
    kerdesek = tobbKerdes;
    if (torlendo)
        delete[] torlendo;                                          // Clean up old array
}

// Ask all questions and evaluate answers
void KerdesSor::kikerdez() {
    double osszesen = 0;                      // Accumulated score
    string valasz;                            // User input

    for (unsigned int i = 0; i < kerdesekSzama; i++) {
        cout << kerdesek[i]->lekerKerdesSzovege() << endl;    // Ask question via interface
        cin >> valasz;                                        // Get user answer
        cout << "Eredmeny: "
             << (osszesen += kerdesek[i]->lekerValaszErtek(valasz)) * 100 << "%\n";
    }

    cout << "Vegeredmeny: " << osszesen / kerdesekSzama * 100 << "%\n";
}
```



Here's a **line-by-line explanation** of your `KerdesSor` class and its implementation:

---

### ‚úÖ **Header File Section (`KerdesSor.h`)**

```cpp
#ifndef KERDESSOR_H_
#define KERDESSOR_H_
```

Start of an **include guard** ‚Äî prevents multiple inclusion of this header during compilation.

```cpp
#include "Kerdes.h"
#include <iostream>
#include <string>
using namespace std;
```

* Includes the `Kerdes` abstract base class (which `KerdesSor` will manage).
* Includes standard libraries for I/O and strings.
* `using namespace std;` allows using `string`, `cout`, `cin`, etc., without prefixing `std::`.

```cpp
class KerdesSor {
```

Defines a new class `KerdesSor` that represents a **container for questions**.

```cpp
private:
    Kerdes **kerdesek;             // Pointer to a dynamic array of Kerdes* (polymorphic questions)
    unsigned int kerdesekSzama;    // Tracks how many questions are stored
```

* `kerdesek` is a dynamic array of pointers to `Kerdes` objects (base class pointers).
* `kerdesekSzama` stores the current number of questions.

```cpp
public:
    KerdesSor();                          // Constructor
    void hozzaadKerdes(Kerdes* kerdes);  // Add a question
    void kikerdez();                      // Ask all questions
    ~KerdesSor();                         // Destructor
```

Public methods:

* Constructor initializes the structure.
* `hozzaadKerdes`: adds a question.
* `kikerdez`: asks the questions.
* Destructor releases memory.

```cpp
};
#endif /* KERDESSOR_H_ */
```

End of class and include guard.

---

### ‚öôÔ∏è **Implementation Section (`KerdesSor.cpp`)**

```cpp
#include "KerdesSor.h"
```

Include the header to implement its functions.

---

### üß± Constructor

```cpp
KerdesSor::KerdesSor() : kerdesek(0), kerdesekSzama(0) {}
```

* Initializes the pointer to `nullptr` (0) and the count to 0.
* At this point, there are no questions in the list.

---

### ‚ùå Destructor

```cpp
KerdesSor::~KerdesSor() {
    if (kerdesek)
        delete[] kerdesek;
}
```

* If the array was allocated, delete it.
* This **frees the dynamic memory** holding the array of pointers.
* **Does not delete the individual `Kerdes*` elements** ‚Äî assumes ownership is managed elsewhere.

---

### ‚ûï `hozzaadKerdes` ‚Äî Add a New Question

```cpp
void KerdesSor::hozzaadKerdes(Kerdes* kerdes) {
```

Adds a new question to the internal array.

```cpp
Kerdes** tobbKerdes = new Kerdes*[kerdesekSzama + 1];
```

* Allocates a new array of pointers with one more slot.

```cpp
for (unsigned int i = 0; i < kerdesekSzama; i++)
    tobbKerdes[i] = kerdesek[i];
```

* Copies all existing pointers from the old array to the new one.

```cpp
tobbKerdes[kerdesekSzama++] = kerdes;
```

* Appends the new question pointer.
* Increments the question count.

```cpp
Kerdes** torlendo = kerdesek;
kerdesek = tobbKerdes;
```

* Save the old array and replace it with the new one.

```cpp
if (torlendo)
    delete[] torlendo;
```

* Deletes the old array to free memory.
* ‚ö†Ô∏è This is a basic dynamic array resizing operation (like a manual `std::vector`).

---

### ‚ùì `kikerdez` ‚Äî Ask All Questions

```cpp
void KerdesSor::kikerdez() {
```

Starts a quiz session, asking all stored questions.

```cpp
double osszesen = 0;
string valasz;
```

* `osszesen` will store the cumulative score.
* `valasz` will hold user input.

```cpp
for (unsigned int i = 0; i < kerdesekSzama; i++) {
```

* Iterate over all stored questions.

```cpp
cout << kerdesek[i]->lekerKerdesSzovege() << endl;
cin >> valasz;
```

* Display question text.
* Read user answer.

```cpp
cout << "Eredmeny: "
     << (osszesen += kerdesek[i]->lekerValaszErtek(valasz)) * 100 << "%\n";
```

* Evaluate answer via the common interface (`Kerdes`).
* Add score to total and print result as percentage.

```cpp
cout << "Vegeredmeny: " << osszesen / kerdesekSzama * 100 << "%\n";
```

* After all questions, print the final percentage.

---

### ‚úÖ Summary

`KerdesSor` is a **question manager** that:

* Stores questions as polymorphic base class pointers.
* Can dynamically resize its internal storage.
* Uses runtime polymorphism to handle different question types via `Kerdes*`.

Would you like a refactored version that uses `std::vector<Kerdes*>` for cleaner memory management?





```cpp
#include "ValasztosKerdes.h"    // Include multiple-choice question class
#include "SzamolosKerdes.h"     // Include numeric question class
#include "KerdesSor.h"          // Include the container class for questions

int main() {
    KerdesSor kerdesSor;    // Create the question container

    // Create a multiple-choice question
    ValasztosKerdes valasztos("Melyik a kedvenc tant\xE1rgyad bet\x171jele?");
    valasztos.hozzaadValasztas("a: Testnevel\xE9s");
    valasztos.hozzaadValasztas("b: Angol");
    valasztos.hozzaadValasztas("c: Programoz\xE1s");
    valasztos.beallitHelyesValasz("c");

    // Add the multiple-choice question to the container
    kerdesSor.hozzaadKerdes(&valasztos);  // Compatible object through base pointer

    // Create a numeric question
    SzamolosKerdes szamolos("Mennyi 2+2? ", 4.0);

    // Add the numeric question to the container
    kerdesSor.hozzaadKerdes(&szamolos);

    // Run the quiz: display questions, accept answers, and show results
    kerdesSor.kikerdez();

    return 0;
}
```


 Here's a **line-by-line explanation** of the provided `main()` function in your quiz program:

---

### üîΩ **Includes**

```cpp
#include "ValasztosKerdes.h"    // Include multiple-choice question class
#include "SzamolosKerdes.h"     // Include numeric question class
#include "KerdesSor.h"          // Include the container class for questions
```

* These headers define the classes used: multiple-choice, numeric questions, and the question container.
* Required for class definitions and method access.

---

### üü¢ `int main()`

```cpp
KerdesSor kerdesSor;
```

* Create an instance of the question list (container).
* Can hold different types of questions (`Kerdes*` pointers).

---

### ‚ùì **Create and set up a multiple-choice question**

```cpp
ValasztosKerdes valasztos("Melyik a kedvenc tant√°rgyad bet≈±jele?");
```

* Instantiates a `ValasztosKerdes` object with the question text.

```cpp
valasztos.hozzaadValasztas("a: Testnevel√©s");
valasztos.hozzaadValasztas("b: Angol");
valasztos.hozzaadValasztas("c: Programoz√°s");
```

* Adds three answer options to the question.

```cpp
valasztos.beallitHelyesValasz("c");
```

* Sets `"c"` as the correct answer.

```cpp
kerdesSor.hozzaadKerdes(&valasztos);
```

* Adds the question to the container.
* The object is passed as a `Kerdes*` (base class pointer), enabling **polymorphism**.

---

### üî¢ **Create and add a numeric question**

```cpp
SzamolosKerdes szamolos("Mennyi 2+2? ", 4.0);
```

* Creates a numeric question asking "What is 2+2?" with the correct answer `4.0`.

```cpp
kerdesSor.hozzaadKerdes(&szamolos);
```

* Also added to the container as a `Kerdes*`.

---

### ‚ñ∂Ô∏è **Run the quiz**

```cpp
kerdesSor.kikerdez();
```

* Starts the quiz:

  * Iterates through each question,
  * Displays it,
  * Accepts user input,
  * Evaluates and displays results.

---

### üö™ **Exit program**

```cpp
return 0;
```

* Ends the program successfully.

---

### ‚úÖ Summary:

* This `main()` demonstrates **polymorphism in action**.
* Different question types are **handled uniformly** through a shared interface (`Kerdes*`).
* The quiz is flexible, extensible, and supports new question types with minimal changes.

Want help visualizing this with a UML class diagram?


This UML class diagram visually represents the structure and relationships between the classes in your quiz system project. Here's a breakdown of each component:

---

### üß© **1. `Kerdes` ‚Äì Interface (Abstract Base Class)**

| Visibility | Member                                                                                            |
| ---------- | ------------------------------------------------------------------------------------------------- |
| `+`        | `lekerKerdesSzovege() : string` ‚Äì pure virtual function to get the question text                  |
| `+`        | `lekerValaszErtek(valasz : const string&) : double` ‚Äì pure virtual function to evaluate an answer |
| `+`        | `~Kerdes()` ‚Äì virtual destructor                                                                  |

* Marked as **`<<interface>>`**, meaning this is an abstract class.
* Other classes implement this to ensure uniform behavior.

---

### üßÆ **2. `SzamolosKerdes` ‚Äì Numeric Question**

| Visibility | Member                                                   |
| ---------- | -------------------------------------------------------- |
| `-`        | `kerdesSzoveg : string`         ‚Äì question text          |
| `-`        | `helyesValasz : double`         ‚Äì correct numeric answer |
| `+`        | `SzamolosKerdes(...)`           ‚Äì constructor            |
| `+`        | `lekerKerdesSzovege()`          ‚Äì returns question text  |
| `+`        | `lekerValaszErtek(...)`         ‚Äì evaluates answer       |
| `+`        | `~SzamolosKerdes()`             ‚Äì destructor             |

* **Inherits** from `Kerdes` (indicated by the red dashed arrow).
* Implements numeric answer evaluation.

---

### ‚úÖ **3. `ValasztosKerdes` ‚Äì Multiple-Choice Question**

| Visibility | Member                                                         |
| ---------- | -------------------------------------------------------------- |
| `-`        | `kerdesSzoveg : string`         ‚Äì question text                |
| `-`        | `valaszok : string*`            ‚Äì array of options             |
| `-`        | `valaszokSzama : unsigned int`  ‚Äì count of options             |
| `-`        | `helyesValasz : string`         ‚Äì correct option               |
| `+`        | `ValasztosKerdes(...)`          ‚Äì constructor                  |
| `+`        | `hozzaadValasztas(...)`         ‚Äì add an option                |
| `+`        | `beallitHelyesValasz(...)`      ‚Äì set correct answer           |
| `+`        | `lekerKerdesSzovege()`          ‚Äì returns question and options |
| `+`        | `lekerValaszErtek(...)`         ‚Äì evaluates answer             |
| `+`        | `~ValasztosKerdes()`            ‚Äì destructor                   |

* **Inherits** from `Kerdes`.
* Handles a set of multiple-choice options.

---

### üì¶ **4. `KerdesSor` ‚Äì Question Container**

| Visibility | Member                                                                 |
| ---------- | ---------------------------------------------------------------------- |
| `-`        | `kerdesek : Kerdes**`           ‚Äì dynamic array of base-class pointers |
| `-`        | `kerdesekSzama : unsigned int`  ‚Äì number of stored questions           |
| `+`        | `KerdesSor()`                   ‚Äì constructor                          |
| `+`        | `hozzaadKerdes(...)`            ‚Äì add a question                       |
| `+`        | `kikerdez()`                    ‚Äì run the quiz                         |
| `+`        | `~KerdesSor()`                  ‚Äì destructor                           |

* Has a **composition relationship** with `Kerdes` objects (denoted by the diamond).
* Uses a **base class pointer (`Kerdes*`)** to store both `SzamolosKerdes` and `ValasztosKerdes` polymorphically.

---

### üìå Relationships Summary:

* `SzamolosKerdes` and `ValasztosKerdes` both **implement the `Kerdes` interface**.
* `KerdesSor` contains `Kerdes*` pointers, enabling it to **store and manage any kind of question**.

---

Would you like a modified version of the UML using `std::vector` for better memory safety, or an explanation of how polymorphism works in this setup?

Here is an **ASCII UML class diagram** representing the same structure as the image you uploaded:

```
             +-----------------------------+
             |        <<interface>>        |
             |           Kerdes            |
             +-----------------------------+----------------------+
             | + lekerKerdesSzovege() : string                    |
             | + lekerValaszErtek(valasz: const string&) : double |
             | + ~Kerdes()                                        |
             +----------------------------------------------------+
                     ‚ñ≤
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ                    ‚îÇ
+----------------------+    +--------------------------------+
|   SzamolosKerdes     |    |     ValasztosKerdes            |
+----------------------+    +--------------------------------+
| - kerdesSzoveg : string   | - kerdesSzoveg : string        |
| - helyesValasz : double   | - valaszok : string*           |
|                           | - valaszokSzama : unsigned int |
|                           | - helyesValasz : string        |
+----------------------+    +--------------------------------+
| + SzamolosKerdes(...)     | + ValasztosKerdes(...)         |
| + lekerKerdesSzovege()    | + hozzaadValasztas(...)        |
| + lekerValaszErtek(...)   | + beallitHelyesValasz(...)     |
| + ~SzamolosKerdes()       | + lekerKerdesSzovege()         |
|                           | + lekerValaszErtek(...)        |
|                           | + ~ValasztosKerdes()           |
+----------------------+    +--------------------------------+

               Uses (composition)
                     ‚ñº
           +----------------------------+
           |        KerdesSor           |
           +----------------------------+
           | - kerdesek : Kerdes**      |
           | - kerdesekSzama : unsigned |
           +----------------------------+
           | + KerdesSor()              |
           | + hozzaadKerdes(Kerdes*)   |
           | + kikerdez()               |
           | + ~KerdesSor()             |
           +----------------------------+
```

### Notes:

* `‚ñ≤` shows **inheritance** from `Kerdes`.
* `‚ñº` shows **composition**: `KerdesSor` *uses* `Kerdes*` pointers to store any question type.
* Public methods are marked with `+`, and private attributes with `-`.

Would you like me to generate this as a `.txt` file or turn it into a diagram using Graphviz syntax too?



----
**Summarizing file content**

The user wants a summary of the file they uploaded, which focuses on abstract classes and interfaces in C++ in the context of a quiz system. They‚Äôve asked for a 2000-word summary but made it clear they don‚Äôt want this done with canvas (which would normally output as a text document). The summary should be done directly in chat. I‚Äôll aim for a clear and detailed summary that stays close to their word count request.


# Summary 

---

## 1. Overview: Abstract Classes and Interfaces

In C++, **abstract classes** and **interfaces** both serve to define a common base type that cannot be instantiated directly, and that provides a uniform API for derived classes. They are fundamental tools for achieving **polymorphism**, allowing code to operate on objects of different types through a shared interface.

* **Interface** (in the classical sense)

  * Contains only **pure virtual** methods (i.e. declarations followed by `= 0`).
  * Cannot hold any implementation code‚Äîonly method signatures.
  * Serves purely as a contract: ‚Äúany class implementing this interface must provide these methods.‚Äù

* **Abstract class**

  * Must have at least one pure virtual method, making it uninstantiable.
  * May also include **implemented methods**, member variables, and helper functions.
  * Offers more flexibility than a pure interface: you can supply some common code once, while still forcing subclasses to implement specific methods.

In effect, interfaces are ‚Äúpure‚Äù abstract classes; in C++ you don‚Äôt have a dedicated `interface` keyword, but the pattern is the same.

---

## 2. Defining an Abstract Interface in C++

To declare an abstract type in C++, you define a class with one or more **pure virtual** functions:

```cpp
class Kerdes {
public:
    virtual std::string lekerKerdesSzovege() const = 0;
    virtual double      lekerValaszErtek(const std::string& valasz) const = 0;
    virtual ~Kerdes() {}
};
```

* Each method marked `= 0` is **pure virtual**, meaning no implementation is provided here and the class is abstract.
* A **virtual destructor** (`virtual ~Kerdes() {}`) ensures that when a derived object is deleted through a `Kerdes*` pointer, its destructor runs correctly, avoiding resource leaks.

No corresponding `.cpp` file is needed, since there‚Äôs no method body to implement‚Äîjust the header.

---

## 3. Simple Abstract-Class Example: `Flower` and `Lily`

```cpp
class Flower {
public:
    virtual void color() = 0;   // pure virtual -> makes Flower abstract
    virtual ~Flower() {}
};

class Lily : public Flower {
public:
    void color() override {
        std::cout << "White Lily!!\n";
    }
};
```

* `Flower` is abstract because `color()` is pure virtual.
* `Lily` **inherits** from `Flower` and **implements** `color()`, so it becomes concrete (instantiable).
* Attempting `Flower f;` would be a compile error; you can only do `Flower* f = new Lily();`.

This pattern guarantees that all ‚Äúflowers‚Äù have a `color()` method, but lets each subclass decide how to express it.

---

## 4. Designing a Quiz System: Motivation and Goals

You want to build a **quiz system** supporting multiple question types‚Äînumeric and multiple-choice‚Äîyet treat them uniformly. The system must be able to:

1. **Store** questions of various types in one container.
2. **Display** each question and collect an answer.
3. **Evaluate** the answer and accumulate a score.
4. **Summarize** the results at the end.

The challenge: how to handle different data and evaluation logic in a single list? The solution is to define a **common abstract base class** (`Kerdes`) and let each question type implement its own behavior. Then, a container can hold pointers to `Kerdes` and invoke the same methods on all.

---

## 5. The Base Class: `Kerdes`

```cpp
#ifndef KERDES_H_
#define KERDES_H_
#include <string>
class Kerdes {
public:
    virtual std::string lekerKerdesSzovege() const = 0;
    virtual double      lekerValaszErtek(const std::string& valasz) const = 0;
    virtual ~Kerdes() {}
};
#endif
```

* **Include guard** prevents double inclusion.
* Two pure-virtual methods: one to return the question text, another to evaluate a user‚Äôs answer (returning a `double` score).
* Derived classes implement these and can have their own data members.

---

## 6. Numeric Questions: `SzamolosKerdes`

### 6.1 Class Declaration

```cpp
#ifndef SZAMOLOSKERDES_H_
#define SZAMOLOSKERDES_H_
#include "Kerdes.h"
#include <string>

class SzamolosKerdes : public Kerdes {
private:
    std::string kerdesSzoveg;
    double      helyesValasz;

public:
    SzamolosKerdes(const std::string& szoveg, double valasz);
    std::string lekerKerdesSzovege() const override;
    double      lekerValaszErtek(const std::string& valasz) const override;
    ~SzamolosKerdes() override;
};
#endif
```

* Stores the question text and a numeric ‚Äúcorrect answer.‚Äù
* Implements both interface methods.

### 6.2 Implementation

```cpp
#include "SzamolosKerdes.h"
#include <cstdlib>  // for std::stod

SzamolosKerdes::SzamolosKerdes(const std::string& szoveg, double valasz)
    : kerdesSzoveg(szoveg), helyesValasz(valasz) {}

SzamolosKerdes::~SzamolosKerdes() {}

std::string SzamolosKerdes::lekerKerdesSzovege() const {
    return kerdesSzoveg;
}

double SzamolosKerdes::lekerValaszErtek(const std::string& valasz) const {
    double v = std::stod(valasz);
    if (v == helyesValasz)                    return 1.0;   // exact
    else if (std::abs(v - helyesValasz) <= 0.1) return 0.5; // near
    else                                      return 0.0;
}
```

* Uses an **initializer list** to set members.
* Converts the user‚Äôs string answer to `double` with `std::stod`.
* Awards full, partial, or no credit based on tolerance.

---

## 7. Multiple-Choice Questions: `ValasztosKerdes`

### 7.1 Class Declaration

```cpp
#ifndef VALASZTOSKERDES_H_
#define VALASZTOSKERDES_H_
#include "Kerdes.h"
#include <string>

class ValasztosKerdes : public Kerdes {
private:
    std::string kerdesSzoveg;
    std::string* valaszok;
    unsigned int valaszokSzama;
    std::string helyesValasz;

public:
    ValasztosKerdes(const std::string& szoveg);
    void hozzaadValasztas(const std::string& valasztas);
    void beallitHelyesValasz(const std::string& valasz);
    std::string lekerKerdesSzovege() const override;
    double      lekerValaszErtek(const std::string& valasz) const override;
    ~ValasztosKerdes() override;
};
#endif
```

* Keeps a **dynamic array** (`std::string*`) of options and a count.
* Allows adding options and setting which one is correct.

### 7.2 Implementation

```cpp
#include "ValasztosKerdes.h"

ValasztosKerdes::ValasztosKerdes(const std::string& szoveg)
    : kerdesSzoveg(szoveg), valaszok(nullptr), valaszokSzama(0) {}

ValasztosKerdes::~ValasztosKerdes() {
    delete[] valaszok;
}

void ValasztosKerdes::hozzaadValasztas(const std::string& v) {
    std::string* uj = new std::string[valaszokSzama + 1];
    for (unsigned i = 0; i < valaszokSzama; ++i)
        uj[i] = valaszok[i];
    uj[valaszokSzama] = v;
    delete[] valaszok;
    valaszok = uj;
    ++valaszokSzama;
}

void ValasztosKerdes::beallitHelyesValasz(const std::string& v) {
    helyesValasz = v;
}

std::string ValasztosKerdes::lekerKerdesSzovege() const {
    std::string out = kerdesSzoveg + "\n";
    for (unsigned i = 0; i < valaszokSzama; ++i)
        out += "  " + valaszok[i] + "\n";
    return out;
}

double ValasztosKerdes::lekerValaszErtek(const std::string& v) const {
    return (v == helyesValasz) ? 1.0 : 0.0;
}
```

* Each time you add an option, you allocate a new array, copy existing ones, append, then delete the old array.
* Returns the question text plus a numbered/bulleted list of options.
* Full credit only if the answer matches exactly.

> **Note:** Modern C++ would use `std::vector<std::string>` to avoid manual memory management.

---

## 8. The Question Container: `KerdesSor`

### 8.1 Header

```cpp
#ifndef KERDESSOR_H_
#define KERDESSOR_H_
#include "Kerdes.h"
#include <iostream>

class KerdesSor {
private:
    Kerdes**     kerdesek;
    unsigned int kerdesekSzama;

public:
    KerdesSor();
    void hozzaadKerdes(Kerdes* k);
    void kikerdez();
    ~KerdesSor();
};
#endif
```

* Stores a dynamic array of `Kerdes*` pointers.
* Tracks how many questions are in the list.

### 8.2 Implementation

```cpp
#include "KerdesSor.h"

KerdesSor::KerdesSor()
    : kerdesek(nullptr), kerdesekSzama(0) {}

KerdesSor::~KerdesSor() {
    delete[] kerdesek;
}

void KerdesSor::hozzaadKerdes(Kerdes* k) {
    Kerdes** uj = new Kerdes*[kerdesekSzama + 1];
    for (unsigned i = 0; i < kerdesekSzama; ++i)
        uj[i] = kerdesek[i];
    uj[kerdesekSzama] = k;
    delete[] kerdesek;
    kerdesek = uj;
    ++kerdesekSzama;
}

void KerdesSor::kikerdez() {
    double osszesen = 0.0;
    std::string valasz;
    for (unsigned i = 0; i < kerdesekSzama; ++i) {
        std::cout << kerdesek[i]->lekerKerdesSzovege();
        std::cin  >> valasz;
        osszesen += kerdesek[i]->lekerValaszErtek(valasz);
        std::cout << "Eredmeny: " << (osszesen * 100.0) << "%\n";
    }
    std::cout << "Vegeredmeny: " << (osszesen / kerdesekSzama * 100.0) << "%\n";
}
```

* **Adding** a question resizes the array by one‚Äîsimilarly to the multiple-choice logic.
* **Running** the quiz loops through each `Kerdes*`, displays it, gets input, evaluates via polymorphism, and accumulates the score.

> Again, `std::vector<Kerdes*>` would simplify this code and manage memory automatically.

---

## 9. Putting It All Together: `main()`

```cpp
#include "ValasztosKerdes.h"
#include "SzamolosKerdes.h"
#include "KerdesSor.h"

int main() {
    KerdesSor ks;

    ValasztosKerdes q1("Melyik a kedvenc tant√°rgyad bet≈±jele?");
    q1.hozzaadValasztas("a: Testnevel√©s");
    q1.hozzaadValasztas("b: Angol");
    q1.hozzaadValasztas("c: Programoz√°s");
    q1.beallitHelyesValasz("c");
    ks.hozzaadKerdes(&q1);

    SzamolosKerdes q2("Mennyi 2+2?", 4.0);
    ks.hozzaadKerdes(&q2);

    ks.kikerdez();
    return 0;
}
```

1. You create a `KerdesSor` instance.
2. You instantiate a `ValasztosKerdes`, add options, set the correct one, and add it to the container.
3. You instantiate a `SzamolosKerdes` and add it as well.
4. Finally, calling `ks.kikerdez()` runs the quiz, demonstrates runtime polymorphism, and prints results.

---

## 10. UML Class Diagram

Here‚Äôs an ASCII-style UML representation of the relationships:

```
     <<interface>>          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         Kerdes            ‚îÇ  KerdesSor     ‚îÇ
     + leker...()          ‚îÇ  - kerdesek**  ‚îÇ
     + eval...()           ‚îÇ  - count       ‚îÇ
     + ~Kerdes()           ‚îÇ  + add()       ‚îÇ
         ‚ñ≤                 ‚îÇ  + kikerez()   ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 ‚îÇ               ‚îÇ
 ‚îÇ               ‚îÇ
 ‚îÇ               ‚îÇ
SzamolosKerdes   ValasztosKerdes
- question text  - question text
- correct answer - options ptr
+ impl leker()    + addOption()
+ impl eval()     + setCorrect()
```

* **Inheritance**: both `SzamolosKerdes` and `ValasztosKerdes` inherit from `Kerdes`.
* **Composition**: `KerdesSor` holds multiple `Kerdes*`.

---

## 11. Best Practices & Possible Improvements

1. **Use Standard Containers**

   * Replace raw arrays and manual `new[]`/`delete[]` with `std::vector<std::string>` for options and `std::vector<Kerdes*>` for the question list.
   * This avoids manual memory management and simplifies resizing.

2. **Smart Pointers**

   * Consider using `std::unique_ptr<Kerdes>` in the container to manage object lifetimes automatically.
   * Prevents dangling pointers if the container or questions go out of scope.

3. **Pass by Reference vs. Value**

   * Large or complex types (e.g. `std::string`) should be passed as `const T&`.
   * Small built-ins (`int`, `double`, `bool`) can be passed by value for simplicity.

4. **Exception Safety**

   * Ensure that if an exception is thrown during `hozzaadValasztas` or resizing, you don‚Äôt leak memory.
   * Using standard containers handles this for you.

5. **Separation of Concerns**

   * The `kikerdez()` method mixes I/O and scoring logic. You might separate user-interaction from scoring, making it easier to adapt (e.g. for GUI or web).

6. **Extensibility**

   * With a clean interface (`Kerdes`), adding new question types (true/false, fill-in-the-blank) requires only a new subclass implementing the two methods.

---

## 12. Core Takeaways

* **Abstract classes** and **interfaces** in C++ are key to achieving polymorphism: you code against behavior (methods), not against concrete types.
* **Pure virtual functions** enforce that subclasses supply necessary implementations, while a **virtual destructor** ensures proper cleanup.
* Storing derived-class objects through base-class pointers allows you to treat heterogeneous objects uniformly.
* Manual memory management for arrays works, but is error-prone‚Äîmodern C++ favors `std::vector` and smart pointers for safety and clarity.
* The quiz system example cleanly demonstrates how to:

  1. Define a base interface (`Kerdes`).
  2. Implement two distinct behaviors (`SzamolosKerdes`, `ValasztosKerdes`).
  3. Store and operate on them polymorphically in a container (`KerdesSor`).

---

By following these patterns, you gain a flexible architecture where new question types plug in seamlessly, and core logic (asking, evaluating, scoring) remains unchanged. This design exemplifies the power of C++‚Äôs abstract classes and runtime polymorphism.
