
4.1.1.
#include <stdio.h> const int listSize=7;
void printList(int head, int* listIndex, double* listData) { int act=head;
printf("[");
while (act != -1) { printf("%4.2lf", listData[act]);
act = listIndex[act];
if (act != -1) printf(",");
} printf("]");
} void deleteLast(int* head, int* listIndex, double* listData) { int act= *head, prev, prev2;
if (act== -1) return;
if (listIndex[act]== -1) { *head = -1;
return;
} prev2 = act;
act = listIndex[act];
prev = act;
act = listIndex[act];
while (act != -1) { prev2 = prev;
prev = act;
act = listIndex[act];
} listIndex[prev2] = -1;
} int main() { double listData[listSize]={34, 12.55, 893.2, 2, 11.6, 47.5, 45.3};
int listIndex[listSize]={-1, 0, 4, 1, 6, 3, 5};
int head=2;
printf("list: ");
printList(head, listIndex, listData);
printf("\n");
deleteLast(&head, listIndex, listData);
printList(head, listIndex, listData);
printf("\n");
deleteLast(&head, listIndex, listData);
printList(head, listIndex, listData);
printf("\n");
deleteLast(&head, listIndex, listData);
printList(head, listIndex, listData);
printf("\n");
deleteLast(&head, listIndex, listData);
printList(head, listIndex, listData);
printf("\n");
deleteLast(&head, listIndex, listData);
printList(head, listIndex, listData);
printf("\n");
deleteLast(&head, listIndex, listData);
printList(head, listIndex, listData);
printf("\n");
deleteLast(&head, listIndex, listData);
printList(head, listIndex, listData);
printf("\n");
deleteLast(&head, listIndex, listData);
printList(head, listIndex, listData);
return 0;
} 
4.1.1. Készítsen programot, amelyben egy (nem ciklikus) láncolt listát két tömbbel reprezentál! Az egyik tömb az elemek értékeit, a másik a következő elem indexét tartalmazza. Egész változó tartalmazza a lista első elemének az indexét! Inicializálja a tömböket a következő értékekkel: értékek: {34, 12.55, 893.2, 2, 11.6, 47.5, 45.3}, indexek: {-1, 0, 4, 1, 6, 3, 5}! A kettes indexű elem a lista első tagja. Írjon függvényt a lista elemeinek listázáshoz! Írjon függvényt az utolsó elem törléséhez, törölje egyenként az elemeket és minden törlés után listázza az elemeket! Hogyan kell módosítani a programot, ha törlés után elem beszúrása következik? 
4.1.2.
#include <stdio.h>
#include <stdlib.h> const int listSize = 7;
void printList(int head, int* listIndex, double* listData) { int act = head;
printf("[");
while (act != -1) { printf("%4.2lf", listData[act]);
act = listIndex[act];
if (act != -1) printf(", ");
} printf("]\n");
} void deleteLast(int* head, int* listIndex, double* listData) { int act = *head, prev, prev2;
if (act == -1) return;
if (listIndex[act] == -1) { *head = -1;
return;
} prev2 = act;
prev = act = listIndex[act];
act = listIndex[act];
while (act != -1) { prev2 = prev;
prev = act;
act = listIndex[act];
} listIndex[prev2] = -1;
} void deleteFirst(int* head, int* listIndex) { int toErase = *head;
*head = listIndex[*head];
listIndex[toErase] = -1;
} int checkCircle(int* circle, int size) { int idxI;
for(idxI = 1;
idxI < size;
++idxI) { if(circle[0] == circle[idxI]) return 1;
} } return 0;
int checkConsistent(int * listIndex, int size, int head) { int idxI, validSize = 0;
int act = head;
int* circle = (int*)malloc(sizeof (int)*size);
for(idxI = 0;
idxI < size;
++idxI) { if(listIndex[idxI] != -1) { validSize++;
} } if(head == -1 || validSize == 0) { printf("List is inconsistent.\n");
return 1;
} for (idxI = 0;
idxI < validSize;
++idxI) { if(listIndex[act] == -1) { printf("List is inconsistent.\n");
return 1;
} act = listIndex[act];
circle[idxI] = act;
} for(idxI = 0;
idxI < validSize;
++idxI) if(checkCircle(&circle[idxI], validSize - idxI)) { printf("List is inconsistent.\n");
return 1;
} printf("List is consistent.\n");
return 0;
} int main() { double listData[7] = {34, 12.55, 893.2, 2, 11.6, 47.5, 45.3};
int listIndex[7] = {-1, 0, 4, 1, 6, 3, 5};
int head = 2;
deleteFirst(&head, listIndex);
if(!checkConsistent(listIndex, sizeof(listIndex)/sizeof(listIndex[0]), head)) { printf("list: ");
printList(head, listIndex, listData);
} return 0;
} 
4.1.2. Írjon függvényt, amely a lista első elemét törli! Írjon függvényt, amely ellenőrzi, hogy az tömb konzisztens-e, vagyis a benne lévő indexek a megengedett tartományban vannak-e, a start elemtől indulva nem jelentkezik kör! 
4.1.3.
#include <stdio.h>
#include <stdlib.h> const int listSize = 7;
void printList(int head, int* listIndex, double* listData, int size) { int act = head, idxI;
printf("[");
for(idxI = 0;
idxI < size;
++idxI){ printf("%4.2lf", listData[act]);
act = listIndex[act];
if (idxI != size -1) printf(", ");
} printf("]\n");
} int main() { double listData[7] = {34, 12.55, 893.2, 2, 11.6, 47.5, 45.3};
int listIndex[7] = {1, 2, 3, 4, 5, 6, 0};
int head;
printf("From where should the cyclic list start? (0-6) ");
scanf("%d", &head);
printf("list: ");
printList(head, listIndex, listData, sizeof(listData)/sizeof(listData[0]));
return 0;
} 
4.1.3. Valósítsa meg hasonló módon a ciklikus listát! Listázáskor lehessen megadni, hogy honnan kezdődjék a kiírás! 4.2. Lista egy tömbbel
4.2.1.
#include <stdio.h>
#include <stdlib.h>
#include <string.h> const int listSize=5;
typedef struct { char name[100];
int age;
int next;
} Element;
void printList(int head, Element* myList) { int act=head;
printf("[");
while (act != -1) { printf("(%s, %d)", myList[act].name, myList[act].age);
act = myList[act].next;
if (act != -1) printf(", ");
} printf("]");
} int freeSpace(int listSize, Element* myList) { int trial;
srand(333);
do { trial = rand()%(listSize-1)+1;
} while (myList[trial].next != -2);
return trial;
} void addFirst(int* head, int listSize, Element* myList) { int oldHead= *head, newHead;
char name[100];
int age;
printf("name: ");
scanf("%s", name);
printf("age: ");
scanf("%d", &age);
newHead = freeSpace(listSize, myList);
} myList[newHead].next = oldHead;
*head = newHead;
strcpy(myList[newHead].name, name);
myList[newHead].age = age;
int main() { Element myList[listSize]={{ "", 0, -2}, {"", 0, -2}, {"", 0, -2}, {"", 0, -2}, {"", 0, -2}};
int head=-1;
} printf("list: ");
printList(head, myList);
printf("\n");
addFirst(&head, listSize, myList);
printList(head, myList);
printf("\n");
addFirst(&head, listSize, myList);
printList(head, myList);
printf("\n");
addFirst(&head, listSize, myList);
printList(head, myList);
printf("\n");
return 0;

4.2.1. Készítsen programot, amelyben egy (nem ciklikus) láncolt listát statikus tömbbel reprezentál, úgy, hogy a tömb rekordokat tartalmaz, amelyekben név, életkor és a következő elem indexe adattag szerepel! írjon függvényt, amely a lista elejére fűz be új elemet! Az új rekord helyét a tömbben véletlen szám generátorral határozza meg a következő módon: létrehoz egy véletlen indexet;
ha az azon indexhez tartozó rekord következő elem adattag értéke -2, akkor a kérdéses rekord nem tartalmaz hasznos információt vagyis nem használt rekordról van szó;
egyébként nézzünk meg egy másik véletlen indexű elemet! (A módszer hátránya, hogy ha nincs több szabad hely, akkor a foglalás végtelen ciklusba kerül, a korrekt megoldás az lenne, ha külön tartanánk nyílván a szabad helyeket.) 
4.2.2.–4.2.3.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h> typedef struct { char name[100];
int age;
int next;
} Element;
void printList(int head, Element* myList) { int act=head;
printf("[");
while (act != -1) { printf("(%s, %d)", myList[act].name, myList[act].age);
act = myList[act].next;
if (act != -1) printf(", ");
} printf("]");
} int checkFreeSpace(int * indexArray, int listSize){ int idxI;
} for(idxI = 0;
idxI < listSize;
++idxI){ if(indexArray[idxI] == -2) return 0;
} return 1;
void reAllocation(Element* myList, int* listSize) { int idxI;
Element* myList2;
printf("Array is full, reallocating.\n");
myList2 = (Element*)malloc(sizeof(Element)*(2*(*listSize)));
for(idxI = 0;
idxI < *listSize;
++idxI) { myList2[idxI] = myList[idxI];
} for(idxI = *listSize;
idxI < (2 * (*listSize));
++idxI) { myList2[idxI].next = -2;
} myList = myList2;
*listSize = 2 * (*listSize);
} int freeSpace(int listSize, Element* myList) { int trial, idxI;
int * indexArray;
indexArray = (int*)malloc(sizeof(int) * listSize);
for(idxI = 0;
idxI < listSize;
++idxI) { indexArray[idxI] = -2;
} srand(time(NULL));
do { if(checkFreeSpace(indexArray, listSize)) { reAllocation(myList, &listSize);
indexArray = (int*)malloc(sizeof(int) * listSize);
for(idxI = 0;
idxI < listSize;
++idxI) { indexArray[idxI] = -2;
} } trial = rand()%(listSize);
indexArray[trial] = myList[trial].next;
} while (myList[trial].next != -2);
free(indexArray);
return trial;
} void addLast(int* sentinel, int listSize, Element* myList) { int newSentinel;
char name[100];
int age;
printf("name: ");
scanf("%s", name);
printf("age: ");
scanf("%d", &age);
newSentinel = freeSpace(listSize, myList);
myList[*sentinel].next = newSentinel;
myList[newSentinel].next = -1;
strcpy(myList[newSentinel].name, name);
myList[newSentinel].age = age;
*sentinel = newSentinel;
} void addFirst(int* sentinel, int listSize, Element* myList) { int newSentinel;
char name[100];
int age;
} printf("name: ");
scanf("%s", name);
printf("age: ");
scanf("%d", &age);
newSentinel = freeSpace(listSize, myList);
myList[newSentinel].next = -1;
strcpy(myList[newSentinel].name, name);
myList[newSentinel].age = age;
*sentinel = newSentinel;
int main() { int idxI, listSize = 3;
int head=-1;
int sentinel;
} Element* myList = (Element*)malloc(sizeof(Element)*listSize);
for(idxI = 0;
idxI < listSize;
++idxI) { myList[idxI].next = -2;
} printf("list: ");
printList(head, myList);
printf("\n");
addFirst(&head, listSize, myList);
printList(head, myList);
printf("\n");
sentinel = head;
for(idxI = 0;
idxI < 11;
++idxI) { addLast(&sentinel, listSize, myList);
printList(head, myList);
printf("\n");
} free(myList);
return 0;

4.2.2. Írjon függvényt a lista kiíratásához! Egyenként adjon elemeket a listához és írja ki az eredmény listát! 
4.2.3. Módosítsa úgy az előző programot, hogy jelezze, ha nem sikeres az elem hozzáadása, mert betelt a tároló tömb! Dinamikus tömbben tárolja a listát, ha tömb betelne, akkor foglaljon le egy nagyobb tömböt! Valósítsa meg a lista végére beszúró függvényt! 4.3. Lista szerkezet
4.3.1. A karakteres képernyőn jelenítsen meg egy 3 hosszú, egyszeresen láncolt listát! A listát közvetlen értékadásokkal hozza létre, jelenítse meg a listát reprezentáló fej változót is! 4.1. ábra: Lehetséges képernyőkép
4.3.1.
#include <stdio.h>
#include <malloc.h> typedef struct le { int data;
struct le* next;
} listElem;
void displayElement(listElem* act) { printf("[%d, %#p]->", act->data, act->next);
} int main() { listElem *act=NULL, *head=NULL, elem1={12, NULL}, elem2={45, NULL}, elem3={7, NULL};
head = &elem1;
elem1.next = &elem2;
elem2.next = &elem3;
elem3.next = NULL;
act = head;
printf("elements:");
displayElement(act);
act = act->next;
displayElement(act);
act = act->next;
displayElement(act);
printf("NULL");
printf("\n%9s%-#18p%-#18p%-#15p%-18s", "address:", head, head->next, head->next->next, "");
printf("\n\n%9s%-#18p", "head:", head);
printf("\n%9s%-#18p\n\n", "address:", &head);
return 0;
} 
4.3.2. Hasonló módon jelenítse meg az oda-vissza láncolt listát! 4.4. Láncolt lista dinamikus rekordokkal
4.3.2.
#include <stdio.h>
#include <malloc.h> typedef struct le { int data;
struct le* next;
struct le* prev;
} listElem;
void displayElement(listElem* act) { printf("[%d, %#p]->", act->data, act->next);
} void displayElement2(listElem* act) { printf("[%d, %#p]->", act->data, act->prev);
} int main() { listElem *act=NULL, *head=NULL, *tail=NULL, elem1={12, NULL, NULL}, elem2={45, NULL, NULL}, elem3={7, NULL, NULL};
head = &elem1;
elem1.next = &elem2;
elem1.prev = NULL;
elem2.next = &elem3;
elem2.prev = &elem1;
elem3.next = NULL;
elem3.prev = &elem2;
act = head;
printf("elements:");
displayElement(act);
act = act->next;
displayElement(act);
act = act->next;
tail = act;
displayElement(act);
printf("NULL");
printf("\n%9s%-#18p%-#18p%-#15p%-18s", "address:", head, head->next, head->next->next, "");
printf("\n\n%9s%-#18p", "head:", head);
printf("\n%9s%-#18p\n\n", "address:", &head);
printf("Now let's see backward: \n");
displayElement2(tail);
} displayElement2(tail->prev);
displayElement2(tail->prev->prev);
printf("NULL\n");
return 0;

4.4.1.
#include <stdio.h>
#include <malloc.h>
#include <string.h> typedef struct le { char name[100];
int price;
float power;
struct le* next;
} listElem;
listElem* createListElem() { listElem* result=(listElem*)malloc(sizeof(listElem));
printf("name: ");
scanf("%s", result->name);
printf("price: ");
scanf("%d", &result->price);
printf("power: ");
scanf("%f", &result->power);
result->next = NULL;
return result;
} void displayListElem(listElem* myList) { printf("(name: %s, ", myList->name);
printf("price: %d, ", myList->price);
printf("power: %f)", myList->power);
} void deleteList(listElem* sentinel) { listElem *act, *prev;
act = sentinel->next;
while (act) { prev = act;
act = act->next;
free(prev);
} } void listList(listElem* sentinel) { listElem *act=sentinel->next;
printf("List elments: ");
while (act) { displayListElem(act);
act = act->next;
if (act) printf(",");
} printf("\n");
} void insertAfter(listElem* sentinel, listElem* myElem, int place) { } listElem *act=sentinel->next, *prev=sentinel;
while (place>0 && act!=NULL) { prev = act;
act = act->next;
place--;
} prev->next = myElem;
myElem->next = act;
int main() { listElem sentinel={"", 0, 0, NULL}, *temp=NULL;
temp = createListElem();
insertAfter(&sentinel, temp, 2);
listList(&sentinel);
temp = createListElem();
insertAfter(&sentinel, temp, 2);
listList(&sentinel);
temp = createListElem();
insertAfter(&sentinel, temp, 2);
listList(&sentinel);
} temp = createListElem();
insertAfter(&sentinel, temp, 2);
listList(&sentinel);
deleteList(&sentinel);
return 0;

4.4.1. Írjon programot, amely dinamikus struktúrákkal valósítja meg az egyszeresen láncolt listát! Minden rekord tárolja a következő adatokat egy motorról: név, ár, teljesítmény! Valósítsa meg a beszúrást az x. elem után, a listázást és a listatörlést függvényekkel! Ha nincs x darab eleme a listának, akkor a lista végére szúrjon be! Őrszemmel tárolja a lista fejét! Adjon 4 elemet a listához, mindig a második elem után! 
4.4.2. Készítsen függvényt adott sorszámú elem törlésére! 
4.4.2. void deleteAt(listElem* sentinel, int place) { listElem *act=sentinel->next, *prev=sentinel;
place--;
while (place>0 && act!=NULL) { prev = act;
act = act->next;
place--;
} if (act == NULL) return;
prev->next = act->next;
free(act);
act=NULL;
} 
4.4.3.
#include <stdio.h>
#include <malloc.h>
#include <string.h> typedef struct le { char name[100];
int price;
float power;
struct le* next;
} listElem;
listElem* createListElem() { } listElem* result=(listElem*)malloc(sizeof(listElem));
printf("name: ");
scanf("%s", result->name);
printf("price: ");
scanf("%d", &result->price);
printf("power: ");
scanf("%f", &result->power);
result->next = NULL;
return result;
void displayListElem(listElem* myList) { printf("(name: %s, ", myList->name);
printf("price: %d, ", myList->price);
printf("power: %f)", myList->power);
} void deleteList(listElem* sentinel) { listElem *act, *prev;
act = sentinel->next;
while (act) { prev = act;
act = act->next;
free(prev);
} } void listList(listElem* sentinel) { listElem *act=sentinel->next;
printf("List elments: ");
while (act) { displayListElem(act);
act = act->next;
if (act) printf(", ");
} printf("\n");
} void insertAfter(listElem* sentinel, listElem* myElem, int place, int *size) { listElem *act = sentinel->next, *prev = sentinel;
while (place > 0 && act != NULL) { prev = act;
act = act->next;
place--;
} prev->next = myElem;
myElem->next = act;
(*size)++;
} void invertElements(listElem* sentinel, int invert_1, int invert_2) { listElem *act, *inv1, *inv2, *temp, *prev1, *prev2, *next1, *next2, *tempPrev, *tempNext;
int idxI;
act = inv1 = inv2 = prev1 = prev2 = next1 = next2 = tempPrev = tempNext = NULL;
act = sentinel->next;
tempPrev = sentinel;
tempNext = act->next;
for(idxI = 1;
idxI <= invert_1;
++idxI) { if (idxI == invert_1) { inv1 = act;
prev1 = tempPrev;
next1 = tempNext;
} else { tempPrev = act;
act = act->next;
tempNext = act->next;
} } act = sentinel->next;
tempPrev = sentinel;
tempNext = act->next;
for(idxI = 1;
idxI <= invert_2;
++idxI) { if (idxI == invert_2) { inv2 = act;
prev2 = tempPrev;
next2 = tempNext;
} else { tempPrev = act;
act = act->next;
tempNext = act->next;
} } if((invert_1 - invert_2) * (invert_1 - invert_2) == 1) { if(invert_1 < invert_2) { prev1->next = inv2;
inv1->next = inv2->next;
inv2->next = inv1;
} else if(invert_2 < invert_1) { prev2->next = inv1;
inv2->next = inv1->next;
inv1->next = inv2;
} } else if(inv1 != NULL && inv2 != NULL) { prev1->next = inv2;
inv2->next = next1;
prev2->next = inv1;
inv1->next = next2;
} else printf("Cannot invert!\n");
} void listFromEnd(listElem* sentinel, int size) { listElem* act = sentinel->next;
int idxI;
for(idxI = 0;
idxI < size;
++idxI) { if(idxI == size-1) { printf(" (name: %s, ", act->name);
printf("price: %d, ", act->price);
printf("power: %f)", act->power);
if(act == sentinel->next) printf("\n");
else printf(",");
listFromEnd(sentinel, size-1);
} } } else act = act->next;
void searchbyName(listElem* sentinel, int size, int searchAfter, int searchAll, char* name) { listElem *act = sentinel->next;
int idxI;
printf("Found:\n");
for(idxI = 0;
idxI < searchAfter;
++idxI) act = act->next;
while(act != NULL) { if(!strcmp(act->name, name)) printf("(name: %s, price: %d, power: %f)\n", act->name, act>price, act->power);
if(!searchAll) return;
else act = act->next;
} } void searchbyPrice(listElem* sentinel, int size, int searchAfter, int searchAll, int price) { listElem *act = sentinel->next;
int idxI;
printf("Found:\n");
for(idxI = 0;
idxI < searchAfter;
++idxI) act = act->next;
while(act != NULL) { if(act->price == price) printf("(name: %s, price: %d, power: %f)\n", act->name, act>price, act->power);
if(!searchAll) return;
else act = act->next;
} } void searchbyPower(listElem* sentinel, int size, int searchAfter, int searchAll, float power) { listElem *act = sentinel->next;
int idxI;
printf("Found:\n");
for(idxI = 0;
idxI < searchAfter;
++idxI) act = act->next;
while(act != NULL) { if(act->power == power) printf("(name: %s, price: %d, power: %f)\n", act->name, act>price, act->power);
if(!searchAll) return;
else act = act->next;
} } void deletebyName(listElem* sentinel, int* size, char* name) { listElem *act = sentinel->next, *prev = sentinel;
} while(act != NULL) { if(!strcmp(act->name, name)) { prev->next = act->next;
free(act);
act = prev->next;
(*size)--;
} else { prev = act;
act = act->next;
} } void deletebyPrice(listElem* sentinel, int* size, int price) { listElem *act = sentinel->next, *prev = sentinel;
} while(act != NULL) { if(act->price == price) { prev->next = act->next;
free(act);
act = prev->next;
(*size)--;
} else { prev = act;
act = act->next;
} } void deletebyPower(listElem* sentinel, int* size, float power) { listElem *act = sentinel->next, *prev = sentinel;
while(act != NULL) { if(act->power == power) { prev->next = act->next;
free(act);
act = prev->next;
(*size)--;
} } } else { prev = act;
act = act->next;
} int main() { int menu, subMenu, subSubMenu, invert_1, invert_2, listSize = 0, searhAfter, searchPrice, deletePrice, controller, controller2, tempSearchAfter;
float searchPower, deletePower;
char searchName[50], deleteName[50];
listElem sentinel={"", 0, 0, NULL}, *temp=NULL;
temp = createListElem();
insertAfter(&sentinel, temp, 2, &listSize);
listList(&sentinel);
temp = createListElem();
insertAfter(&sentinel, temp, 2, &listSize);
listList(&sentinel);
temp = createListElem();
insertAfter(&sentinel, temp, 2, &listSize);
listList(&sentinel);
for(;;) { printf("\n***Menu***\n");
printf("1. Search\n2. Invert two elements\n3. List from the end\n4. Delete certain element(s)\n5. Exit\n");
scanf("%d", &menu);
switch(menu) { case 1: controller = 0;
for(;controller == 0;) { printf("\n***Search Menu***\n1. Search the first occurrence\n2. Search the first occurrence after index xy\n3. Search all occurrence\n4. Back\n");
scanf(„%d”, &subMenu);
switch(subMenu) { case 1: controller2 = 0;
for(;controller2 == 0;) { printf("***\nSearch the first occ. SubMenu***\n");
printf("1. Search by name\n2. Search by price\n3. Search by power\n4. Back\n");
scanf(„%d”, &subSubMenu);
switch(subSubMenu) { case 1: controller = 1;
controller2 = 1;
printf("Search name? ");
scanf("%s", searchName);
searchbyName(&sentinel, listSize, 0, 0, searchName);
listSize, 0, 0, searchPrice);
listSize, 0, 0, searchPower);
break;
case 2: controller = 1;
controller2 = 1;
printf("Search price? ");
scanf("%d", &searchPrice);
searchbyPrice(&sentinel, break;
case 3: controller = 1;
controller2 = 1;
printf("Search power? ");
scanf("%f", &searchPower);
searchbyPower(&sentinel, break;
case 4: controller2 = 1;
break;
default: controller2 = 0;
index SubMenu***\n");
} } break;
case 2: controller2 = 0;
for(;controller2 == 0;) { printf("\n***Search the first occ after printf("1. Search by name\n2. Search by price\n3. Search by power\n4. Back\n");
scanf("%d", &subSubMenu);
if(subSubMenu == 4) break;
for(tempSearchAfter = 0;
tempSearchAfter == 0;) { printf(„After index? „);
scanf("%d", &searhAfter);
if(searhAfter <= listSize) tempSearchAfter = 1;
else printf(„Bad index!!!\n”);
} switch(subSubMenu) { case 1: controller = 1;
controller2 = 1;
printf("Search name? ");
scanf("%s", searchName);
searchbyName(&sentinel, listSize, searhAfter, 0, searchName);
break;
case 2: controller = 1;
controller2 = 1;
printf("Search price? ");
scanf("%d", &searchPrice);
searchbyPrice(&sentinel, listSize, searhAfter, 0, searchPrice);
break;
case 3: controller = 1;
controller2 = 1;
printf("Search power? ");
scanf("%f", &searchPower);
searchbyPower(&sentinel, listSize, searhAfter, 0, searchPower);
break;
default: controller2 = 0;
} } break;
case 3: controller2 = 0;
for(;controller2 == 0;) { printf("\n***Search all occ. SubMenu***\n");
printf("1. Search by name\n2. Search by price\n3. Search by power\n4. Back\n");
scanf("%d", &subSubMenu);
switch(subSubMenu) { case 1: controller = 1;
controller2 = 1;
printf("Search name? ");
scanf("%s", searchName);
searchbyName(&sentinel, listSize, 0, 1, searchName);
break;
case 2: controller = 1;
controller2 = 1;
printf("Search price? ");
scanf("%d", &searchPrice);
searchbyPrice(&sentinel, listSize, 0, 1, searchPrice);
break;
case 3: controller = 1;
controller2 = 1;
printf("Search power? ");
scanf("%f", &searchPower);
searchbyPower(&sentinel, listSize, 0, 1, searchPower);
break;
case 4: controller2 = 1;
break;
} } } break;
default: controller2 = 0;
if(subMenu == 4) break;
4)\n");
} break;
case 2: for(;;) { printf("\nWhich two would you like to invert? (e.g. 1 scanf("%d%d", &invert_1, &invert_2);
if(listSize < invert_1 || listSize < invert_2 || invert_1 == 0 || invert_2 == 0) printf("Bad index(es)!!!\n");
else { invertElements(&sentinel, invert_1, invert_2);
break;
} } break;
case 3: printf("List elements: ");
listFromEnd(&sentinel, listSize);
break;
case 4: controller = 0;
for(;controller == 0;) { printf("\n*** Delete SubMenu***\n");
printf("1. Delete by name\n2. Delete by price\n3. Delete by power\n4. Back\n");
scanf("%d", &subMenu);
switch(subMenu) { case 1: printf("Delete name? ");
scanf("%s", deleteName);
deletebyName(&sentinel, &listSize, deleteName);
controller = 1;
break;
case 2: printf("Delete price? ");
scanf("%d", &deletePrice);
deletebyPrice(&sentinel, &listSize, deletePrice);
controller = 1;
break;
case 3: printf("Delete power? ");
scanf("%f", &deletePower);
deletebyPower(&sentinel, &listSize, deletePower);
controller = 1;
break;
case 4: controller = 1;
break;
default: controller = 0;
} } break;
case 5: return 0;
} } } deleteList(&sentinel);
return 0;

4.4.3. Írjon függvényeket, amelyek adott mezők alapján keresnek meg elemeket! Legyen olyan változat, amely megadja az első előfordulást, adott indexű elemtől tekintve az első előfordulást, az összes előfordulást! Írjon függvényt, amely sorszám alapján felcserél két elemet, adott tulajdonságú elemeket töröl ki, fordítva járja be a listát (és írja ki az elemeit)! 4.5. Sablon
4.5.1.
#include <iostream>
#include <cstring> using namespace std;
class airplane { public: int id;
int passengers;
airplane(int p1=0, int p2=0) : id(p1), passengers(p2), next(0), prev(0) {} bool operator==(const airplane& para) const;
airplane *next, *prev;
};
ostream& operator<<(ostream& os, const airplane& para) { os << "(id:" << para.id << ", passengers: " << para.passengers << ")";
return os;
} bool airplane::operator==(const airplane& para) const { bool result=false;
if (id==para.id && passengers==para.passengers) result=true;
return result;
} template <typename T1> class list { T1 *head, *tail, *act;
int elemNum;
public: list() : head(0), tail(0), act(0), elemNum(0) {} ~list();
T1* search(const T1& para) const;
void insert(const T1& para);
void delAct();
void moveAct(int para);
T1& getElem() const {return *act;} int getElemNum() const {return elemNum;} template <typename U1> friend ostream& operator<<(ostream&, const list<U1>&);
};
template <typename T1> list<T1>::~list() { T1 *temp=head, *prev;
while (temp) { prev=temp;
} } temp=temp->next;
delete prev;
template <typename T1> T1* list<T1>::search(const T1& para) const { T1* temp=head;
while (temp) { if (*temp==para) return temp;
temp=temp->next;
} return 0;
} template <typename T1> void list<T1>::insert(const T1& para) { elemNum++;
T1 *temp=new T1(para), *before;
if (head==0) { head=tail=act=temp;
return;
} before=act->prev;
if (before==0) head=temp;
else before->next=temp;
temp->next=act;
act->prev=temp;
temp->prev=before;
act=temp;
} template <typename T1> void list<T1>::delAct() { T1 *after, *before;
if (act==0) return;
before=act->prev;
after=act->next;
if (before==0) act=head=after;
else { before->next=after;
act=before;
} if (after==0) tail=before;
else after->prev=before;
elemNum--;
} template <typename T1> void list<T1>::moveAct(int para) { if (para>0) } while (act->next && para) { act=act->next;
para--;
} else while (act->prev && para) { act=act->prev;
para++;
} template <typename U1> ostream& operator<< (ostream& os, const list<U1>& para) { U1* temp=para.head;
if (!temp) os << "empty";
while (temp) { os << *temp << ", ";
temp=temp->next;
} os << endl;
return os;
} int main() { airplane a(1, 500), b(2, 450), c(3, 220), d(4, 260);
list<airplane> myList;
cout << myList;
myList.insert(a);
cout << myList;
myList.insert(b);
cout << myList;
myList.insert(c);
cout << myList;
myList.insert(d);
cout << myList;
cout << "ElemNum:" << myList.getElemNum() << endl;
cout << "act elem: " << myList.getElem() << endl;
cout << "moveAct(2)" << endl;
myList.moveAct(2);
cout << "act elem: " << myList.getElem() << endl;
cout << "delAct()" << endl;
myList.delAct();
cout << myList;
cout << "moveAct(-2)" << endl;
myList.moveAct(-2);
cout << "act elem: " << myList.getElem() << endl;
cout << "delAct()" << endl;
myList.delAct();
cout << "act elem: " << myList.getElem() << endl;
cout << myList;
return 0;
} 
4.5.1. Készítsen egy repülőgép osztályt azonosító, utasok, előző, következő adattagokkal! Készítsen kétszeresen láncolt listát, sablon osztállyal! Tárolja a lista elejét, végét és az aktuális elemet! Valósítsa meg a következő metódusokat: konstruktor, destruktor, adott elem keresése, elem beszúrása aktuális elem elé, aktuális elem törlése, aktuális mutató mozgatása relatív indexszel, aktuális elem referenciájának visszaadása, elemszám visszaadása, kiíró operátor. Tesztelje a listát a repülőgép osztály felhasználásával! 
4.5.2.
#include <iostream>
#include <cstring> using namespace std;
class airplane { public: int id;
int passengers;
airplane(int p1=0, int p2=0) : id(p1), passengers(p2), next(0), prev(0) {} bool operator==(const airplane& para) const;
airplane *next, *prev;
};
ostream& operator<<(ostream& os, const airplane& para) { os << "(id:" << para.id << ", passengers: " << para.passengers << ")";
return os;
} bool airplane::operator==(const airplane& para) const { bool result=false;
if (id==para.id && passengers==para.passengers) result=true;
return result;
} template <typename T1> class list { T1 *head, *tail, *act;
int elemNum;
public: list() : head(0), tail(0), act(0), elemNum(0) {} ~list();
T1* search(const T1& para) const;
void insert(const T1& para);
void delAct();
void delAbs(int para);
void moveAct(int para);
void moveAbs(int para);
T1& getElem() const {return *act;} int getElemNum() const {return elemNum;} template <typename U1> friend ostream& operator<<(ostream&, const list<U1>&);
};
template <typename T1> list<T1>::~list() { T1 *temp=head, *prev;
while (temp) { prev=temp;
temp=temp->next;
delete prev;
} } template <typename T1> T1* list<T1>::search(const T1& para) const { T1* temp=head;
while (temp) { if (*temp==para) return temp;
temp=temp->next;
} } return 0;
template <typename T1> void list<T1>::insert(const T1& para) { elemNum++;
T1 *temp=new T1(para), *before;
if (head==0) { head=tail=act=temp;
return;
} before=act->prev;
if (before==0) head=temp;
else before->next=temp;
temp->next=act;
act->prev=temp;
temp->prev=before;
act=temp;
} template <typename T1> void list<T1>::delAbs(int para) { moveAbs(para);
delAct();
} template <typename T1> void list<T1>::delAct() { T1 *after, *before;
if (act==0) return;
before=act->prev;
after=act->next;
if (before==0) act=head=after;
else { before->next=after;
act=before;
} if (after==0) tail=before;
else after->prev=before;
elemNum--;
} template <typename T1> void list<T1>::moveAct(int para) { if (para>0) while (act->next && para) { act=act->next;
para--;
} else while (act->prev && para) { act=act->prev;
para++;
} } template <typename T1> void list<T1>::moveAbs(int para) { act=head;
for (int i=para;i>0;i--) { act=act->next;
} } template <typename U1> ostream& operator<< (ostream& os, const list<U1>& para) { U1* temp=para.head;
if (!temp) os << "empty";
while (temp) { os << *temp << ", ";
temp=temp->next;
} os << endl;
return os;
} int main() { airplane a(1, 500), b(2, 450), c(3, 220), d(4, 260);
list<airplane> myList;
cout << myList;
myList.insert(a);
cout << myList;
myList.insert(b);
cout << myList;
myList.insert(c);
cout << myList;
myList.insert(d);
cout << myList;
cout << "ElemNum:" << myList.getElemNum() << endl;
cout << "act elem: " << myList.getElem() << endl;
cout << "moveAct(2)" << endl;
myList.moveAct(2);
cout << "act elem: " << myList.getElem() << endl;
cout << "delAct()" << endl;
myList.delAct();
cout << myList;
cout << "moveAct(-2)" << endl;
myList.moveAct(-2);
cout << "act elem: " << myList.getElem() << endl;
cout << "delAct()" << endl;
myList.delAct();
cout << "act elem: " << myList.getElem() << endl;
cout << myList;
return 0;
} 
4.5.2. Írjon metódust az aktuális mutató abszolút mozgatására, adott sorszámú elem törlésére, adott objektum törlésére, a teljes lista törlésére, aktuális mutató utáni beszúrásra! 4.6. Lista
4.6.1.
#include <stdio.h>
#include <stdlib.h> struct TElement { struct TElement * next;
int Data;
};
struct TList { struct TElement * Head;
struct TElement * Actual;
};
void InitList(struct TList * L) { L->Head = L->Actual = NULL;
} void Add(struct TList * L, int data) { if (L->Head == NULL) L->Head = L->Actual = (struct TElement *)malloc(sizeof(struct TElement));
else { L->Actual->next = (struct TElement *)malloc(sizeof(struct TElement));
L->Actual = L->Actual->next;
} L->Actual->Data = data;
L->Actual->next = NULL;
} void PrintList(struct TList * L) { if (L->Head == NULL) return;
L->Actual = L->Head;
printf("The list: ");
while (L->Actual->next) { printf("%d ", L->Actual->Data);
L->Actual = L->Actual->next;
} printf("%d\n", L->Actual->Data);
} void FreeList(struct TList * L) { struct TElement * tmp;
if (L->Head == NULL) return;
L->Actual = L->Head;
do { tmp = L->Actual;
L->Actual = L->Actual->next;
free(tmp);
tmp = NULL;
} while (L->Actual);
} int main() { struct TList List;
int num;
InitList(&List);
do { printf("Type a number: ");
scanf("%d", &num);
if (num != 0) { if (num != -1) Add(&List, num);
else PrintList(&List);
} } while (num != 0);
FreeList(&List);
return 0;
} 
4.6.1. Írjon programot, amely számokat olvas be a billentyűzetről addig, amíg a beolvasott szám nem 0! A program fűzze a beolvasott számot egy egyszeresen láncolt lista végére! A -1 gépelése után írja ki a képernyőre a lista tartalmát! Valósítsa meg az add és print függvényeket, valamint a lista felszabadítását! Példa: Type a number: 10 Type a number: 20 Type a number: 30 Type a number: -1 The list: 10 20 30 Type a number: 40 Type a number: 50 Type a number: -1 The list: 10 20 30 40 50 Type a number: 0 4.7. Prímszita
4.7.1.
#include <stdio.h>
#include <stdlib.h> struct PrimeArray { int current_number;
struct PrimeArray* next;
};
void UploadPrimeArray(struct PrimeArray*, int);
void ListPrimeArray(struct PrimeArray);
void RemoveNotPrimes(struct PrimeArray*);
void FreePrimeArray(struct PrimeArray*);
int main() { int MAX_NUMBER;
struct PrimeArray my_prime_array;
printf("Pleas enter a number, the orignal list will be generated from 2 to this number.\n");
scanf("%d", &MAX_NUMBER);
printf("The original list:\n");
UploadPrimeArray(&my_prime_array, MAX_NUMBER);
ListPrimeArray(my_prime_array);
RemoveNotPrimes(&my_prime_array);
printf("\n\nThe list, after removing not primes:\n");
ListPrimeArray(my_prime_array);
FreePrimeArray(&my_prime_array);
return 0;
} void UploadPrimeArray(struct PrimeArray* first, int max_number) { int i;
struct PrimeArray* actual;
actual = first;
actual->current_number = 2;
actual->next = NULL;
for (i = 3;
i <= max_number;
++i) { actual->next = (struct PrimeArray*)malloc(sizeof(struct PrimeArray));
actual = actual->next;
actual->current_number = i;
actual->next = NULL;
} } void ListPrimeArray(struct PrimeArray first) { int i = 1;
struct PrimeArray* actual = &first;
while (actual) { printf("%3d.element: %3d\n", i++, actual->current_number);
actual = actual->next;
} } void RemoveNotPrimes(struct PrimeArray* first) { struct PrimeArray* actual, *prev, *next;
while (first->next) { actual = first->next;
prev = first;
next = actual->next;
while (actual->next) { if ((actual->current_number % first->current_number) == 0) { free(actual);
actual = next;
next = actual->next;
prev->next = actual;
} else { prev = actual;
actual = actual->next;
next = actual->next;
} } printf("\nInner steps (%%%d)\n", first->current_number);
ListPrimeArray(*first);
first = first->next;
} } void FreePrimeArray(struct PrimeArray* first) { fel struct PrimeArray* actual = first->next;
while (actual) { first = actual->next;
free(actual);
actual = first;
} } 
4.7.1. Kérjünk be egy tetszőleges egész számot (n), majd egy listába tegyük be 2-től n-ig a természetes számokat! Vegyünk ki minden nem prím számot a listából! Ötlet: a lista első eleme (2) prím, minden olyan számot törlünk, amely osztható ezzel a számmal (az első iterációban 2 kivételével az összes páros szám törlődik). A megmaradt elemek közül a következő ismét prím, töröljük ennek is minden többszörösét. Ezt ismételjük addig, amíg a lista végére nem érünk, ekkor írjuk ki a listát! 4.8. Halmazműveletek
4.8.1. Hozzunk létre két rendezett listát, majd készítsük el a két lista unióját, az eredményt az első listában tároljuk! 
4.8.1.
#include <stdio.h>
#include <malloc.h> struct array { int current_number;
struct array* next;
};
void Uploadarray(struct array*, int*, int);
void Combarrays(struct array**, struct array**);
void Listarray(struct array*);
void FreeArray(struct array*);
int main() { struct array * head_first,* head_second;
int set_1[] = {1, 2, 4, 5, 6, 8, 9, 10, 13};
int set_2[] = {0, 2, 3, 5, 6, 7, 9, 11, 12, 13};
head_first = (struct array*)malloc(sizeof(struct array));
head_second = (struct array*)malloc(sizeof(struct array));
} Uploadarray(head_first, set_1, sizeof(set_1)/sizeof(int));
Uploadarray(head_second, set_2, sizeof(set_2)/sizeof(int));
printf("First list:\n");
Listarray(head_first);
printf("\nSecond list:\n");
Listarray(head_second);
Combarrays(&head_first, &head_second);
printf("\nFirst list after creating the union of the sets:\n");
Listarray(head_first);
FreeArray(head_first);
return 0;
void Uploadarray(struct array* first, int* array_here, int size) { int i;
struct array* actual;
actual = first;
actual->current_number = array_here[0];
actual->next = NULL;
for(i = 1;
i < size;
i++) { actual->next = (struct array*)malloc(sizeof(struct array));
actual = actual->next;
actual->current_number = array_here[i];
actual->next = NULL;
} } void Combarrays(struct array** first_start, struct array** second_start) { struct array *first, *first_temp, *second_temp, *prev;
if ((*first_start)->current_number > (*second_start)->current_number) { first_temp = *first_start;
second_temp = *second_start;
*second_start = (*second_start)->next;
(*first_start) = second_temp;
(*first_start)->next = first_temp;
} prev = first = *first_start;
while (first && (*second_start)) { if(first->current_number == (*second_start)->current_number) { prev = first;
first = first->next;
second_temp = (*second_start);
(*second_start) = (*second_start)->next;
free(second_temp);
} else if(first->current_number < (*second_start)->current_number) { prev = first;
first = first->next;
} else if(first->current_number > (*second_start)->current_number) { second_temp = (*second_start);
(*second_start) = (*second_start)->next;
prev->next = second_temp;
prev->next->next = first;
prev = second_temp;
} } if((*second_start)) first->next = (*second_start);
} void Listarray(struct array* first) { int i = 1;
struct array* actual = first;
while(actual) { printf("%d.element: %d\n", i++, actual->current_number);
actual = actual->next;
} } void FreeArray(struct array* actual) { struct array* temp = actual;
while(temp) { actual = temp->next;
free(temp);
temp = actual;
} } 
4.8.2.
#include <stdio.h>
#include <malloc.h> struct array { int current_number;
struct array* next;
};
void UploadArray(struct array*, int*, int);
void ListArray(struct array*);
void FreeArray(struct array*);
void Intersection(struct array**, struct array*);
int main() { struct array* first, *second;
struct array** ptr_first;
int numbers_1[8] = {0,1,5,7,9,13,19,96};
int numbers_2[8] = {1,4,9,15,19,25,37,45};
first = (struct array*)malloc(sizeof(struct array));
second = (struct array*)malloc(sizeof(struct array));
ptr_first = &first;
UploadArray(first, numbers_1, 8);
UploadArray(second, numbers_2, 8);
printf("The first list:\n");
ListArray(first);
printf("\nThe second list:\n");
ListArray(second);
Intersection(ptr_first, second);
printf("\nThe first list after creating the intersecrion of the lists:\n");
ListArray(first);
FreeArray(first);
FreeArray(second);
return 0;
} void UploadArray(struct array* first, int* numbers, int size) { int i;
struct array* actual = first;
for(i = 0;
i < size;
i++) { if(i) { actual->next = (struct array*)malloc(sizeof(struct array));
actual = actual->next;
} actual->current_number = numbers[i];
actual->next = NULL;
} } void ListArray(struct array* first) { int i = 1;
while(first) { printf("%d.element: %d\n", i++, first->current_number);
first = first->next;
} } void FreeArray(struct array* actual) { struct array* temp = actual;
while(temp) { actual = temp->next;
free(temp);
temp = actual;
} } void Intersection(struct array** first, struct array* second) { struct array* prev_first, *prev_second, *element_next;
while((*first) && second) { if((*first)->current_number > second->current_number) { prev_second = second;
second = second->next;
free(prev_second);
} else if((*first)->current_number < second->current_number) { prev_first = *first;
*first = (*first)->next;
free(prev_first);
} else { element_next = *first;
prev_first = element_next;
element_next = element_next->next;
second = second->next;
break;
} } while(element_next && second) { if(element_next->current_number > second->current_number) { second = second->next;
} else if(element_next->current_number < second->current_number) { prev_first->next = element_next->next;
free(element_next);
element_next = prev_first->next;
} else { prev_first = element_next;
element_next = element_next->next;
second = second->next;
} } if(element_next) { prev_first->next = NULL;
FreeArray(element_next);
} } 
4.8.2. Unió helyett a két lista metszetét képezzük! 5. A verem és sor adatszerkezetek feladatai 5.1. Verem osztály
