The uploaded PDF is a slide deck titled **"Programozás II. – 4. előadás: OOA & OOD"** by B from the University. It covers **Object-Oriented Analysis and Design (OOA & OOD)**, focusing on building domain and design models.

Here’s a quick summary of the key concepts covered:

---

### 🧩 **OOA & OOD Workflow**

1. **Domain Model (OOA)**:

   * **Step I**: Identify **conceptual classes** (based on nouns and domain concepts).
   * **Step II**: Add **associations** (relationships between classes).
   * **Step III**: Add **attributes** (only store what's needed; use classes for complex data).

2. **Design Model (OOD)**:

   * **Step IV**: Assign **responsibilities** and define **methods**.

---

### 🏷️ **Conceptual Classes**

* Represent real-world domain concepts (not software artifacts).
* Examples: `Sale`, `Item`, `Customer`, etc.
* Avoid implementation details (e.g., no methods).

---

### 🔗 **Associations**

* Represent meaningful relationships between classes.
* Use **multiplicities** (`1`, `0..1`, `*`, etc.) to define quantity.
* Avoid derived or redundant associations for clarity.

---

### 📋 **Attributes**

* Keep them **simple** (e.g., numbers, dates, strings).
* If an attribute is complex or has behavior, consider making it a class.
* Don’t use foreign keys as attributes.

---

### 🛠️ **GRASP Patterns** (Design responsibilities)

1. **Expert** – Assign responsibility to the class with the information.
2. **Creator** – A class creates instances of classes it contains or closely uses.
3. **Low Coupling** – Minimize dependencies between classes.
4. **High Cohesion** – Keep classes focused and manageable.
5. **Controller** – Assign system event handling to non-UI controller classes.

---

Would you like a detailed visual guide or summary sheet of this content in English or Hungarian?


**TL;DR of Slide 2 – Object-Oriented Analysis and Design (OOA & OOD):**

* **Domain Model (Analysis):**

  1. Identify *conceptual classes* (real-world entities)
  2. Add *associations* (relationships between classes)
  3. Add *attributes* (properties of the classes)

* **Design Model (Design):**
  4\. Assign *responsibilities* to classes – this includes defining their *methods*

This process moves from modeling reality to designing the software structure based on that model.

Would you like a simple example of each step in English?

**Slide 3 – TL;DR in English:**

* Identify the **conceptual classes**
* Create the **initial domain model**
* Distinguish between **valid and invalid attributes**
* Use **descriptive classes** where appropriate
* Be careful **not to mix conceptual and implementation views**

These are the key steps for building a clear, real-world-based domain model before software design begins.

Would you like a quick example of a valid vs. invalid attribute?

**Conceptual Class – "Sale" (Slide Explanation in English):**

* **Concept's Symbol:**
  `Sale` — this represents a conceptual class, not a software class.

* **Concept's Intension (Definition):**
  *"A sale represents the event of a purchase transaction. It has a date and time."*
  → This describes what a Sale **means** in the domain.

* **Concept's Attributes:**

  * `date`
  * `time`

* **Concept's Extension (Instances):**
  Examples of actual sales:
  `sale-1`, `sale-2`, `sale-3`, `sale-4`
  → These are specific real-world instances of the `Sale` concept.

This slide emphasizes that **conceptual classes** represent **real-world ideas**, not implementation constructs like software classes or database tables.

Would you like this explanation as a visual diagram or study card?

**Slide 5 – TL;DR in English:**

> **Fundamental Principle:**
> The **domain model describes reality** using **conceptual classes**.
> It is **not** a diagram of software classes, objects, or their responsibilities.

👉 The domain model reflects **real-world concepts**, not the software implementation.

Would you like a rule-of-thumb for telling the difference between a domain model and a software design model?

**Slide 6 – TL;DR in English:**

> **Example – Sale**
> `Sale` is a **visualization of a real-world concept** within the domain (e.g., sales transactions).
> It includes attributes like `date` and `time`.

> ⚠️ **Important note:**
> This is **not a software class** — it’s a **conceptual model** of something from the real world.

So: **"Sale" in this context = business concept**, not code.

Would you like a visual comparison between conceptual and software classes?



**Slide 7 – TL;DR in English:**

> **Counterexample – What Not to Include in the Domain Model:**

* **`SalesDatabase`, `Sale` with methods like `print()` and IDs**
  → These are **software artifacts** (implementation-specific), not part of the **domain model**.

* The presence of:

  * `id` fields
  * Operations like `print()`
  * System/storage classes (e.g., `SalesDatabase`)
    Indicates this is a **software class**, **not** a **conceptual class**.

> ✅ **Domain model ≠ software class diagram**
> Focus on modeling real-world **concepts**, **not code structure**.

Want a checklist to help decide whether something belongs in a domain model?




**Slide 8 – TL;DR in English:**

> **What the Domain Model Describes:**

* The **objects/classes of the real world** (not code)
* The **relationships (associations)** between conceptual classes
* The **attributes** of those conceptual classes
* ❌ **No methods** — the domain model does **not** include behavior or operations

✅ In short: The domain model shows **what exists** and **how things are related**, not **what they do**.

Would you like an example domain model diagram next?

**Slide 9 – TL;DR in English (Domain Model Example):**

This is a **conceptual domain model** illustrating real-world entities and relationships.

---

### ✅ **Conceptual Classes (Real-World Objects):**

* `Sale` – with attributes `date`, `time`
* `Store` – with `name`, `address`
* `Register`, `LineItem`, `Item`, `Payment`

---

### 🔗 **Associations (Relationships):**

* A `Store` *houses* a `Register`
* A `Register` *records* a `Sale`
* A `Sale` *contains* `LineItem`s
* A `LineItem` refers to an `Item` and a quantity
* A `Sale` is *paid by* one or more `Payment`s

---

### 🔢 **Multiplicity Examples:**

* A `Sale` has **1..**\* `LineItems`
* A `Store` has **1** `Register`
* A `LineItem` has **0..1** `Item`

---

This diagram is a **pure domain model**: it uses **conceptual classes**, **attributes**, and **associations** to represent the business reality — **no methods, no software details**.

Would you like this turned into a simplified UML diagram for study?


**Slide 10 – TL;DR in English:**

> **Guidelines for Building the Domain Model:**

* ✅ It’s **better to be too detailed** than not detailed enough.
* 🚫 Don’t assume that a **simpler model is always better**.
* 🛠️ It’s **normal to forget things** at first — refine and expand later.
* 💡 **Don’t be afraid** to include real-world objects that **aren’t strictly required** by the current system requirements.

**Bottom line:** Start broad, model the domain thoroughly, and **trim later if needed** — not the other way around.

Would you like a checklist of things to include in your first draft domain model?


**Slide 11 – TL;DR in English:**

> **How to Identify Conceptual Classes:**

* 📋 Use a **list of conceptual class categories** (e.g., physical things, events, roles).
* 🔍 Look for **nouns in the requirement descriptions** — they often point to key domain concepts.

This step helps you extract relevant real-world concepts for your domain model from natural language specifications.

Would you like a full list of the conceptual class categories from the next slides?


**Slide 12 – TL;DR in English:**

> **Conceptual Class Categories (Part 1):**
> Use these types of domain elements to identify useful conceptual classes:

1. 🧱 **Physical, tangible objects** (e.g., cash register, airplane)
2. 📄 **Descriptions, designs, or specifications** of something (e.g., product description)
3. 📍 **Places** (e.g., store, airport)
4. 🔄 **Transactions** (e.g., order, payment)
5. 🧾 **Transaction steps or items** (e.g., a single sale item)
6. 📦 **Containers of other things** (e.g., warehouse, plane)
7. 💻 **External electronic/computer systems** (e.g., credit card reader, air traffic control system)

This helps guide you when analyzing a domain and deciding what concepts to model.

Would you like the second half of the category list next?



**Slide 13 – TL;DR in English:**

> **Conceptual Class Categories (Part 2):**

8. 💭 **Abstract concepts** (e.g., hunger, illness)
9. 🏢 **Organizations** (e.g., produce department)
10. 📅 **Events** (e.g., meeting, flight, sale, landing)
11. 🔄 **Processes** (e.g., product sale, seat reservation)
12. 📜 **Rules and policies** (e.g., refund policy, cancellation policy)
13. 📚 **Catalogs** (e.g., product catalog)
14. 🗂️ **Records** (e.g., financial, legal, or employment records)
15. 💳 **Financial services and instruments** (e.g., credit)
16. 📘 **Documents, references, descriptions, books**

This extended list broadens your view to include **non-physical** but still important domain concepts in your model.

Want an example use case with identified conceptual classes based on this list?

**Slide 14 – TL;DR in English:**

> **Identifying Nouns in Requirements Text**

* 🔍 **Look for nouns** in requirement descriptions — they can help spot **candidate classes**.
* ⚠️ **Important:** Don’t automatically turn every noun into a class!
  Instead, use nouns to **cross-check** that you haven’t **missed important concepts**.

**Example (from a use case):**

> *"The customer arrives at the register with the items they want to buy. The cashier scans the item's ID."*

✅ Possible conceptual classes:

* `Customer`, `Register`, `Item`, `Cashier`, `ItemID`

This method helps extract domain-relevant classes from plain-language descriptions.

Would you like help turning a paragraph into conceptual classes using this method?

**Slide 15 – TL;DR in English:**

> **Steps to Describe the Domain Model:**

1. **Identify conceptual classes** (real-world entities)
2. **Draw the initial domain model** (just the classes)
3. **Add associations** (relationships between classes)
4. **Add attributes** (properties of the classes)

✅ This structured approach helps build a clear and complete conceptual understanding of the problem domain — before moving on to software design.

Would you like a visual version of these four steps as a diagram?

**Slide 16 – TL;DR in English:**

> **Step I – Identifying Classes**

* Begin by listing the **core conceptual classes** in the domain.
* These are typically the **main entities** you’ve found by:

  * Reviewing requirements
  * Spotting key nouns
  * Using the conceptual class category list

✅ This is the **first step** in building a domain model — focusing **only on the classes**, without yet adding relationships or attributes.

Would you like an example list of typical classes in a retail or store system?

**Slide 17 – TL;DR in English:**

> **Example – Conceptual Classes Identified:**

These are examples of real-world concepts chosen as **conceptual classes** for a sales system:

* `Register`
* `Item`
* `Store`
* `Sale`
* `SalesLineItem`
* `Cashier`
* `Customer`
* `Ledger`
* `CashPayment`
* `ProductCatalog`
* `ProductDescription`

✅ These represent **things, roles, or records** in the real world — not yet software implementations.

Would you like to see how these can be connected in a class diagram?


**Slide 18 – TL;DR in English:**

> **How to Name Conceptual Classes – Guidelines:**

* 🎯 Think like a **cartographer** (map maker):

  * Use **existing, familiar terms** from the real-world domain
  * Ignore **unimportant** or irrelevant details
  * Do **not invent or include things** that don’t exist in the real domain

✅ The goal is to keep your domain model **accurate and realistic**, using the **language of the stakeholders**.

Would you like tips on avoiding common naming mistakes in domain modeling?


**Slide 19 – TL;DR in English:**

> **Common Mistake in Class Identification:**

* **Guideline:**
  If something (X) **isn’t just a number or a text** in the real world, then **X should probably be a class**, **not an attribute**.

✅ Ask yourself:

> *“Is this concept more than just data?”*
> If yes → model it as a **class**.

This helps avoid oversimplifying your domain model by incorrectly treating complex concepts as simple fields.

Want an example of turning an attribute into a class correctly?


**Slide 20 – TL;DR in English:**

> **Identifying Descriptive Classes (e.g., Product Descriptions):**

**Guidelines:**

* 📦 Use a descriptive class when the **description applies to many instances** (e.g., all items of the same type).
* 🛑 If information is **not regularly updated per instance**, and we want to **avoid data loss**, model it separately.
* 🔁 If it helps **reduce redundancy**, it should be a separate **descriptive class**.

✅ Example:
Use `ProductDescription` (with price, name, etc.) instead of duplicating those details in every `Item`.

Would you like to see the “worse vs. better” modeling example from the next slide?






**Slide 21 – TL;DR in English:**

> **Example: Descriptive Class – Better vs. Worse Design**

* ❌ **Worse design**:
  The `Item` class stores `description`, `price`, and `itemID` directly → leads to **redundancy** and **duplication**.

* ✅ **Better design**:
  Create a separate `ProductDescription` class that **describes multiple `Item` instances**.

**Key takeaway:**
Use a **descriptive class** (`ProductDescription`) when the information is **shared** across many instances of another class (`Item`).

Would you like help modeling a similar "better vs. worse" case with your own domain?





**Slide 22 – TL;DR in English:**

> **Example: Descriptive Class – Flight vs. FlightDescription**

* ❌ **Worse design**:
  Each `Flight` holds its own `number`, even though multiple flights with the **same number** may exist on different days → leads to **duplication**.

* ✅ **Better design**:
  Create a `FlightDescription` class with the shared `number` and route info. Each `Flight` instance then refers to that description.

**Key idea:**
Use a **descriptive class** like `FlightDescription` to store **shared static data** (like flight number, destination), and separate it from **dynamic instances** like `Flight` (with date/time).

Want a diagram that generalizes this kind of relationship?





**Slide 23 – TL;DR in English:**

> **UML and the Domain Model**

* 📘 **UML** provides basic diagram types like:

  * **Class diagrams**
  * **Sequence diagrams**

* ⚙️ UML is **not methodology-dependent** — it **doesn’t define** domain or implementation models.

* ✅ Therefore, **don’t let UML limit you**:

  * A **class diagram** can be used in a **conceptual**, **design**, or **implementation** context.

**Key takeaway:**
UML is a **tool**, not a method — use it flexibly to support your modeling needs at any level.

Would you like a summary of how class diagrams differ between conceptual and implementation models?







**Slide 24 – TL;DR in English:**

> **Step II – Adding Associations**

Once you’ve identified the conceptual classes, the next step is to **define associations** between them.

* Associations represent **real-world relationships** (e.g., “a Sale contains LineItems”).
* They are key to expressing how objects are **connected** and **interact** in the domain.

✅ This step enriches your model by showing **structure and context** beyond isolated classes.

Would you like to see a list of common real-world association patterns next?









**Slide 25 – TL;DR in English:**

> **Identifying Associations**

* 🔗 Focus on **associations that store knowledge** — ones that represent meaningful relationships in the domain.
* 📋 Use a **list of common association types** as a guide.
* 📌 **Note:** The **direction of an association** is not important for the model’s logic — it’s only to **improve readability**.

✅ Good associations help you express **how classes are related** in the real world.

Would you like to see the upcoming list of frequent association patterns?




**Slide 26 – TL;DR in English:**

> **Example of an Association:**

* The conceptual class `Register` is **associated** with `Sale`.
* The relationship is named: `Records-current`.
* The multiplicity is **1 to 1** → each `Register` is recording exactly one current `Sale`.

✅ This illustrates a **typical real-world link** between objects, captured in the domain model.

Would you like an example with one-to-many or optional associations next?


**Slide 27 – TL;DR in English:**

> **Example – Reading Direction in Associations**

* The **arrow** (→) on an association has **no semantic meaning** — it only shows the **reading direction** for the label (e.g., “Register records current Sale”).
* It’s **optional** and often omitted.
* **Multiplicity** is still important:

  * `Register` → 1
  * `Sale` → 0..1 (i.e., a register may or may not have a sale recorded)

✅ Focus on **meaningful relationships** and **correct multiplicities**, not the arrow direction.

Would you like a reference for all UML multiplicity options?



**Slide 28 – TL;DR in English:**

> **Common Association Patterns** (real-world relationships to consider when modeling):

* 🧩 **Part of**: A is a physical/logical part of B (e.g., *wing – airplane*, *line item – sale*)
* 📦 **Contained in**: A is physically in/on B (e.g., *cash register – store*)
* 📄 **Described by**: A describes B (e.g., *product description – item*)
* 📘 **Entry in**: A is an item/record/transaction of B (e.g., *repair – service log*)
* 🧾 **Recorded in**: A is logged/stored/identified in B (e.g., *sale – cash register*)
* 👥 **Member of**: A is a member/employee of B (e.g., *cashier – store*)
* 🏢 **Organizational unit of**: A is a subunit of B (e.g., *department – store*)

✅ These patterns help you identify **realistic, meaningful associations** in your domain model.

Want the rest of this list (continued in the next slide)?








**Slide 29 – TL;DR in English:**

> **Common Association Patterns (continued):**

* 🛠️ **Uses or operates** B (e.g., *cashier – register*, *pilot – airplane*)
* 💬 **Communicates with** B (e.g., *customer – cashier*)
* 💳 **Involved in a transaction with** B (e.g., *buyer – payment*, *passenger – ticket*)
* 🔁 **One transaction is linked to another** (e.g., *payment – purchase*, *booking – cancellation*)
* ➡️ **Follows B** (e.g., *invoice line – invoice*, *city – city*)
* 🏠 **Owned by** B (e.g., *register – store*, *plane – airline*)
* 📅 **Event related to** B (e.g., *sale – customer*, *landing – plane*)

✅ Use these real-world patterns to **inspire accurate associations** between your domain model classes.

Would you like to move on to the *key associations* to always include?





**Slide 30 – TL;DR in English:**

> **Key Associations You Should Not Miss:**

1. 🧩 **A is a physical or logical part of B**
   *(e.g., a line item is part of a sale)*
2. 📦 **B physically or logically contains A**
   *(e.g., a store contains registers)*
3. 🧾 **B records or logs A**
   *(e.g., a register records sales)*

✅ These are **high-priority associations** that typically reflect the **core structure** of your domain.

Would you like to continue with the guidelines for choosing associations?


**Slide 31 – TL;DR in English:**

> **Guidelines for Associations in the Domain Model:**

* 🎯 **Focus on meaningful associations** — those that carry information **for some duration** (not just momentary).
* 📌 **Identifying the right classes** is more important than identifying every possible relationship.
* 🧠 **Too many associations** can make the model **confusing** and hard to read.
* 🧹 **Avoid redundant or derived associations**, as they clutter the model unnecessarily.

✅ Keep your model **clear, focused, and maintainable**.

Would you like to go on to the topic of multiplicities?








**Slide 32 – TL;DR in English:**

> **Association Multiplicities Explained:**

* `*` → **Zero or more**
* `a..b` → **At least `a` and at most `b`**
* `a..*` → **At least `a` (no upper limit)**
* `0..b` → **At most `b` (can be none)**

✅ Multiplicities define **how many instances** of one class can be associated with instances of another — a **crucial aspect** of accurate modeling.

Would you like to go through examples of these multiplicities next?








**Slide 33 – TL;DR in English:**

> **Example of Association Multiplicity:**

* `Store 1 — Stocks — * Item`

This means:

* 🔹 **One** store can stock **multiple items**
* 🔹 Each item can be stocked by **zero or more** stores (if bidirectional)

The `*` signifies a **"many"** side — zero or more instances.

✅ This type of multiplicity is common in one-to-many relationships in real-world systems.

Ready for the next example showing more multiplicity types?







**Slide 34 – TL;DR in English:**

> **Examples of Multiplicities:**

* `*` → **Zero or more** (e.g., an item can be in many orders, or none)
* `1..*` → **One or more** (must have at least one)
* `1..40` → **Between one and forty**
* `5` → **Exactly five**
* `3, 5, 8` → **Exactly three, five, or eight**

✅ Multiplicities precisely define **how many related instances** are allowed — ensuring correct **constraints** in the model.

Would you like to continue with another multiplicity example involving flights and airports?






**Slide 35 – TL;DR in English:**

> **Example: Multiplicity in Flight–Airport Association**

* `Flight * — Flies-to — 1 Airport`
* `Flight * — Flies-from — 1 Airport`

This means:

* ✈️ **Each flight** departs from **one** airport and arrives at **one** airport.
* 🛫 **Each airport** can be the origin or destination for **many flights**.

✅ A common **many-to-one relationship** used in travel and logistics systems.

Ready for the notes on naming associations?




**Slide 36 – Notes (TL;DR English Version):**

* 📏 Multiplicity is often a matter of **interpretation** (e.g., how to model ownerless or disloyal dogs).
* 🏷️ Association names:

  * Can be written in different formats (e.g., `DogOwner`, `dog-owner`, or `dog_owner`).
  * Choose names that clearly express the relationship.

Shall we continue with Slide 40?





**Slide 37 – TL;DR in English:**

> **Conceptual Class Example with Associations:**

A complex domain model showing:

* Classes like `Sale`, `SalesLineItem`, `ProductDescription`, `Register`, `Store`, `CashPayment`, etc.
* Associations such as:

  * `Sale` *contains* `SalesLineItem`
  * `SalesLineItem` *describes* a `ProductDescription`
  * `Register` *captures* the `Sale`
  * `Sale` *paid-by* `CashPayment`
  * `Cashier` *works-on* `Register`

✅ This diagram integrates **classes, associations**, and **multiplicities**, forming a **complete conceptual view** of a retail transaction domain.

Would you like a simplified redraw or interpretation of this UML diagram?




**Slide 38 – TL;DR in English:**

> **III. Adding Attributes – Principles**

* ✅ Only include information explicitly required by system requirements.
* 📊 Use **simple data types** (text, number, date, boolean, etc.).
* ⚠️ If unsure whether something should be an attribute or a class → **make it a class**.
* ❌ **Never** use foreign keys as attributes in the domain model.

✔️ Keep attributes **clear**, **minimal**, and **meaningful** — focus on representing **real-world properties**, not implementation details.

Shall we continue with attribute examples?



**Slide 39 – Key Principles (TL;DR English Version):**

* ✅ Only store **information required by the system's requirements**.
* 📌 Attributes should be **simple data types** like text, number, boolean, date, time.
* 🧾 Examples: address, color, shape, phone number, ID number, barcode, zip code, enums.
* ⚠️ If unsure whether something should be a class or an attribute → **prefer making it a class**.
* ❌ **Never** use **foreign keys** as attributes in the domain model.

Would you like the TL;DR for Slide 40 next?


**Slide 40 – Example: Attributes (TL;DR English Version):**

* `Sale` class has:

  * `dateTime`: a regular attribute (simple data type).
  * `/total: Money`: a **derived attribute** (computed from other data, not stored directly).

Would you like the TL;DR for Slide 41 next?


**Slide 41 – How to recognize if an attribute should be a class (TL;DR English):**

Turn an attribute into a class if:

* It has **separable parts** (e.g., name → first + last).
* It has **related operations** (e.g., ID number validation).
* It has **its own attributes** (e.g., promo price with start/end dates).
* It includes a **unit of measure** (e.g., currency).
* It is a **composite code** (e.g., barcode with country, manufacturer, etc.).

Want the TL;DR for Slide 42?



**Slide 42 – Attribute or Class? (TL;DR English):**

❌ **Worse:** Treating `currentRegister` as just a simple data attribute.

✅ **Better:** Model `Register` as a separate class and use an association:

* `Cashier` → *uses* → `Register`

**Key Idea:** If it's more than a number or text (i.e., it refers to another object), it should be a class, not just an attribute.

Continue to Slide 43?




**Slide 43 – Example: Attribute or Class? (TL;DR English):**

❌ **Worse:** Using `destination` as a simple attribute in `Flight`.

✅ **Better:** Represent `destination` as a relationship to a separate `Airport` class.

**Key Idea:** When the attribute represents a rich concept (like a real-world entity), use an association to a conceptual class instead of a plain attribute.

Would you like the TL;DR for slide 44 next?


Here's a quick summary:

The example seems to describe an object-oriented design involving attributes and classes. It shows how attributes like `itemId`, `manufacturerCode`, and `countryCode` are part of different classes such as `Product` and `Store`. The `Store` class has an attribute `address`, which is another class (`Address`). The relationships between these classes are illustrated.

* `Product` has attributes like `Description`, `itemId`, and others.
* `Store` has attributes like `street1`, `street2`, `cityName`, and an `address` of type `Address`.



In this example:

* **Worse:** The `Cashier` is treated as a "simple" attribute but is being used as a foreign key to relate to another object, like a `Register`. This design is less flexible because it combines two different concepts (a simple attribute and a foreign key) into one, making it harder to extend or maintain.

* **Better:** In the improved design, `Cashier` is a class that has attributes like `name` and `currentRegisterNumber`. Additionally, the `Works-on` relationship is expressed explicitly, which means that a `Cashier` can work on one or more `Register` objects, with `Register` having a `number`. This clearly separates different concepts and shows how they are related, improving the overall design.

In summary:

* **Worse** mixes simple attributes with foreign keys.
* **Better** separates concerns and defines the relationship more clearly.


In this example:

* **Not useful:** The `amount` attribute in the `Payment` class is just a generic `Number`, which doesn't provide enough context about what the number represents.

* **Better:** The `amount` is refined to be either `Quantity` or `Money`. `Quantity` represents a general amount, while `Money` is a specialized type of `Quantity` with a unit of currency. This is a better design because it adds more meaning to the `amount` by specifying its type, making the model clearer and more structured.

In summary:

* **Not useful**: A generic `Number` for `amount`.
* **Better**: `Amount` is modeled as `Quantity` or `Money` to add context and meaning.



This domain model illustrates the relationships between various entities in a sales system:

* **Records-sale-of:** This represents the overall process of recording a sale, involving classes like `Ledger`, `Sales`, and `CashPayment`.
* **Ledger:** A class that records details of sales transactions.
* **Product Catalog:** Contains items like `LineItem`, which describe the products sold.
* **Sales:** Represents a sale, with attributes like `total` and `dateTime`, and can be paid using `CashPayment`.
* **LineItem:** Represents a specific item in a sale, linked to a `Product`.
* **CashPayment:** Captures payment details, including `amountTendered`.
* **Register:** Represents a store register that records sales transactions.
* **Store:** Contains information about the store, including `name` and `address`, and manages items in `Stocks`.
* **Customer and Cashier:** These entities interact within the system, with `Works-on` indicating the cashier works with the register.

In summary:

* **Entities** like `Product`, `CashPayment`, `Register`, and `Store` are defined.
* **Associations** like `Contains`, `Used-by`, and `Records` show relationships.
* **Attributes** like `itemID`, `description`, and `amountTendered` describe individual properties of the entities.



**IV. Felelősségek hozzárendelése**:

This section discusses the assignment of responsibilities in object-oriented design. It focuses on determining which class or object should handle specific tasks or operations. The goal is to ensure that the design follows the principles of cohesion (grouping related functions) and low coupling (minimizing dependencies between classes).

* **Responsibility assignment** involves considering which class is most suited to handle a specific responsibility based on its role in the system.
* This process helps ensure that the design is logical, maintainable, and clear, with classes doing what they are best suited for.

In summary:

* **Assigning responsibilities** makes the design more structured and maintainable.


Slide 49 introduces GRASP (General Responsibility Assignment Software Patterns), which are design patterns for assigning responsibilities to classes in object-oriented design. [cite: 57]

The purpose of GRASP is to provide guidance for understanding objects, the reasoning behind responsibility assignments, and principles for making those assignments. [cite: 57]


Slide 50 describes the types of responsibilities that can be assigned to objects and how these responsibilities relate to methods:

* **Types of Responsibilities**:
    * **Knowledge-based**:
        * Knowing its own private attributes.
        * Knowing related objects.
        * Providing information that can be calculated or derived from its own knowledge.
    * **Action-based**:
        * Performing a task itself (e.g., creating another object or performing a calculation).
        * Initiating an action in another object.
        * Controlling or coordinating actions of other objects. [cite: 58]

* **Responsibilities and Methods**:
    * Responsibilities are implemented through methods that are accessible from the outside world. [cite: 59]



The key takeaway from this slide is:

* Responsibilities assigned to objects are implemented using methods that are accessible to the outside world. [cite: 51]

In simpler terms, when an object is given a responsibility, it fulfills that responsibility through a method that other objects can call and use.


This slide is about how we represent the assignments of responsibilities in object-oriented design[cite: 60].

* **What we use to represent them:**
    * Class diagrams [cite: 60]
    * Collaboration diagrams [cite: 60]
* **What we represent:**
    * Possible implementations [cite: 60]
    * The specific implementations chosen as a result of design decisions [cite: 60]




    This slide introduces the GRASP patterns, which are general principles for assigning responsibilities to classes: [cite: 61]

The GRASP patterns covered are: [cite: 61]

1.  Expert
   
2.  Creator
   
3.  High Cohesion
   
4.  Low Coupling
   
5.  Controller


This slide explains the "Expert" GRASP pattern:

* **Guideline (Irányelv):** Assign a responsibility to the class that has the most information needed to fulfill it. [cite: 62]
   
* **Problem it solves:** In an application, there can be many responsibilities to assign to classes. [cite: 62, 63]
   
* **Benefits of doing it well:**
    * Easy to understand
    * Easy to maintain
    * Easy to extend
    * Easy to reuse
   
* **Significance:** This pattern is important because it greatly impacts the overall design. [cite: 62, 63]

This slide provides guidance on where to find the class to which a responsibility should be assigned, according to the Expert pattern:

* **Where to find this class?**
    * Primarily in the domain model[cite: 64].
    * Secondarily in the design model[cite: 64].

In essence, you should first look at your domain model to identify the class that has the necessary information. If it's not clear, then you might look at the design model.



This slide provides an example of applying the Expert GRASP pattern to determine which class should be responsible for calculating the total of a sale[cite: 65].

* **The responsibility:** Determining the total of a sale.
   
* **Applying the Expert pattern:**
    * The `Sale` class has the most relevant information about the sale itself[cite: 65].
    * However, to calculate the total, `Sale` needs to know the subtotal of each item in the sale[cite: 66].
    * Therefore, calculating the subtotal is the responsibility of `SalesLineItem` since it has the quantity information[cite: 67].
    * To calculate the subtotal, `SalesLineItem` needs the price of the item, and following the Expert pattern, `ProductSpecification` is responsible for knowing the item's price[cite: 67, 68].





This slide visually represents the class diagram related to the "Expert" pattern example discussed on the previous slide[cite: 65, 66, 67, 68, 69].

The diagram shows the relationships between the following classes:

* **Sale:** Represents a sale transaction and has attributes like `time`.
   
* **SalesLineItem:** Represents a line item within a sale and has an attribute `quantity`. It has a "1..\*" relationship with Sale, indicating that a Sale contains one or more SalesLineItems.
   
* **ProductDescription:** Describes a product and has attributes like `description`, `price`, and `itemID`. It has a "\*" relationship with SalesLineItem, meaning a product description can be associated with many sales line items. The "1" near ProductDescription and SalesLineItem suggests that each SalesLineItem is related to one ProductDescription.


This slide continues the "Expert" pattern example, focusing on the `Sale` class and its responsibility of calculating the total. [cite: 65, 66, 67, 68, 69, 70]

* A new method `getTotal()` is added to the `Sale` class. [cite: 70]
   
* The notation `: Sale t = getTotal` indicates that the `getTotal` method is being called on a `Sale` object and the result is being assigned to a variable `t` of type `Sale`. [cite: 70]

In essence, this slide shows the first step in implementing the Expert pattern by adding the `getTotal()` method to the `Sale` class, as `Sale` is the expert on the overall sale information. [cite: 70]



This slide further develops the "Expert" pattern example, detailing how the `Sale` class uses the `SalesLineItem` class to calculate the total.

* The `Sale` class's `getTotal()` method calls the `getSubtotal()` method of each `SalesLineItem`.
   
* `SalesLineItem` is given the responsibility to calculate its own subtotal because it is the "expert" on quantity.
   
* The notation `1 *: st = getSubtotal lineItems[ i ] : SalesLineItem` suggests a loop: for each `SalesLineItem` (`lineItems[ i ]`) in the `Sale`, the `getSubtotal()` method is called, and the result is assigned to `st`.



This slide completes the "Expert" pattern example by showing how `ProductDescription` contributes to the total calculation.

* The `Sale` class calls `getTotal()`.
   
* `getTotal()` in `Sale` calls `getSubtotal()` in `SalesLineItem`.
   
* Now, `getSubtotal()` in `SalesLineItem` needs the price, so it calls `getPrice()` in `ProductDescription`. `ProductDescription` is the "expert" on product price.
   
* The notation `1.1: p := getPrice()` shows that `getSubtotal()` calls `getPrice()`, assigns the returned price to `p`.





This slide notes that the Expert pattern alone is often not enough for assigning responsibilities. [cite: 73] Other principles, such as:

* **Low Coupling**
   
* **High Cohesion**

must also be considered to create a well-designed system. [cite: 73]







This slide explains the "Creator" GRASP pattern, which guides the assignment of object creation responsibilities[cite: 75].

* **Guideline:** Assign the responsibility of creating objects of class A to class B if one or more of the following conditions are true:
    * B "contains" or aggregates A objects.
    * B records instances of A objects.
    * B closely uses A objects.
    * B has the information needed to initialize A objects.
    * B represents a whole/part relationship with A objects.
* If multiple classes meet these criteria, prioritize the class that "contains" or aggregates A, or that represents the whole in a whole/part relationship[cite: 75].





**2. Creator: Example**:

* The responsibility of creating a `SalesLineItem` object falls to the `Sale` class, as it contains multiple `SalesLineItem` objects.

In summary:

* **Creator**: The `Sale` is responsible for creating `SalesLineItem` objects, as they are part of the `Sale`.




 


**2. Creator: Example**:

* The `Register` class calls the `makeLineItem(quantity)` method to create a `SalesLineItem`. Similarly, the `Sale` class uses the `create(quantity)` method to generate the `SalesLineItem`.

In summary:

* **Creator**: Both `Register` and `Sale` are responsible for creating `SalesLineItem` objects, using their respective methods.




**2. Creator: Resolving Contradictions**:

* For practical reuse, we can create a class to handle similar objects.
* This can be achieved using the **object factory** pattern, which centralizes the creation of objects.

In summary:

* **Object Factory**: A class can be used to manage the creation of similar objects, promoting reuse.





**3. Gyenge láncolás (Low coupling)**:

* **Guideline**: Responsibilities should be assigned by minimizing dependencies between classes.
* **Problem it solves**: It ensures that the relationships between classes are minimized, increasing reusability and minimizing the impact of changes.

In summary:

* **Low Coupling**: Minimize dependencies between classes to enhance reusability and reduce the effects of changes.



**3. Low Coupling: Example**:

* **Responsibility of creating `Payment`**:

  * If the `Register` class creates the `Payment`, it sends messages to two other classes.
  * If the `Sale` class creates the `Payment`, each class sends a message to only one other class.
  * The second option results in fewer dependencies (a better implementation).

In summary:

* **Low Coupling**: Creating `Payment` in the `Sale` class minimizes dependencies, leading to a more favorable implementation.




**3. Low Coupling: Example**:

* **Bad Example**: If `makePayment()` is called directly from the `Register` class, it creates more dependencies between classes.

* **Better Example**: If `Sale` class calls `makePayment()`, which then calls `create()` to create the `Payment`, this results in fewer dependencies.

In summary:

* **Low Coupling**: Having `Sale` manage the creation of `Payment` minimizes dependencies, leading to a cleaner design.


**Láncolás Programozási Nyelvekben**:

* **X and Y are in a chain** if:

  1. X has an attribute of type Y or refers to Y type.
  2. X uses some service or method from a Y type object.
  3. X contains a method that requires a parameter of type Y or referencing Y.
  4. X is a subclass of Y, either directly or indirectly.
  5. Y is an interface implemented by X.

In summary:

* **Chain in Programming**: X and Y are linked through attributes, methods, inheritance, or interfaces.



**4. Magas kohézió (High Cohesion)**:

* **Guideline**: Responsibilities should be defined in a way that maximizes cohesion within a class.

* **Key Question**: How do we keep complexity manageable?

* **Low Cohesion** occurs when:

  1. A class performs tasks that do not necessarily belong to it.
  2. A class takes on too many responsibilities.

In summary:

* **High Cohesion**: A class should focus on a specific responsibility, keeping tasks related to its core function, thus reducing complexity.



**Kohézió szintjei**:

1. **Very Low Cohesion**: A class performs tasks related to many different roles.
2. **Low Cohesion**: A class is responsible for many tasks within a single role.
3. **Medium Cohesion**: A class performs a few tasks across a few roles.
4. **High Cohesion**: A class takes on a single role and only a few tasks.

In summary:

* **High Cohesion**: A class should focus on a single role with a few related tasks to ensure simplicity and clarity.



**4. High Cohesion: Example**:

* **Register**: Responsible for tasks related to managing transactions and processing payments.
* **Sale**: Focuses on managing the sale process, including tracking items and calculating totals.

In summary:

* **High Cohesion**: Each class (`Register` and `Sale`) focuses on a specific, well-defined responsibility, making them easier to maintain and understand.



**4. High Cohesion: Example**:

* **Bad Example**: If the `Register` class directly handles `makePayment()` and creates the `Payment`, it mixes responsibilities between processing payments and handling the sale process.

In summary:

* **Low Cohesion**: The `Register` class is doing too much, leading to a less cohesive design. The responsibilities should be more clearly separated for better cohesion.



**4. High Cohesion: Example**:

* **Better Example**: The `Sale` class is responsible for creating the `Payment` and calling `makePayment()`, while the `Register` class focuses on its specific role without directly handling payment creation.

In summary:

* **High Cohesion**: By assigning specific responsibilities to each class, the design is clearer and more maintainable.







**5. Controller**:

* **Guideline**: The responsibility for handling system messages is assigned to specific classes:

  * **General Controller**: Manages the entire message flow for the system, subsystem, or device.
  * **Use Case Controller**: Handles messages related to specific scenarios outlined in use cases.

* **Key Question**: Who is responsible for handling incoming system messages?

* **System messages** are not simple events (e.g., mouse clicks) but are mapped messages that can be interpreted within the domain model (the modeled reality).

In summary:

* **Controller**: A class is responsible for handling system messages, which are interpreted based on the domain model, ensuring proper flow of information.






**System Operations and Controller Allocation**:

* **System operations** are discovered during system behavior analysis and include actions like `endSale()`, `enterItem()`, `makeNewSale()`, `makePayment()`, `makeNewReturn()`, etc.

* **Facade Controller**: In the first design, all system operations are handled by one facade controller. This simplifies the management by centralizing control but may increase complexity as the system grows.

* **Use Case Controllers**: In the second design, system operations are allocated across several use case controllers. This approach organizes responsibilities more clearly and reduces the burden on a single controller, promoting better modularity.

In summary:

* **Facade Controller**: Centralizes operations, but may lead to high complexity.
* **Use Case Controllers**: Distributes operations across multiple controllers, improving modularity and clarity.




**System Operations and Controller Allocation**:

* **System operations** are identified during system behavior analysis, such as `endSale()`, `enterItem()`, `makeNewSale()`, `makePayment()`, `makeNewReturn()`, etc.

* **Facade Controller**: In this approach, a single controller manages all operations. This centralizes control but can lead to complexity as the system grows.

* **Use Case Controllers**: Here, operations are distributed among several controllers, which improves clarity and modularity by dividing responsibilities.

In summary:

* **Facade Controller**: Centralizes operations, potentially increasing complexity.
* **Use Case Controllers**: Distribute operations, enhancing modularity and organization.






**5. Controller (Example)**:

* When the cashier presses a button, the `actionPerformed(actionEvent)` method in the `UI Layer` (e.g., `SaleJFrame`) triggers the system operation message (`enterItem(itemID, qty)`).
* The class responsible for receiving this system event is typically a **controller** or **coordinator**.

The controller doesn't usually perform the actual work; instead, it delegates tasks to other objects in the **domain layer**. It acts as a "facade" between the interface layer and the domain layer.

In summary:

* **Controller**: Receives system event messages and delegates work to other objects, serving as a facade to manage interactions between the UI and the domain logic.


**Bad Example: Without a Controller**:

* When the cashier presses a button, the `SaleJFrame` (UI Layer) directly sends a message to the domain layer (`makeLineItem(itemID, qty)`), which is undesirable.

This design embeds business logic in the presentation layer, which is problematic because the interface layer (UI) should not be responsible for deciding how domain processes are handled.

In summary:

* **Bad Design**: The UI layer (`SaleJFrame`) should not directly communicate with the domain layer, as this mixes presentation and business logic.


**Good Example: Through a Controller**:

* When the cashier presses a button, the `SaleJFrame` (UI Layer) sends a system operation message to the **controller**.
* The controller then communicates with the domain layer (`Register`), which handles the specific business logic (`makeLineItem(itemID, qty)`).

In summary:

* **Good Design**: The controller acts as an intermediary, separating the UI layer from the domain logic, ensuring a clean architecture and better organization.




**Overloaded Controllers (Incorrect Implementation)**:

* Having a single controller that receives all system messages, including a wide variety of message types, leads to overloading.
* The controller handles not only message processing but also many other tasks, instead of delegating responsibilities to other objects.
* The controller stores numerous attributes or information, instead of relying on other objects to manage these details.

In summary:

* **Incorrect Implementation**: An overloaded controller takes on too many responsibilities, leading to a less maintainable and less flexible design.






**Summary**:

* **Domain Model**:

  1. Define the conceptual classes.
  2. Add relationships (associations) between classes.
  3. Add attributes to the classes.
* **Design Model**:
  4\. Assign responsibilities:

  * Define methods for the classes.

In summary:

* **Domain Model**: Focuses on identifying classes, their relationships, and attributes.
* **Design Model**: Involves assigning responsibilities and defining methods for the classes.







**Key Takeaways from the Lecture**:

1. **Domain Modeling**:

   * Identify the **conceptual classes** that represent the real-world entities.
   * Define **associations** (relationships) between these classes to model how they interact.
   * Add **attributes** to the classes to specify their properties.

2. **Design Modeling**:

   * After domain modeling, focus on **assigning responsibilities** to classes, ensuring that each class has clear tasks.
   * Define **methods** that fulfill the class's responsibilities, maintaining clarity and separation of concerns.

3. **Good Design Practices**:

   * Aim for **high cohesion** by making sure each class has a clear, specific responsibility.
   * Ensure **low coupling** between classes, meaning minimal dependencies.
   * Use **controllers** to handle system events and delegate responsibilities to other objects, avoiding overloading a single controller.
   * Manage **complexity** by using appropriate patterns like the **object factory** or **use case controllers**.

4. **System Operation Flow**:

   * Design controllers to act as intermediaries between the UI layer and the domain layer, allowing for a clean separation of concerns and maintainable code.

In essence, the lecture focuses on structuring systems in a way that ensures clarity, flexibility, and maintainability by properly defining classes, their responsibilities, and their interactions.

-----


This lecture provided essential insights into object-oriented analysis and design, highlighting two main phases: Domain Modeling and Design Modeling. The key concepts explored in the lecture emphasize the importance of clarity, maintainability, and proper organization in system design.

**Domain Modeling**

Domain modeling is crucial as the initial step in the design process. It serves as the bridge between understanding real-world concepts and their representation within a software system.

1. **Conceptual Class Identification**:

   * The process begins by identifying conceptual classes that mirror real-world entities or concepts within the system's scope. For example, in a retail context, conceptual classes might include `Product`, `Sale`, `Store`, and `Cashier`. This step lays a foundational structure for the domain model, clearly representing the key participants involved.

2. **Defining Associations**:

   * After establishing the conceptual classes, associations illustrate how these classes relate or interact. Associations define relationships such as containment (`Store` contains `Product`), usage (`Cashier` uses `Register`), or transactional relationships (`Sale` records transactions involving multiple `Products`). Properly defined associations help clarify the system's logical flow and interactions.

3. **Specifying Attributes**:

   * Attributes provide details for the classes, describing their specific properties. For instance, a `Product` might have attributes like `itemID`, `description`, and `price`, which describe individual products precisely. Accurately defining attributes ensures that each class's purpose and characteristics are clear and well-structured.

**Design Modeling**

Once the domain model is established, the design modeling phase defines how the software will fulfill the conceptual requirements. This phase focuses heavily on assigning responsibilities and defining interactions within the system.

4. **Assigning Responsibilities**:

   * Responsibility assignment involves determining which classes will perform specific tasks. This phase ensures each class has clear duties, contributing to a design characterized by high cohesion and low coupling.

   * **High Cohesion**: High cohesion implies that each class should have a focused, singular responsibility or role, such as a `Sale` class handling the processing of transactions or a `Register` class managing customer interactions and initiating transactions. Classes with high cohesion are easier to understand, maintain, and modify.

   * **Low Coupling**: Low coupling ensures minimal dependency between classes, reducing the impact of changes within the system. For instance, instead of having a single class managing various tasks and directly interacting with numerous other classes, responsibilities should be distributed logically, minimizing direct connections. This approach simplifies system maintenance and enhances reusability.

5. **Method Definition**:

   * Once responsibilities are allocated, defining methods that implement these responsibilities is essential. For example, the `Sale` class might include methods such as `makeLineItem()` to handle line items within a sale, clearly reflecting its responsibility.

**Controller Principle**

Controllers are essential for handling system events and delegating tasks, especially within layered architectures.

* **Facade Controllers**: A facade controller simplifies interactions by acting as a single entry point to the domain logic. This centralization, while initially simplifying management, can lead to increased complexity as the system grows.

* **Use Case Controllers**: Alternatively, using multiple controllers, each focused on specific use cases, significantly improves modularity and clarity. This method distributes responsibilities more evenly, avoids overloading a single component, and results in better-structured and maintainable systems.

**Controller Implementation Examples**:

* **Poor Controller Implementation**:

  * An incorrect controller implementation involves embedding business logic directly in the user interface layer, such as a UI element (`SaleJFrame`) managing domain processes directly. This design mixes concerns, leading to complexity and difficulties in system maintenance.

* **Proper Controller Implementation**:

  * In contrast, an effective controller serves as an intermediary, separating the interface layer (UI) from the domain logic. When a user action (e.g., pressing a button) occurs, the UI layer sends a system message to the controller, which then delegates to the appropriate domain object (e.g., `Sale` or `Register`). This clear separation simplifies maintenance, testing, and future modifications.

**Avoiding Controller Overload**:

An essential aspect of controller design is avoiding overload, characterized by controllers taking on too many tasks or storing extensive information. Properly implemented controllers should delegate tasks to other objects and avoid extensive data storage, thus maintaining their clarity and focused responsibility.

**Patterns and Practical Considerations**:

* **Object Factory Pattern**:

  * The lecture also emphasized patterns like the object factory, particularly useful in resolving practical contradictions in responsibility assignment. The factory pattern centralizes object creation, promoting reuse and consistency across the system.

* **Attribute vs. Class Consideration**:

  * Deciding whether a feature should be an attribute or its own class was another crucial discussion point. For example, rather than using a simple numeric attribute for monetary values, using a specialized `Money` class can provide additional context and precision, demonstrating more thoughtful and clearer design.

**Conclusion**:

This lecture emphasized structured, thoughtful design practices to achieve clear, maintainable, and adaptable software systems. It reinforced the importance of domain modeling for clarity, design modeling for effective implementation, and proper controller use for organized interaction management. Adhering to these principles fosters software that is easier to develop, extend, and maintain.
 