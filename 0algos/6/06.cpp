6.1.1. Hozzon létre struktúrát a bináris fa csomópontja számára! Használjon szülő mutatót és egy egész típusú adattagot! Hozzon létre 8 struktúra változót és állítsa be úgy a mutatókat, hogy kialakítsa az alábbi adatszerkezetet! Írjon menüt, amelynek a segítségével a fán mozoghat balra, jobbra, visszafele és kiléphet! Írja ki mindig az aktuális elem egész adattagját és hogy vannak-e gyerekei! Ha olyan irányba történne a mozgás, ahol nincs csomópont, akkor nem változik az aktuális mutató. 2 9 7 8 Ábra: Megvalósítandó szerkezet
6.1.1.
#include <stdio.h> struct nodeType { int data;
nodeType *left, *right, *parent;
};
typedef struct nodeType node;
void printNode(node* act) { printf("Act node: data: %d. ", act->data);
printf("You can go left: %d, ", act->left?1:0 );
printf("right: %d, ", act->right?1:0 );
printf("parent: %d\n", act->parent?1:0 );
} int select() { int result;
printf("\nLeft - 1\n");
printf("Right - 2\n");
printf("Back - 3\n");
printf("Quick - 4\n");
printf("Your choice: ");
scanf("%d", &result);
return result;
} int main() { node a={2, NULL, NULL, NULL}, b={11, NULL, NULL, NULL}, c={23, NULL, NULL, NULL}, d={13, NULL, NULL, NULL}, e={9, NULL, NULL, NULL}, f={7, NULL, NULL, NULL}, g={66, NULL, NULL, NULL}, h={8, NULL, NULL, NULL}, *root=&a, *act=root;
int choice;
a.left = &b;
a.right = &c;
b.left = &d;
b.right = &e;
b.parent = &a;
d.right = &g;
d.parent = &b;
g.parent = &d;
c.right = &f;
c.parent = &a;
f.left = &h;
h.parent = &f;
do { printNode(act);
choice = select();
switch (choice) { case 1: if (act->left) act = act->left;
break;
case 2: if (act->right) act = act->right;
break;
case 3: if (act->parent) act = act->parent;
break;
} } } while (choice != 4);
return 0;

6.1.2. Az egész adattag mellet még legyen sztring és lebegőpontos szám típusú adattag is! A menüben legyen lehetőség az egyes adattagok megváltoztatására! 6.2. Fabejárások
6.1.2.
#include <stdio.h> struct nodeType { int data;
float data2;
char string[50];
struct nodeType *left, *right, *parent;
};
typedef struct nodeType node;
void printNode(node* act) { printf("Act node - data(int): %d, data(float): %f, data(string): %s\n", act->data,act->data2,act->string);
printf("You can go left: %d, ", act->left?1:0 );
printf("right: %d, ", act->right?1:0 );
printf("parent: %d\n", act->parent?1:0 );
} void editNode(node* act) { printf("editing node\n");
printf("data (int): ");
scanf("%d",&(act->data));
printf("data (float): ");
scanf("%f",&(act->data2));
printf("data (string): ");
scanf("%s",act->string);
} int select() { int result;
printf("\nLeft - 1\n");
printf("Right - 2\n");
printf("Back - 3\n");
printf("Edit - 4\n");
printf("Quit - 5\n");
printf("Your choice: ");
scanf("%d", &result);
return result;
} int main() { node a={2, 0.2, "", NULL, NULL, NULL}, b={11, 0.11, "", NULL, NULL, NULL}, c={23, 0.23, "", NULL, NULL, NULL}, d={13, 0.13, "", NULL, NULL, NULL}, e={9, 0.9, "", NULL, NULL, NULL}, f={7, 0.7, "", NULL, NULL, NULL}, g={66, 0.66, "", NULL, NULL, NULL}, h={8, 0.8, "", NULL, NULL, NULL}, *root=&a, *act=root;
int choice;
a.left = &b;
a.right = &c;
b.left = &d;
b.right = &e;
b.parent = &a;
d.right = &g;
d.parent = &b;
g.parent = &d;
c.right = &f;
c.parent = &a;
f.left = &h;
h.parent = &f;
} do { printNode(act);
choice = select();
switch (choice) { case 1: if (act->left) act = act->left;
break;
case 2: if (act->right) act = act->right;
break;
case 3: if (act->parent) act = act->parent;
break;
case 4: editNode(act);
break;
} } while (choice != 5);
return 0;

6.2.1. Hozzon létre struktúrát a bináris fa csomópontja számára! Ne használjon szülő mutatót, de legyen egy egész típusú adattag! Hozzon létre 8 struktúra változót és állítsa be úgy a mutatókat, hogy kialakítsa az alábbi adatszerkezetet! Valósítsa meg a preodrer, inorder és postorder fabejárásokat! 2 7 4 1 3 9 5 8 Ábra: Megvalósítandó szerkezet 6.3. Bináris keresőfa
6.2.1.
#include <stdio.h> struct nodeType { int data;
nodeType *left, *right;
};
typedef struct nodeType node;
void preOrder(node* act) { if (!act) return;
printf("%d ", act->data);
preOrder(act->left);
preOrder(act->right);
} void inOrder(node* act) { if (!act) return;
inOrder(act->left);
printf("%d ", act->data);
inOrder(act->right);
} void postOrder(node* act) { } if (!act) return;
postOrder(act->left);
postOrder(act->right);
printf("%d ", act->data);
int main() { node a={1, NULL, NULL}, b={2, NULL, NULL}, c={3, NULL, NULL}, d={4, NULL, NULL}, e={5, NULL, NULL}, f={7, NULL, NULL}, g={8, NULL, NULL}, h={9, NULL, NULL}, *root=&b;
b.left = &f;
b.right = &c;
f.left = &d;
f.right = &h;
d.left = &a;
d.right = &e;
h.right = &g;
printf("\nPre order: ");
preOrder(root);
printf("\nIn order: ");
inOrder(root);
printf("\nPost order: ");
postOrder(root);
} return 0;

6.3.1.
#include <stdio.h>
#include <malloc.h>
#include <limits.h>
#include <string.h> struct nodeType { int price;
char manufacturer[50];
unsigned int infra : 1;
float range;
struct nodeType *less, *bigger;
};
typedef struct nodeType node;
void printNode(node* act) { printf("\n(price: %d, ", act->price);
printf("manufacturer: %s, ", act->manufacturer);
printf("infra: %d, ", act->infra);
printf("range: %3.1f) ", act->range);
} void printTree(node* act) { if (!act) return;
printTree(act->less);
printNode(act);
printTree(act->bigger);
} void freeTree(node* act) { if (!act) return;
freeTree(act->less);
freeTree(act->bigger);
free(act);
} void insertNode(node* sentinel, node* origNode) { node *act = sentinel, *newNode;
newNode = (node*)malloc(sizeof(node));
*newNode = *origNode;
newNode->less = NULL;
newNode->bigger = NULL;
while (1) { if (newNode->price <= act->price) { then equal elements must go to the left (sentinel can have only one child) if (act->less == NULL) { act->less = newNode;
return;
} else act = act->less;
} else { if (act->bigger == NULL) { act->bigger = newNode;
return;
} else act = act->bigger;
} } } int main() { node sentinel={LONG_MAX, "", 0, 0, NULL, NULL}, myNode={25, "ibm", 0, 5.2, NULL, NULL};
insertNode(&sentinel, &myNode);
printf("\nOrdered node list: ");
myNode.price = 63;
strcpy(myNode.manufacturer, "ms");
myNode.infra=1;
myNode.range=2.1;
insertNode(&sentinel, &myNode);
myNode.price = 11;
strcpy(myNode.manufacturer, "genius");
myNode.infra=1;
myNode.range=4.5;
insertNode(&sentinel, &myNode);
myNode.price = 22;
strcpy(myNode.manufacturer, "takamaka");
myNode.infra=0;
myNode.range=0.9;
insertNode(&sentinel, &myNode);
printTree(sentinel.less);
freeTree(sentinel.less);
return 0;
} 
6.3.1. Tároljon adatokat egerekről bináris keresőfában ár szerint rendezve! A tárolandó adatok: ár - int, gyártó - statikus sztring, infra - bitmező, madzag hossz vagy infra hatótáv - lebegőpontos. Ne használjon szülő mutatót! Tárolja a fa gyökerét őrszemmel! Az őrszem kulcsmezőjének maximálisnak kell lennie! Valósítsa meg a következő függvényeket: csomópont megjelenítése, fa megjelenítése, fa felszabadítása, csomópont beszúrása! Teszteljük a programot! 
6.3.2.
#include <stdio.h>
#include <malloc.h>
#include <limits.h>
#include <string.h> typedef struct nodeType { int price;
char manufacturer[50];
unsigned int infra : 1;
float range;
struct nodeType *less, *bigger, *parent;
} node;
void printNode(node* act) { printf("(price: %d, ", act->price);
printf("manufacturer: %s, ", act->manufacturer);
printf("infra: %d, ", act->infra);
printf("range: %3.1f)\n", act->range);
} void printTree(node* act) { if (!act) return;
printTree(act->less);
printNode(act);
printTree(act->bigger);
} void freeTree(node* act) { if (!act) return;
freeTree(act->less);
freeTree(act->bigger);
free(act);
} void insertNode(node* root, node* orig) { node* act=root;
node* step=root;
while (step!=NULL) { if (act->price >= orig->price) { step=(act->less);
} else { step=(act->bigger);
} if (step!=NULL) { act=step;
} } if (act->price>=orig->price) { act->less=orig;
} else { act->bigger=orig;
} orig->parent=act;
} int main() { node first = {25, "ibm", 0, 5.2, NULL, NULL};
node myNode1 = {0,"",0,0.0,NULL,NULL};
node myNode2 = {0,"",0,0.0,NULL,NULL};
node myNode3 = {0,"",0,0.0,NULL,NULL};
node *root = &first;
myNode1.price = 63;
strcpy(myNode1.manufacturer, "ms");
myNode1.infra=1;
myNode1.range=2.1;
} insertNode(root, &myNode1);
myNode2.price = 11;
strcpy(myNode2.manufacturer, "genius");
myNode2.infra=1;
myNode2.range=4.5;
insertNode(root, &myNode2);
myNode3.price = 22;
strcpy(myNode3.manufacturer, "takamaka");
myNode3.infra=0;
myNode3.range=0.9;
insertNode(root, &myNode3);
printf("Ordered node list:\n");
printTree(root);
return 0;

6.3.2. Módosítsa úgy a programot, hogy az őrszemben a legkisebb kulcs értéket tároljuk! A billentyűzetről kérje be az új csomópont tulajdonságait! Az őrszem helyett mutatóval reprezentáljuk a fát! Használjon szülő mutatót is! 6.4. Családfa
6.4.1. Az input fájl egy családfáról tartalmaz információkat. Minden emberhez egy darab őst rendel. Írjon programot, amely beolvassa a családfát a fájlból, a billentyűzetről pedig bekér egy nevet! Ezután a program írja ki a képernyőre a megadott személy gyerekeinek a nevét és életkorát (az aktuális év 1436), vagy az évet, amikor meghaltak! Ha a megadott embernek nincs gyereke, vagy nem létezik, akkor a program ennek megfelelő üzenetet írjon ki a képernyőre! Használjon dinamikus tömböket! Az input formátuma: NameString Number1 Number2 Number3 ahol NameString: A személy neve, egy szó szóköz nélkül. Number1: A személy születési éve Number2: A személy halálának éve (ha ez a szám -1, a személy él) Number3: A személy gyerekeinek száma Az input faszerkezet szerűen tárolja a személyeket. Ha valakinek két gyereke van, akkor először az első gyermek sorát írjuk le, aztán felsoroljuk az első gyermek leszármazottját és csak utána jön a második gyerekhez tartozó sor. A bemeneti fájl tabulálása nem kötelező. Példa: Fosco 1264 1360 3 Dora 1302 1406 0 Drogo 1308 1380 1 Frodo 1368 -1 0 Dudo 1311 1409 1 Daisy 1350 -1 0 Fosco 1264-ben született, és 1360-ban halt meg. 3 gyermeke volt, Dora, Drogo és Dudo. Drogo fia volt Frodo, aki 1368-ban született, és még életben van. Dora 104 évet élt. Kimenet: (A „Fosco” nevet gépeltük be) Name: Fosco Children of Fosco: ********************************* Dora, lived for 104 years Drogo, lived for 72 years Dudo, lived for 98 years 6.5. Matematikai kifejezések kiértékelése
6.4.1. struct TPerson { char Name[NAMELENGTH];
int Born, Died;
int ChildrenNum;
struct TPerson * Children;
};
void ReadPerson(FILE * fd, struct TPerson * Head) { int i;
fscanf(fd, "%s", Head->Name);
fscanf(fd, "%d %d %d", &Head->Born, &Head->Died, &Head>ChildrenNum);
Head->Children = (struct TPerson*)malloc( sizeof(struct TPerson) * Head->ChildrenNum);
for (i = 0;
i < Head->ChildrenNum;
i++) { ReadPerson(fd, &Head->Children[i]);
} } int PrintChildren(struct TPerson * Head, char * name, int year) { int i;
int exist = FALSE;
if ( strcmp(Head->Name, name) == 0 ) { exist = TRUE;
if (Head->ChildrenNum > 0) { for (i = 0;
i < Head->ChildrenNum;
i++) { if (Head->Children[i].Died != -1) { printf("%s, lived for ", Head->Children[i].Name);
printf("%d years\n", Head->Children[i].Died - Head>Children[i].Born);
} else { printf("%s, ", Head->Children[i].Name);
printf("%d years old\n", year - Head->Children[i].Born);
} } } else printf("%s hasn't got children!\n", name);
} else { for (i = 0;
i < Head->ChildrenNum;
i++) { if (!exist) exist = PrintChildren(&Head->Children[i], name, year);
else PrintChildren(&Head->Children[i], name, year);
} } return exist;
} void FreeFamilyTree(struct TPerson * Head) { int i;
for (i = 0;
i < Head->ChildrenNum;
i++) { FreeFamilyTree( &Head->Children[i] );
} free(Head->Children);
Head->Children = NULL;
} int main(int argc, char *argv[]) { struct TPerson Head;
char Name[NAMELENGTH];
FILE * fd = fopen(INPUT_FILE, "r");
if (fd==NULL) { perror("Hiba");
return 0;
} ReadPerson(fd, &Head);
fclose(fd);
printf("Name: ");
scanf("%s", Name);
printf("Children of %s:\n*********************************\n", Name);
if ( !PrintChildren(&Head, Name, ACTUAL_YEAR ) ) printf("There is no person with name %s!\n", Name);
} FreeFamilyTree(&Head);
return 0;

6.5.1.
#include <stdio.h>
#include <stdlib.h>
#include <string.h> #define INPUT_FILE "expr1.txt" #define MAXLENGTH 15 #define ELEMENTNUM(a) (( a ) * 2 - 1) typedef char TElement[MAXLENGTH];
struct TExpression { int operandsnum;
TElement * expr;
};
void PrintExpression(struct TExpression * E) { int i;
for (i = 0;
i < ELEMENTNUM(E->operandsnum);
i++) printf("%s ", E->expr[i]);
} void MulDiv(struct TExpression * E) { int i, j;
int offs;
double a;
for (i = 0;
i < ELEMENTNUM(E->operandsnum);
i++) { offs = 0;
if (strcmp(E->expr[i], "*") == 0) { a = atof(E->expr[i - 1]);
a *= atof(E->expr[i + 1]);
sprintf(E->expr[i - 1], "%g", a);
offs = 1;
} if (strcmp(E->expr[i], "/") == 0) { a = atof(E->expr[i - 1]);
a /= atof(E->expr[i + 1]);
sprintf(E->expr[i - 1], "%g", a);
offs = 1;
} if (offs) { for (j = i;
j < (ELEMENTNUM(E->operandsnum) - 2);
j++) strcpy(E->expr[j], E->expr[j + 2]);
E->operandsnum--;
i--;
} } } void AddSub(struct TExpression * E) { int i, j;
int offs;
double a;
for (i = 0;
i < ELEMENTNUM(E->operandsnum);
i++) { offs = 0;
if (strcmp(E->expr[i], "+") == 0) { a = atof(E->expr[i - 1]);
a += atof(E->expr[i + 1]);
sprintf(E->expr[i - 1], "%g", a);
offs = 1;
} } } if (strcmp(E->expr[i], "-") == 0) { a = atof(E->expr[i - 1]);
a -= atof(E->expr[i + 1]);
sprintf(E->expr[i - 1], "%g", a);
offs = 1;
} if (offs) { for (j = i;
j < (ELEMENTNUM(E->operandsnum) - 2);
j++) strcpy(E->expr[j], E->expr[j + 2]);
E->operandsnum--;
i--;
} double GetValue(struct TExpression * E) { MulDiv(E);
AddSub(E);
return atof(E->expr[0]);
} void ReadExpression(FILE * fd, struct TExpression * E) { int i;
fscanf(fd, "%d", &E->operandsnum);
E->expr = (TElement *)malloc(sizeof(TElement) * ELEMENTNUM(E>operandsnum));
for (i = 0;
i < ELEMENTNUM(E->operandsnum) ;
i++) { fscanf(fd, "%s", *(E->expr + i));
} } void FreeExpression(struct TExpression * E) { free(E->expr);
E->expr = NULL;
E->operandsnum = 0;
} int main(int argc, char * argv[]) { struct TExpression Expr;
FILE * fd = fopen(argc > 1 ? argv[1] : INPUT_FILE, "r");
if (fd == NULL) { perror("Error");
return 1;
} ReadExpression(fd, &Expr);
fclose(fd);
PrintExpression(&Expr);
} printf(" = %g\n", GetValue(&Expr));
FreeExpression(&Expr);
return 0;

6.5.1. Írjon programot, amely kiértékel egy egyszerű matematikai kifejezést! A kifejezések lebegőpontos számokat, illetve négy matematikai operátort tartalmazhatnak: összeadás (+), kivonás (-), szorzás (*), osztás (/). A kifejezés nem tartalmaz zárójeleket. A kifejezést fájlból olvassa be! A program a beolvasott matematikai kifejezést és annak eredményét írja ki a képernyőre! Figyeljen az operátorok kiértékelési sorrendjére! Például 1 + 2 * 3 = 7 és nem 9. Az input fájl formátuma: Első sor: Az operandusok száma. Második sor: A matematikai kifejezés. A számok és operátorok egy-egy szóköz karakterrel vannak elválasztva. Példa bemenet: 6 2 + 3 * 54 - 64 / 10 + 60 Kimenet: 2 + 3 * 54 - 64 / 10 + 60 = 217.6 6.6.Bináris fa feladatok
6.6.1.-6.6.3.
#include <stdio.h>
#include <stdlib.h> struct binary_tree { int number;
struct binary_tree* left;
struct binary_tree* right;
};
void Insert(struct binary_tree*, int);
void List(struct binary_tree*);
int CountNode(struct binary_tree*);
int CountLeaf(struct binary_tree*);
int MaxDepth(struct binary_tree*);
int MaxKey(struct binary_tree*);
int MinDepth(struct binary_tree*);
int SameTree(struct binary_tree*, struct binary_tree*);
int main() { struct binary_tree* head = NULL, *head2 = NULL;
int i;
int tree_1[] = {7, 9, 13, 15, 45, 2, 1, 5, 94};
int tree_2[] = {7, 9, 13, 15, 45, 2, 1, 5, 94};
for (i = 0;
i < sizeof(tree_1)/sizeof(int);
++i) { if (!head) { head = (struct binary_tree*)malloc(sizeof(struct binary_tree));
head->left = NULL;
head->right = NULL;
head->number = tree_1[i];
} else { Insert(head, tree_1[i]);
} } for (i = 0;
i < sizeof(tree_2)/sizeof(int);
++i) { if (!head2) { head2 = (struct binary_tree*)malloc(sizeof(struct binary_tree));
head2->left = NULL;
head2->right = NULL;
head2->number = tree_2[i];
} else { Insert(head2, tree_2[i]);
} } printf("First tree:\n");
List(head);
printf("\n\nSecond tree:\n");
List(head2);
printf("\n\nThere are %d node in the first binary tree\n", CountNode(head));
printf("There are %d leaf in the first binary tree\n", CountLeaf(head));
printf("The max depth in the first tree is %d\n", MaxDepth(head));
printf("The max key in the first tree is: %d\n", MaxKey(head));
printf("The minimum depth in the first tree is: %d\n", MinDepth(head));
if(SameTree(head, head2)) printf("The trees have the same shape\n");
else printf("The trees don't have the same shape\n");
return 0;
} void Insert(struct binary_tree* head, int temp) { if (temp == (head->number)) ;
else if (temp < head->number) { if (head->left) Insert(head->left, temp);
else { head->left = (struct binary_tree*)malloc(sizeof(struct binary_tree));
head->left->number = temp;
head->left->left = NULL;
head->left->right = NULL;
} } else if (temp > head->number) { if (head->right) Insert(head->right, temp);
else { head->right = (struct binary_tree*)malloc(sizeof(struct binary_tree));
head->right->number = temp;
head->right->left = NULL;
head->right->right = NULL;
} } } void List(struct binary_tree* head) { if (head->left) List(head->left);
printf("%d ", head->number);
if (head->right) List(head->right);
} int CountNode(struct binary_tree* head) { if (head == NULL) { return 0;
} else { return(CountNode(head->left) + 1 + CountNode(head->right));
} } int CountLeaf(struct binary_tree* head) { if(head == NULL) return 0;
if((head->left == NULL) && (head->right == NULL)) return 1;
else return (CountLeaf(head->left) + CountLeaf(head->right));
} int MaxDepth(struct binary_tree* head) { int left_depth, right_depth;
if (head == NULL) return 0;
else { left_depth = MaxDepth(head->left);
right_depth = MaxDepth(head->right);
if (left_depth > right_depth) return(left_depth + 1);
else return(right_depth + 1);
} } int MaxKey(struct binary_tree* head) { if (head) while(head->right) head = head->right;
return head->number;
} int MinDepth(struct binary_tree* head) { int left_depth, right_depth;
if (head == NULL) return 0;
else { left_depth = MaxDepth(head->left);
right_depth = MaxDepth(head->right);
if (left_depth < right_depth) return(left_depth + 1);
else return(right_depth + 1);
} } int SameTree(struct binary_tree* a, struct binary_tree* b) { if (a == NULL && b == NULL) return 1;
else if (a != NULL && b != NULL) { return( SameTree(a->left, b->left) && SameTree(a->right, b->right) );
} } else return 0;

6.6.1. Írjon programot, amely egy tömb elemeiből készít bináris keresőfát, ezután határozza meg, hány csúcsa, illetve hány levele van a fának! A bináris keresőfa olyan adatszerkezet, amelyben minden elemnek két mutatója van, egy jobb, illetve egy bal. A fába elsőként belerakott elem a gyökér, ezután minden elemet a következőképp helyezünk el. Kiindulunk a gyökér elemtől. Ha a beszúrni kívánt elem kisebb, mint az aktuális, akkor balra megyünk tovább a fában, ha nagyobb, akkor jobbra. Egészen addig haladunk így a fában, amíg egy üres helyet találunk, ide beszúrjuk az kívánt elemet. 
6.6.2. Írjon függvényeket a következő funkciók megvalósítására;
fa magassága (a gyökérlevél távolságok között a legnagyobb), maximális érték meghatározása, gyökérhez legközelebb eső szint meghatározása, amin már van levele a fának! Levél: olyan csúcs a fában, aminek nincsen se bal, se jobb gyereke. 
6.6.3. Írjon programot, amely eldönti két fáról, hogy azonos alakúak-e! 7. Gráf feladatok 7.1. Tűzoltók
