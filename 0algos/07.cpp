7.1.1. Egy nagyváros közepén található a tűzoltó állomás. Sajnos gyakran megesik, hogy a tűz helyszínére tartó tűzoltó autók nem azon az útvonalon haladnak, amerre a leghamarabb kiérnének, mivel a sofőrök nem képesek a legrövidebb utat meghatározni. Írjon útvonaltervező programot, amely egy mátrixban tárolt úthálózat alapján megtervezi a legrövidebb útvonalat a tűzoltó állomás és a tűz helyszíne között! Ötlet: használjon Dijkstra algoritmust! 7.2. Bolygóközi futárszolgálat A Bolygóközi Kézbesítő Vállalat különböző bolygók között bonyolít le szállításokat. Mivel a távolságok hatalmasak, ezért a közlekedést térkapukon keresztül oldják meg. Az egyes bolygók közelében féregjárat nyílások helyezkednek el, minden járat egy másik bolygó közelében ér véget. A közlekedés eme járatrendszerek belsejében zajlik. A járatok nyílásai a közeli bolygó kormányzatának a tulajdonában állnak, így a járatba való belépésért díjat szednek. A járat használatáért fizetendő összeg függ a belépési pontot birtokló kormányzattól, valamint a cél állomástól (a népszerűbb célállomások felé tartó járműveket jobban megsarcolják). Adott egy csillagtérkép, amelyen feltüntettük, hogy mely bolygók között létezik féregjárat, és az egyes járatokért mekkora díjat kell fizetni. A térkép adjacencia mátrixban van tárolva, ahol -1 jelzi azt, ha két bolygó között nincs közvetlen járat, egyébként pedig az egyes tarifákat tároljuk a mátrix celláiban.
7.1.1.
#include <stdio.h> #define GRAPHSIZE 2048 #define INFINITY GRAPHSIZE*GRAPHSIZE #define MAX(a, b) ((a > b) ? (a) : (b)) int e;
int n;
long dist[GRAPHSIZE][GRAPHSIZE];
long d[GRAPHSIZE];
void printD() { int i;
printf("The shortest path form node 0 to node n\nnode n: for (i = 1;
i <= n;
++i) printf("%10d", i);
printf("\ndistance: ");
for (i = 1;
i <= n;
++i) { printf("%10ld", d[i]);
} printf("\n");
} ");
void dijkstra(int s) { int i, k, mini;
int visited[GRAPHSIZE];
for (i = 1;
i <= n;
++i) { d[i] = INFINITY;
visited[i] = 0;
} d[s] = 0;
} for (k = 1;
k <= n;
++k) { mini = -1;
for (i = 1;
i <= n;
++i) if (!visited[i] && ((mini == -1) || (d[i] < d[mini]))) mini = i;
visited[mini] = 1;
for (i = 1;
i <= n;
++i) if (dist[mini][i]) if (d[mini] + dist[mini][i] < d[i]) d[i] = d[mini] + dist[mini][i];
} int main(int argc, char *argv[]) { int i, j;
int u, v, w;
FILE *fin = fopen("dist.txt", "r");
fscanf(fin, "%d", &e);
fscanf(fin, "%d", &n);
for (i = 0;
i < e;
++i) for (j = 0;
j < e;
++j) dist[i][j] = 0;
n = -1;
for (i = 0;
i < e;
++i) { fscanf(fin, "%d%d%d", &u, &v, &w);
dist[u][v] = w;
n = MAX(u, MAX(v, n));
} fclose(fin);
dijkstra(1);
printD();
return 0;
} 6 5 1 2 3 1 3 2 2 4 6 2 5 3 3 5 7 5 4 2 
7.2.1.-7.2.3.
#include <stdio.h>
#include <stdlib.h> typedef struct Graf { int csomopontok;
double ** matrix;
} Graf;
typedef struct El { int pont1, pont2;
double suly;
} El;
void grafInit(Graf * graf, int meret) { graf->csomopontok = meret;
graf->matrix = NULL;
if (meret > 0) { int sor, oszlop;
graf->matrix = (double**) malloc(sizeof (double*) * graf>csomopontok);
for (sor = 0;
sor < graf->csomopontok;
sor++) { graf->matrix[sor] = (double*) malloc(sizeof (double) * graf>csomopontok);
for (oszlop = 0;
oszlop < graf->csomopontok;
oszlop++) { graf->matrix[sor][oszlop] = -1;
} } } } void grafBetolt(const char * file, Graf * graf) { FILE * fd = fopen(file, "r");
if (fd == NULL) { perror("Hiba");
return;
} int sor, oszlop;
fscanf(fd, "%d", &graf->csomopontok);
graf->matrix = (double**) malloc(sizeof (double*) * graf>csomopontok);
for (sor = 0;
sor < graf->csomopontok;
sor++) { graf->matrix[sor] = (double*) malloc(sizeof (double) * graf>csomopontok);
for (oszlop = 0;
oszlop < graf->csomopontok;
oszlop++) { fscanf(fd, "%lg", &graf->matrix[sor][oszlop]);
} } fclose(fd);
} void grafFelszabadit(Graf * graf) { int sor;
for (sor = 0;
sor < graf->csomopontok;
sor++) { free(graf->matrix[sor]);
} free(graf->matrix);
graf->csomopontok = 0;
graf->matrix = 0;
} double dijkstra(int start, int veg, Graf graf, int * ut) { if (start == veg) { return 0.0;
} double vegtelen = 1.0 / 0.0;
int * kesz = (int*) malloc(sizeof (int) * graf.csomopontok);
int * elozo = (int*) malloc(sizeof (int) * graf.csomopontok);
double * d = (double*) malloc(sizeof (double) * graf.csomopontok);
kesz[start] = 1;
int i;
for (i = 0;
i < graf.csomopontok;
i++) { kesz[i] = 0;
d[i] = vegtelen;
elozo[i] = -1;
if (graf.matrix[start][i] > -1) { d[i] = graf.matrix[start][i];
tavolsagara tudunk mar becslest adni elozo[i] = start;
} } for (i = 0;
i < graf.csomopontok;
i++) { ra minimalis int node = 0;
while (node < graf.csomopontok && kesz[node]) node++;
if (node < graf.csomopontok) { int j;
for (j = 0;
j < graf.csomopontok;
j++) if (d[j] < d[node] && !kesz[j]) node = j;
} kesz[node] = 1;
for (j = 0;
j < graf.csomopontok;
j++) { if (!kesz[j] && graf.matrix[node][j] > 0 && d[j] > d[node] + graf.matrix[node][j]) { d[j] = d[node] + graf.matrix[node][j];
elozo[j] = node;
} } } else { i = graf.csomopontok;
} int utIndex = graf.csomopontok;
if (d[veg] < vegtelen) { int node = veg;
while (node != start) { ut[ --utIndex ] = node;
node = elozo[node];
} ut[ --utIndex ] = node;
} int ut_i;
for (ut_i = utIndex;
ut_i < graf.csomopontok - 1;
ut_i++) printf("%d -- %lg -- ", ut[ut_i], graf.matrix[ut[ut_i]][ut[ut_i + 1]]);
printf("%d\n", ut[ut_i]);
} double res = d[veg];
free(elozo);
free(d);
free(kesz);
return res;
int bejar(Graf graf, int start, int * szinek, int szin) { int i;
int * meglatogatott = (int*) malloc(sizeof (int) * graf.csomopontok);
for (i = 0;
i < graf.csomopontok;
i++) { meglatogatott[i] = 0;
} int * nyitott = (int*) malloc(sizeof (int) * graf.csomopontok);
int nyitottCsomopontok = 0;
nyitott[0] = start;
nyitottCsomopontok++;
int node = start;
int bejart = 0;
while (nyitottCsomopontok > 0) { node = nyitott[ --nyitottCsomopontok ];
if (meglatogatott[node] == 0) { meglatogatott[node] = 1;
bejart++;
if (szinek != NULL) { szinek[node] = szin;
} } for (i = 0;
i < graf.csomopontok;
i++) { if (meglatogatott[i] == 0 && graf.matrix[node][i] > -1) { int j = 0;
while (j < nyitottCsomopontok && nyitott[j] != i) { j++;
} if (j >= nyitottCsomopontok) { nyitott[ nyitottCsomopontok++ ] = i;
} } } } } free(meglatogatott);
free(nyitott);
return bejart;
double kruskal(Graf graf, Graf mft) { int elekSzama = 0;
int i, j;
for (i = 0;
i < graf.csomopontok;
i++) { for (j = i + 1;
j < graf.csomopontok;
j++) { if (graf.matrix[i][j] > -1) { elekSzama++;
} } } printf("%d el van a grafban\n", elekSzama);
El * elek = (El*) malloc(sizeof (El) * elekSzama);
elekSzama = 0;
for (i = 0;
i < graf.csomopontok;
i++) { for (j = i + 1;
j < graf.csomopontok;
j++) { if (graf.matrix[i][j] > -1) { elek[ elekSzama ].pont1 = i;
elek[ elekSzama ].pont2 = j;
elek[ elekSzama ].suly = graf.matrix[i][j];
elekSzama++;
} } } for (i = 0;
i < elekSzama - 1;
i++) { int minIndex = i;
for (j = i + 1;
j < elekSzama;
j++) { if (elek[ j ].suly < elek[ minIndex ].suly) { minIndex = j;
} } } } El temp = elek[ i ];
elek[ i ] = elek[ minIndex ];
elek[ minIndex ] = temp;
int lefedve = 0;
int * szinek = (int*)malloc(sizeof(int) * graf.csomopontok);
for (i = 0;
i < graf.csomopontok;
i++) { szinek[i] = i;
} int elIndex = 0;
double osszSuly = 0.0;
while (elIndex < elekSzama) { El el = elek[ elIndex ];
if (szinek[el.pont1] != szinek[el.pont2]) { mft.matrix[ el.pont1 ][ el.pont2 ] = el.suly;
osszSuly += el.suly;
int szinRef = szinek[el.pont1];
int szin2 = szinek[el.pont2];
for (j = 0;
j < graf.csomopontok;
j++) { if (szinek[j] == szinRef) { szinek[j] = szin2;
} } } elIndex++;
} free(elek);
free(szinek);
return osszSuly;
int main() { Graf graf;
grafInit(&graf, 0);
grafBetolt("terkep.txt", &graf);
if (graf.csomopontok == 0) { return EXIT_FAILURE;
} int * ut = (int*) malloc(graf.csomopontok * sizeof (int));
int start, veg;
printf("Kezdopont: ");
scanf("%d", &start);
printf("Cel: ");
scanf("%d", &veg);
double hossz = dijkstra(start, veg, graf, ut);
printf("A legrovidebb ut hossza: %lg\n", hossz);
int elerheto = bejar(graf, start, NULL, 0);
printf("A %d. pontbol %d pont erheto el\n", start, elerheto);
int * szinek = (int*) malloc(sizeof (int) * graf.csomopontok);
int i;
for (i = 0;
i < graf.csomopontok;
i++) { szinek[i] = 0;
} int pont;
int komponensek = 0;
do { pont = 0;
while (pont < graf.csomopontok && szinek[pont] > 0) { pont++;
} if (pont < graf.csomopontok) { komponensek++;
elerheto = bejar(graf, pont, szinek, komponensek);
printf("A %d. komponensben %d csomopont van\n", komponensek, elerheto);
} } while (pont < graf.csomopontok);
} grafFelszabadit(&graf);
free(ut);
free(szinek);
return EXIT_SUCCESS;
6 -1 16 13 -1 -1 -1 -1 -1 10 12 -1 -1 -1 4 -1 -1 14 -1 -1 -1 9 -1 -1 20 -1 -1 -1 7 -1 4 -1 -1 -1 -1 -1 -1 
7.2.1. Készítsen programot, amely beolvassa a csillagtérképet egy fájlból, majd határozza meg, hogy legolcsóbban mekkora összegért lehet szállítani a felhasználó által megadott két bolygó között! Adja meg a legolcsóbb úthoz tartozó útvonalat is! Ötlet: használjon Dijkstra algoritmust! 
7.2.2. Kérjen be egy bolygó sorszámát, majd határozza meg, hogy a féregjáratokon keresztül hány bolygóhoz lehet onnan eljutni! 
7.2.3. Határozza meg, hogy hány darab komponens található a csillagtérképen! Az egy komponensben lévő bolygók között létezik útvonal, két külön komponensben lévő bolygó között nem létezik. Adja minden komponensben, az ott található bolygók számát! 7.3. Oázisok
7.3.1. A Szahara egyik szegletében 11 oázis található. Nem mindegyik között van közvetlen út és az utak sokszor kacskaringósak, hogy elkerüljék a futóhomokot és más veszélyeket. 10 beduin törzs él külön oázisokban, a 11., a szent oázis lakatlan. A törzsek egyszer csak észreveszik, hogy mindegyikük oázisa a kiszáradás szélén áll. Összegyűltek hát, hogy megoldást találjanak a problémára. A szent oázisban annyi víz van, amely képes elegendő vízzel ellátni a törzseket. Megállapodnak abban, hogy közösen építenek egy csővezeték rendszert az utak mellett, amelyen keresztül elegendő vízhez jut minden törzs. Ismerjük az oázisok közötti utak távolságát. Írjon programot, amely megtervez egy, az oázisokat összekötő csőhálózatot úgy, hogy a lehető legkevesebb cső felhasználásával minden kiszáradó oázis vízhez juthasson. A csövek kapacitása elég nagy, tehát az egyszerre szállítandó víz mennyiségével nem kell foglalkozni. Ötlet: használjon Prim algoritmust! 7.4. Sörhálózat A Kétfarkú Kutyapárt megnyerte a választásokat, így ígéretükhöz híven az ivóvíz hálózat mellé ingyen sör hálózatot alakítanak ki. Mindenkinek persze nem jut az ingyen sörből, de az év egy napján leállítják a vízszolgáltatást és a vízvezetékeken keresztül egy szerencsés kisorsolt városban megindul a sörszolgáltatás. A városok közötti vízvezetéknek ismert a szállítási kapacitása, valamint hogy az egyes vezetékek mely városokat kötnek össze. A hálózat egyik csomópontja a sörgyár.
7.3.1.
#include <stdio.h>
#include <stdlib.h> typedef struct Graf { int csomopontok;
double ** matrix;
} Graf;
typedef struct El { int pont1, pont2;
double suly;
} El;
void grafInit(Graf * graf, int meret) { graf->csomopontok = meret;
graf->matrix = NULL;
if (meret > 0) { int sor, oszlop;
graf->matrix = (double**) malloc(sizeof (double*) * graf>csomopontok);
for (sor = 0;
sor < graf->csomopontok;
sor++) { graf->matrix[sor] = (double*) malloc(sizeof (double) * graf>csomopontok);
for (oszlop = 0;
oszlop < graf->csomopontok;
oszlop++) { graf->matrix[sor][oszlop] = -1;
} } } } void grafBetolt(const char * file, Graf * graf) { FILE * fd = fopen(file, "r");
if (fd == NULL) { perror("Hiba");
return;
} int sor, oszlop;
fscanf(fd, "%d", &graf->csomopontok);
graf->matrix = (double**) malloc(sizeof (double*) * graf>csomopontok);
for (sor = 0;
sor < graf->csomopontok;
sor++) { graf->matrix[sor] = (double*) malloc(sizeof (double) * graf>csomopontok);
for (oszlop = 0;
oszlop < graf->csomopontok;
oszlop++) { fscanf(fd, "%lg", &graf->matrix[sor][oszlop]);
} } fclose(fd);
} void grafFelszabadit(Graf * graf) { int sor;
for (sor = 0;
sor < graf->csomopontok;
sor++) { free(graf->matrix[sor]);
} free(graf->matrix);
graf->csomopontok = 0;
graf->matrix = 0;
} double kruskal(Graf graf, Graf mft) { int elekSzama = 0;
int i, j;
for (i = 0;
i < graf.csomopontok;
i++) { for (j = i + 1;
j < graf.csomopontok;
j++) { if (graf.matrix[i][j] > -1) { elekSzama++;
} } } printf("%d el van a grafban\n", elekSzama);
El * elek = (El*) malloc(sizeof (El) * elekSzama);
elekSzama = 0;
for (i = 0;
i < graf.csomopontok;
i++) { for (j = i + 1;
j < graf.csomopontok;
j++) { if (graf.matrix[i][j] > -1) { elek[ elekSzama ].pont1 = i;
elek[ elekSzama ].pont2 = j;
elek[ elekSzama ].suly = graf.matrix[i][j];
elekSzama++;
} } } for (i = 0;
i < elekSzama - 1;
i++) { int minIndex = i;
for (j = i + 1;
j < elekSzama;
j++) { if (elek[ j ].suly < elek[ minIndex ].suly) { minIndex = j;
} } El temp = elek[ i ];
elek[ i ] = elek[ minIndex ];
elek[ minIndex ] = temp;
} } int lefedve = 0;
int * szinek = (int*) malloc(sizeof (int) * graf.csomopontok);
for (i = 0;
i < graf.csomopontok;
i++) { szinek[i] = i;
} int elIndex = 0;
double osszSuly = 0.0;
while (elIndex < elekSzama) { El el = elek[ elIndex ];
if (szinek[el.pont1] != szinek[el.pont2]) { mft.matrix[ el.pont1 ][ el.pont2 ] = el.suly;
mft.matrix[ el.pont2 ][ el.pont1 ] = el.suly;
osszSuly += el.suly;
int szinRef = szinek[el.pont1];
int szin2 = szinek[el.pont2];
for (j = 0;
j < graf.csomopontok;
j++) { if (szinek[j] == szinRef) { szinek[j] = szin2;
} } } elIndex++;
} free(elek);
free(szinek);
return osszSuly;
int main() { Graf graf;
grafInit(&graf, 0);
grafBetolt("kruskal.txt", &graf);
if (graf.csomopontok == 0) { return EXIT_FAILURE;
} Graf minfeszfa;
grafInit(&minfeszfa, graf.csomopontok);
double minFeszFaHossz = kruskal(graf, minfeszfa);
printf("A minimalis feszitofa ossz sulya: %lg\n", minFeszFaHossz);
int i, j;
for (i = 0;
i < minfeszfa.csomopontok;
i++) { for (j = i + 1;
j < minfeszfa.csomopontok;
j++) { if (minfeszfa.matrix[i][j] > -1) { printf("%d -- %d, suly: %lg\n", i, j, minfeszfa.matrix[i][j]);
} } } } grafFelszabadit(&graf);
grafFelszabadit(&minfeszfa);
return EXIT_SUCCESS;
-1 7 -1 5 -1 -1 -1 -1 -1 -1 -1 7 -1 8 9 7 -1 -1 5 -1 -1 -1 -1 8 -1 -1 5 -1 -1 -1 -1 -1 -1 5 9 -1 -1 15 6 -1 -1 -1 -1 -1 -1 7 5 15 -1 8 9 -1 -1 -1 -1 -1 -1 -1 6 8 -1 11 7 -1 -1 -1 -1 -1 -1 -1 9 11 -1 -1 5 -1 -1 -1 5 -1 -1 7 -1 -1 -1 -1 6 -1 -1 -1 -1 -1 -1 -1 5 -1 -1 -1 10 -1 -1 -1 -1 -1 -1 -1 6 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 10 -1 -1 
7.4.1.-7.4.3.
#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include <algorithm>
#include <limits> using namespace std;
const double vegtelen = numeric_limits<double>::infinity();
class FlowGraph { public: FlowGraph();
void Betolt(string FileNev);
void Folyam(int pont1, int pont2, double f);
double Folyam(int pont1, int pont2) const;
double Maradek(int pont1, int pont2) const;
bool Szomszedok(int pont1, int pont2) const;
void ResetFolyam();
double Ki(int pont) const;
double Be(int pont) const;
int Csomopontok() const;
private: vector< vector<double> > flow;
vector< vector<double> > matrix;
int n;
void MatrixBetolt(istream & is, vector< vector<double> > & matrix, int n);
void Init(int mennyi);
};
FlowGraph::FlowGraph() { n = 0;
} void FlowGraph::MatrixBetolt(istream & is, vector< vector<double> > & matrix, int n) { matrix.clear();
int i, j;
for (i = 0;
i < this->n;
i++) { vector<double> sor;
for (j = 0;
j < this->n;
j++) { double szam;
is >> szam;
if (szam == -1) szam = vegtelen;
sor.push_back(szam);
} matrix.push_back(sor);
} } void FlowGraph::Init(int mennyi) { n = mennyi;
matrix.resize(n);
int i;
for (i = 0;
i < n;
i++) matrix[i].resize(n, vegtelen);
} void FlowGraph::Folyam(int pont1, int pont2, double f) { flow[pont1][pont2] = f;
flow[pont2][pont1] = -f;
} void FlowGraph::ResetFolyam() { int i, j;
for (i = 0;
i < flow.size();
i++) { for (j = 0;
j < flow.size();
j++) { flow[i][j] = 0;
} } } void FlowGraph::Betolt(string FileNev) { ifstream ifs(FileNev.c_str());
if (ifs) { ifs >> n;
MatrixBetolt(ifs, matrix, n);
ifs.close();
} else cout << "hibas megnyitas" << endl;
int i, j;
flow.resize(n);
for (i = 0;
i < n;
i++) { flow[i].resize(n, 0);
for (j = 0;
j < n;
j++) if (matrix[i][j] == vegtelen) matrix[i][j] = -vegtelen;
} } double FlowGraph::Ki(int pont) const { int i;
double res = 0;
for (i = 0;
i < n;
i++) if (flow[pont][i] > 0) res += flow[pont][i];
return res;
} double FlowGraph::Be(int pont) const { int i;
double res = 0;
for (i = 0;
i < n;
i++) if (flow[i][pont] > 0) res += flow[i][pont];
return res;
} bool FlowGraph::Szomszedok(int pont1, int pont2) const { return Maradek(pont1, pont2) > 0.0;
} double FlowGraph::Folyam(int pont1, int pont2) const { return flow[pont1][pont2];
} double FlowGraph::Maradek(int pont1, int pont2) const { return matrix[pont1][pont2] - flow[pont1][pont2];
} int FlowGraph::Csomopontok() const { return n;
} bool bejar(int pont1, int pont2, FlowGraph & graf, vector<int> & ut) { int i;
set<int> visited;
vector<int> openset;
vector<int> elozo;
elozo.resize(graf.Csomopontok(), -1);
openset.push_back(pont1);
int node = pont1;
while (!openset.empty() && node != pont2) { node = openset.back();
openset.pop_back();
visited.insert(node);
for (i = 0;
i < graf.Csomopontok();
i++) { if (visited.find(i) == visited.end() && graf.Szomszedok(node, i) && find(openset.begin(), openset.end(), i) == openset.end()) { openset.push_back(i);
elozo[i] = node;
} } } vector<int>::iterator iter = elozo.begin();
ut.clear();
if (node == pont2) { int node = pont2;
while (node != pont1) { ut.insert(ut.begin(), node);
node = elozo[node];
} ut.insert(ut.begin(), node);
} } return node == pont2;
double FordFulkerson(int start, int end, FlowGraph & flow) { vector<int> ut;
do { bejar(start, end, flow, ut);
if (ut.size() > 0) { double min = flow.Maradek(ut[0], ut[1]);
int i;
for (i = 1;
i < ut.size() - 1;
i++) if (flow.Maradek(ut[i], ut[i + 1]) < min) min = flow.Maradek(ut[i], ut[i + 1]);
for (i = 0;
i < ut.size() - 1;
i++) { flow.Folyam(ut[i], ut[i + 1], min + flow.Folyam(ut[i], ut[i + 1]));
} } } while (ut.size() > 0);
return flow.Be(end);
} void legtobbSorHova(FlowGraph & graf, int honnan) { int maxIndex = 0;
double maxSor = 0.0;
int index;
for (index = 0;
index < graf.Csomopontok();
index++) { if (index != honnan) { graf.ResetFolyam();
double mennyiseg = FordFulkerson(honnan, index, graf);
if (mennyiseg > maxSor) { maxSor = mennyiseg;
maxIndex = index;
} } } cout << honnan << "-bol a legtobb sor " << maxIndex << "-be szallithato, ";
cout << "a mennyiseg: " << maxSor << endl;
} void komponensek(FlowGraph & graf) { vector<bool> megneztuk;
megneztuk.resize(graf.Csomopontok(), false);
int keres;
int komponensek = 0;
int maxKomponens = 0;
do { keres = 0;
while (keres < megneztuk.size() && megneztuk[keres]) keres++;
if (keres < megneztuk.size()) { komponensek++;
int pont1 = keres;
int i;
set<int> visited;
vector<int> openset;
openset.push_back(pont1);
int node = pont1;
while (!openset.empty()) { node = openset.back();
openset.pop_back();
visited.insert(node);
megneztuk[node] = true;
for (i = 0;
i < graf.Csomopontok();
i++) { if (visited.find(i) == visited.end() && graf.Szomszedok(node, i) && find(openset.begin(), openset.end(), i) == openset.end()) { openset.push_back(i);
} } vector<int>::iterator iter = openset.begin();
} if (maxKomponens < visited.size()) { maxKomponens = visited.size();
} } } while (keres < megneztuk.size());
cout << "A legnagyobb komponens " << maxKomponens << " varosbol all" << endl;
} int main(int argc, char** argv) { FlowGraph graf;
graf.Betolt("pipes.txt");
int sorgyar, cel;
cout << "Hol legyen a sorgyar? " << endl;
cin >> sorgyar;
cout << "Hol legyen a cel? " << endl;
cin >> cel;
double max = FordFulkerson(sorgyar, cel, graf);
cout << sorgyar << " es " << cel << " kozott max " << max << " mennyisegu sor szallithato" << endl;
} legtobbSorHova(graf, sorgyar);
graf.ResetFolyam();
komponensek(graf);
return 0;
6 -1 16 13 -1 -1 -1 -1 -1 10 12 -1 -1 -1 4 -1 -1 14 -1 -1 -1 9 -1 -1 20 -1 -1 -1 7 -1 4 -1 -1 -1 -1 -1 -1 
7.4.1. Írjon programot, amely megmondja, hogy maximálisan mennyi sört lehet továbbítani a sörgyárból a kisorsolt városba, ehhez mely vezetékeket kell felhasználni és, hogy ezek a vezetékek milyen mértékben lesznek kihasználva! A program fájlból olvassa be a vezetékhálózatot és a felhasználótól kérdezze meg, hogy hol van a sörgyár és melyik a kisorsolt város! Ötlet: használjon Ford és Fulkerson algoritmust! 
7.4.2. .Határozzuk meg, hogy ha csak egy városban lehet sörgyár (a helyét nem kötjük ki), akkor legfeljebb hány várost láthatunk el itallal? Ez azért fontos, mert a vezetékhálózat nem köt össze minden várost. 
7.4.3. Írjon függvényt, amely meghatározza, hogy egy adott csomópontból hova lehet eljuttatni a legnagyobb mennyiségű sört, és mekkora ez a mennyiség! 7.5. Páros gráf
7.5.1. Döntsük el egy gráfról, hogy páros-e, ehhez segítségnek használjunk szomszédossági mátrixot és szélességi keresést! A szélességi keresés a gráf egy adott csúcsából kiindulva bejárjanak szomszédjait, ezután azok szomszédjait és így tovább. Az algoritmus implementációjában segíthet, ha a nem meglátogatott csúcsokat egy sor adatszerkezetbe rakjuk, a meglátogatni kívánt csúcsokat pedig kivesszünk ebből a listából és belerakjuk egy átmenetibe, így az algoritmust addig kell futtatni, míg van kivehető elem a sorból. 7.6. Belmann-Ford algoritmus
7.5.1.
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h> #define SIZE 7 struct connected_nodes { int connected_node;
struct connected_nodes* next;
};
struct nodes { int node;
int clas;
int visited;
struct connected_nodes* edges;
struct nodes* next;
};
struct list { struct nodes* actual;
struct list* next;
};
void CreateGraph(int, int**, struct nodes*);
int BFS(struct nodes*);
void CreateList(struct nodes*, struct list**, struct list**);
void FreeList(struct list**);
int main() { int i, j;
struct nodes my_node;
int** dynamic_matrix = NULL;
int adjacenci_matrix[SIZE][SIZE] = { {0, 0, 0, 1, 1, 1, 0}, {0, 0, 0, 1, 1, 0, 0}, {0, 0, 0, 0, 1, 0, 1}, {1, 1, 0, 0, 0, 0, 0}, {1, 1, 1, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0} };
dynamic_matrix = (int**)malloc(SIZE*sizeof(int*));
for (i = 0;
i < SIZE;
++i) { dynamic_matrix[i] = (int*)malloc(SIZE*sizeof(int));
} for(i = 0;
i < SIZE;
++i) for (j = 0;
j < SIZE;
++j) dynamic_matrix[i][j] = adjacenci_matrix[i][j];
my_node.edges = NULL;
my_node.next = NULL;
} my_node.node = 0;
CreateGraph(SIZE, dynamic_matrix, &my_node);
if (BFS(&my_node)) { printf("\nThe graph is not bipartite!\n");
} else { printf("\nThe nodes have been divided into two disjoint sets.\n");
printf("The graph is bipartite.\n");
} for (i = 0;
i < SIZE;
++i) { free(dynamic_matrix[i]);
} free(dynamic_matrix);
return 0;
void CreateGraph(int size, int** adjacenci_matrix, struct nodes* my_node) { int i = 0, j = 0;
struct connected_nodes* temp_ptr;
my_node->node = 0;
my_node->visited = 0;
my_node->clas = 0;
for(i = 0;
i < size;
++i) { if(adjacenci_matrix[0][i]) { if (my_node->edges) { temp_ptr->next = (struct connected_nodes*)malloc(sizeof (struct connected_nodes));
temp_ptr = temp_ptr->next;
temp_ptr->connected_node = i;
temp_ptr->next = NULL;
} else { my_node->edges = (struct connected_nodes*)malloc(sizeof (struct connected_nodes));
temp_ptr = my_node->edges;
temp_ptr->connected_node = i;
temp_ptr->next = NULL;
} } } for(i = 1;
i < size;
++i) { my_node->next = (struct nodes*)malloc(sizeof (struct nodes));
my_node = my_node->next;
my_node->node = i;
my_node->next = NULL;
my_node->edges = NULL;
my_node->visited = 0;
my_node->clas = 0;
for(j = 0;
j < size;
++j) { if(adjacenci_matrix[i][j]) { if (my_node->edges) { temp_ptr->next = (struct connected_nodes*)malloc(sizeof (struct connected_nodes));
temp_ptr = temp_ptr->next;
temp_ptr->connected_node = j;
temp_ptr->next = NULL;
} else { my_node->edges = (struct connected_nodes*)malloc(sizeof (struct connected_nodes));
temp_ptr = my_node->edges;
temp_ptr->connected_node = j;
temp_ptr->next = NULL;
} } } } } int BFS(struct nodes* root) { int current_node;
struct connected_nodes* cn_temp;
struct nodes* n_temp;
struct list* list_temp, *list_temp1, * list_temp2, *list_temp_for_print;
lista list_temp2 = NULL;
root->clas = 1;
root->visited = 1;
printf("Creating first list (nodes in the current list): ");
list_temp1 = (struct list*)malloc(sizeof(struct list));
list_temp1->actual = root;
list_temp1->next = NULL;
list_temp_for_print = list_temp1;
while (list_temp_for_print) { printf("%d ", list_temp_for_print->actual->node);
list_temp_for_print = list_temp_for_print->next;
} printf("\n");
while (list_temp1) { list_temp = list_temp1;
while (list_temp) { cn_temp = list_temp->actual->edges;
while (cn_temp) { current_node = cn_temp->connected_node;
n_temp = root;
while (n_temp->node != current_node) n_temp = n_temp->next;
if (n_temp->visited == 0) { n_temp->visited = 2;
n_temp->clas = (-1) * list_temp1->actual->clas;
} else { if (list_temp1->actual->clas == n_temp->clas) return 1;
else { ;
} } cn_temp = cn_temp->next;
} list_temp = list_temp->next;
} printf("Creating next list (nodes in the current list): ");
CreateList(root, &list_temp1, &list_temp2);
FreeList(&list_temp1);
list_temp1 = list_temp2;
list_temp2 = NULL;
list_temp_for_print = list_temp1;
while (list_temp_for_print) { printf("%d ", list_temp_for_print->actual->node);
list_temp_for_print = list_temp_for_print->next;
} printf("\n");
} return 0;
} void CreateList(struct nodes* root, struct list** ptr1, struct list** ptr2) { struct nodes* n_temp;
struct connected_nodes* connected_node_temp;
struct list *first_list_temp, *second_list_temp;
int current_node;
first_list_temp = *ptr1;
while(first_list_temp) { connected_node_temp = first_list_temp->actual->edges;
while (connected_node_temp) { current_node = connected_node_temp->connected_node;
n_temp = root;
while (n_temp->node != current_node) n_temp = n_temp->next;
if (!(*ptr2) && (n_temp->visited == 2)) { n_temp->visited = 1;
(*ptr2) = (struct list*)malloc(sizeof(struct list));
(*ptr2)->actual = n_temp;
(*ptr2)->next = NULL;
second_list_temp = *ptr2;
} else if(n_temp->visited == 2) { n_temp->visited = 1;
second_list_temp->next = (struct list*)malloc(sizeof(struct list));
second_list_temp = second_list_temp->next;
second_list_temp->actual = n_temp;
second_list_temp->next = NULL;
} connected_node_temp = connected_node_temp->next;
} first_list_temp = first_list_temp->next;
} } void FreeList(struct list** head) { struct list* temp1, *temp2;
} temp1 = (*head);
while (temp1) { temp2 = temp1->next;
free(temp1);
temp1 = temp2;
} *head = NULL;

7.6.1.
#include <stdio.h> typedef struct { int u, v, weight;
}Edge;
#define INFINITY 10000 #define SIZE 5 void BellmanFord(int, int, int, int*, Edge*);
void PrintDistances(int, int[]);
int main() { Edge edges[1024];
int i, j;
int edges_num = 0, source_node = 2;
int distances_from_source[SIZE];
int adjacenci_matrix[SIZE][SIZE] = { {0, 6, 0, 7, 0}, {0, 0, 5, 8, -4}, {0, -2, 0, 0, 0}, {0, 0, -3, 9, 0}, {2, 0, 7, 0, 0} };
printf("The adjacenci matrix:\n");
for (i = 0;
i < SIZE;
++i) { for (j = 0;
j < SIZE;
++j) { printf("%d ", adjacenci_matrix[i][j]);
if (adjacenci_matrix[i][j] != 0) { edges[edges_num].u = i;
edges[edges_num].v = j;
edges[edges_num].weight = adjacenci_matrix[i][j];
edges_num++;
} } printf("\n");
} printf("\nRun Belmann-Ford algorithm to node %d\n", source_node);
BellmanFord(source_node, SIZE, edges_num, distances_from_source, edges);
printf("\nMinimal distances from node %d:\n", source_node);
PrintDistances(SIZE, distances_from_source);
return 0;
} void PrintDistances(int size, int* distances_from_source) { int i;
for (i = 0;
i < size;
++i) printf("to %d\t", i + 1);
printf("\n");
for (i = 0;
i < size;
++i) printf("%d\t", distances_from_source[i]);
} printf("\n");
void BellmanFord(int source, int size, int edges_num, int* distances_from_source, Edge* edges) { int i, j;
for (i = 0;
i < size;
++i) distances_from_source[i] = INFINITY;
distances_from_source[source] = 0;
for (i = 0;
i < size - 1;
++i) for (j = 0;
j < edges_num;
++j) if (distances_from_source[edges[j].u] + edges[j].weight < distances_from_source[edges[j].v]) distances_from_source[edges[j].v] = distances_from_source[edges[j].u] + edges[j].weight;
} 
7.6.1. Valósítsuk meg a Bellman-Ford algoritmust egy gráfon! Az algoritmus egy irányított gráf adott pontjától keresi meg a minimális költségű utakat a gráf többi pontjába. Először az egy, majd a kettő él hosszú legrövidebb utakat keresi meg és így tovább. Ha a gráf negatív kört tartalmaz, az algoritmus nem ad vissza jó értéket. 
7.6.2.
#include <stdio.h> typedef struct { int u, v, weight;
}Edge;
#define INFINITY 10000 #define SIZE 8 int BellmanFord(int, int, int, int*, Edge*);
void PrintDistances(int, int[]);
int main() { Edge edges[1024];
int i, j, max_distance = 0, temp_max_distance;
int edges_num = 0;
int distances_from_source[SIZE];
int adjacenci_matrix[SIZE][SIZE] = { {0, 1, 1, 0, 0, 0, 0, 0}, {1, 0, 0, 1, 0, 0, 0, 0}, {1, 0, 0, 0, 1, 1, 0, 0}, {0, 1, 0, 0, 0, 0, 1, 0}, {0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0, 1}, {0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0}, };
printf("Adjacenci matrix:\n");
for (i = 0;
i < SIZE;
++i) { for (j = 0;
j < SIZE;
++j) { printf("%d ", adjacenci_matrix[i][j]);
if (adjacenci_matrix[i][j] != 0) { edges[edges_num].u = i;
edges[edges_num].v = j;
edges[edges_num].weight = adjacenci_matrix[i][j];
edges_num++;
} } printf("\n");
} for (i = 0;i < SIZE;
++i) { temp_max_distance = BellmanFord(i, SIZE, edges_num, distances_from_source, edges);
PrintDistances(SIZE, distances_from_source);
if (temp_max_distance > max_distance) max_distance = temp_max_distance;
} printf("\nThe tree's diameter is: %d\n", max_distance);
return 0;
} void PrintDistances(int size, int* distances_from_source) { int i;
} printf("Distances from ");
for (i = 0;
i < size;
++i) { if (distances_from_source[i] == 0) printf("%d:\n", i+1);
} for (i = 0;
i < size;
++i) printf("to %d\t", i + 1);
printf("\n");
for (i = 0;
i < size;
++i) printf("%d\t", distances_from_source[i]);
printf("\n");
int BellmanFord(int source, int size, int edges_num, int* distances_from_source, Edge* edges) { int i, j, max = 0;
for (i = 0;
i < size;
++i) distances_from_source[i] = INFINITY;
distances_from_source[source] = 0;
for (i = 0;
i < size - 1;
++i) { for (j = 0;
j < edges_num;
++j) { if (distances_from_source[edges[j].u] + edges[j].weight < distances_from_source[edges[j].v]) { distances_from_source[edges[j].v] = distances_from_source[edges[j].u] + edges[j].weight;
} } } for (i = 0;
i < size;
++i) { if (distances_from_source[i] > max) max = distances_from_source[i];
} return max;
} 
7.6.2. Számítsuk ki egy fa átmérőjét! Egy fa átmérője alatt a fa bármely két csúcsa között futó legrövidebb utak közül a leghosszabbat értjük. Ötlet: Ha lefuttatjuk a fa minden pontjára a Belmann-Ford algoritmust, akkor ebből már csak a legkisebb elemet kell kiválasztani. 
7.6.3. Adott egy valuta átváltási táblázat (adjacencia mátrix). x valutát y-ra szeretnénk váltani, keressük meg azt az átváltási sorozatot, amelyben a legtöbb y valutát kapjuk. Nem biztos, hogy a direkt átváltás a legjobb. Pl.: 1 dollárért kapunk 2 eurót, azonban 1 dollárért kaphatunk 6 frankot is, 1 frankért fél dollárt, így a dollár – frank - euró lesz a legjobb átváltás. Az átváltási táblázat főátlója csupa egyes, hiszen 1 dollár átváltva dollárra 1 dollárt kapunk. A főátlóra szimmetrikusan pedig egymás reciprokjai kell, hogy szerepeljenek, mert ha 1 euró = 2 dollár, akkor 1 dollár = 1/2 euró. 7.7. Kruskal algoritmus
7.6.3.
#include <stdio.h> typedef struct { int u, v;
float weight;
}Edge;
#define INFINITY 10000 #define SIZE 3 void ModifiedBellmanFord(int, int, int, float*, Edge*);
void PrintMaxMoney(int, float[]);
int main() { Edge edges[1024];
int i, j;
int edges_num = 0, source_node = 0;
float distances_from_source[SIZE];
float adjacenci_matrix[SIZE][SIZE] = { {1, 2, 3}, {1./2, 1, 1./4}, {1./3, 4, 1} };
printf("Adjacenci matrix for exchange table:\n");
for (i = 0;
i < SIZE;
++i) { for (j = 0;
j < SIZE;
++j) { printf("%f ", adjacenci_matrix[i][j]);
if (adjacenci_matrix[i][j] != 0) { edges[edges_num].u = i;
edges[edges_num].v = j;
edges[edges_num].weight = adjacenci_matrix[i][j];
edges_num++;
} } printf("\n");
} ModifiedBellmanFord(source_node, SIZE, edges_num, distances_from_source, edges);
} PrintMaxMoney(SIZE, distances_from_source);
return 0;
void PrintMaxMoney(int size, float* distances_from_source) { int i;
printf("\nMax money at current currancys:\n");
for (i = 0;
i < size;
++i) printf("at %d\t\t", i + 1);
printf("\n");
for (i = 0;
i < size;
++i) printf("%f\t", distances_from_source[i]);
printf("\n");
} void ModifiedBellmanFord(int source, int size, int edges_num, float* distances_from_source, Edge* edges) { int i, j;
for (i = 0;
i < size;
++i) distances_from_source[i] = 0;
distances_from_source[source] = 1;
for (i = 0;
i < size - 1;
++i) { for (j = 0;
j < edges_num;
++j) { if (distances_from_source[edges[j].u] * edges[j].weight > distances_from_source[edges[j].v]) { distances_from_source[edges[j].v] = distances_from_source[edges[j].u] * edges[j].weight;
} } } } 
7.7.1.
#include <stdio.h>
#include <stdlib.h> #define SIZE 5 struct edges { int current_node;
struct edges* next;
};
struct node { int parent;
int current_node;
struct edges* current_node_edges;
struct node* next;
};
struct edge_list { int u;
int v;
int weight;
struct edge_list* next;
};
void Union(int, int, int, struct node*, struct node*);
int Where(int, int, int, struct node*, struct node*);
void CreateDisjunctGraphs(struct node*, int);
void FreeGraph(struct node*);
void FreeGraphList(struct node*);
void SortByWeight(struct edge_list**);
void FreeEdgeList(struct edge_list*);
int main() { int temp_num, i, j, k;
int source, destiny;
int destiny_disjunct_graph_root, source_disjunct_graph_root;
struct node my_disjunct_graph;
struct node nodes_in_row, *nodes_in_row_temp;
struct edge_list* my_edge_list = NULL;
struct edge_list *edge_list_temp;
struct edges* edges_temp;
struct edge_list* my_sorted_edge_list;
int adjacenci_matrix[SIZE][SIZE] = { {0, 3, 1, 0, 9}, {0, 4, 2, 4, 0}, {0, 4, 0, 1, 7}, {2, 0, 5, 0, 0}, {1, 0, 3, 0, 4} };
printf("The adjacenci matrix:\n");
for (i = 0;
i < SIZE;
++i) { for (k = 0;
k < i;
++k) printf("0 ");
for (j = i;
j < SIZE;
++j) { printf("%d ", adjacenci_matrix[i][j]);
if (adjacenci_matrix[i][j] != 0) { if (!my_edge_list) { my_edge_list = (struct edge_list*)malloc(sizeof(struct edge_list));
edge_list_temp = my_edge_list;
edge_list_temp->next = NULL;
edge_list_temp->u = i+1;
edge_list_temp->v = j+1;
edge_list_temp->weight = adjacenci_matrix[i][j];
} else { edge_list_temp->next = (struct edge_list*)malloc(sizeof(struct edge_list));
edge_list_temp = edge_list_temp->next;
edge_list_temp->next = NULL;
} } edge_list_temp->u = i+1;
edge_list_temp->v = j+1;
edge_list_temp->weight = adjacenci_matrix[i][j];
} printf("\n");
} SortByWeight(&my_edge_list);
my_sorted_edge_list = my_edge_list;
edge_list_temp = my_sorted_edge_list;
my_edge_list = my_edge_list->next;
while (my_edge_list) { SortByWeight(&my_edge_list);
edge_list_temp->next = my_edge_list;
edge_list_temp = edge_list_temp->next;
my_edge_list = my_edge_list->next;
} edge_list_temp = my_sorted_edge_list;
printf("\nList of the links from the biggest:\n");
while (edge_list_temp) { printf("Link (%d-%d), weight: %d\n", edge_list_temp->u, edge_list_temp->v, edge_list_temp->weight );
edge_list_temp = edge_list_temp->next;
} CreateDisjunctGraphs(&my_disjunct_graph, SIZE);
CreateDisjunctGraphs(&nodes_in_row, SIZE);
edge_list_temp = my_sorted_edge_list;
while (edge_list_temp) { printf("\nDisjunct graphs, before analyse link (%d-%d) with weight %d:\n", edge_list_temp->u, edge_list_temp->v, edge_list_temp->weight);
nodes_in_row_temp = &my_disjunct_graph;
while (nodes_in_row_temp) { printf("Root nood: %d the link(s): ", nodes_in_row_temp>current_node);
edges_temp = nodes_in_row_temp->current_node_edges;
while(edges_temp) { printf("%d ", edges_temp->current_node);
edges_temp = edges_temp->next;
} printf("\n");
nodes_in_row_temp = nodes_in_row_temp->next;
} destiny = edge_list_temp->u;
source = edge_list_temp->v;
destiny_disjunct_graph_root = Where(0, 0, destiny, &my_disjunct_graph, &nodes_in_row);
source_disjunct_graph_root = Where(0, 0, source, &my_disjunct_graph, &nodes_in_row);
if (destiny_disjunct_graph_root > source_disjunct_graph_root) { temp_num = destiny_disjunct_graph_root;
destiny_disjunct_graph_root = source_disjunct_graph_root;
source_disjunct_graph_root = temp_num;
} if (destiny_disjunct_graph_root != source_disjunct_graph_root) { Union(SIZE, destiny_disjunct_graph_root, source_disjunct_graph_root, &my_disjunct_graph, &nodes_in_row);
} else { printf("The nodes are in the same graph!\n");
} if (!my_disjunct_graph.next) { printf("\nPerfect, only one graph remain.\n");
printf("The minimum spanning tree has been created, the last link weight is: %d\n", edge_list_temp->weight);
break;
} edge_list_temp = edge_list_temp->next;
} if (my_disjunct_graph.next) { printf("\nSorry, more than one graph remain.\n");
printf("Cannot create minimum spanning tree!\n");
} } FreeGraph(&my_disjunct_graph);
FreeGraphList(&nodes_in_row);
FreeEdgeList(my_sorted_edge_list);
return 0;
void CreateDisjunctGraphs(struct node* my_node, int size) { int i;
my_node->parent = 1;
my_node->current_node = 1;
my_node->current_node_edges = NULL;
my_node->next = NULL;
for(i = 2;
i <= size;
++i) { my_node->next = (struct node*)malloc(sizeof(struct node));
my_node = my_node->next;
my_node->parent = i;
my_node->current_node = i;
my_node->current_node_edges = NULL;
my_node->next = NULL;
} } int Where(int recursion, int temp_parent, int u, struct node* actual, struct node* original) { int i = 0;
struct node* temp;
struct edges* temp_edge;
while (actual) { if (u == actual->current_node || temp_parent) return actual->parent;
else { temp_edge = actual->current_node_edges;
while (temp_edge) { temp = original;
while(temp_edge->current_node != temp->current_node) temp = temp->next;
temp_parent = Where(1, temp_parent, u, temp, original);
if (temp_parent) return actual->parent;
temp_edge = temp_edge->next;
} } if (recursion) return 0;
actual = actual->next;
} return 0;
} void Union(int size, int destiny, int source, struct node* my_dijunct_graphs , struct node* original) { struct node* temp_node, *source_node, *source_node_prev, *destiny_node;
struct edges* temp_edge;
source_node = my_dijunct_graphs;
destiny_node = my_dijunct_graphs;
while (source_node->current_node != source) { source_node_prev = source_node;
source_node = source_node->next;
} while (destiny_node->current_node != destiny) destiny_node = destiny_node->next;
if (destiny_node->next->current_node == source) { destiny_node->next = source_node->next;
source_node->next = NULL;
konzisztens lesz source_node->parent = destiny_node->parent;
temp_node = original;
while(temp_node->current_node != source) temp_node = temp_node->next;
temp_node->parent = destiny_node->parent;
if (!destiny_node->current_node_edges) { destiny_node->current_node_edges = (struct edges*)malloc(sizeof(struct edges));
destiny_node->current_node_edges->next = NULL;
destiny_node->current_node_edges->current_node = source_node>current_node;
temp_node = original;
while (temp_node->current_node != destiny_node->current_node) temp_node = temp_node->next;
temp_node->current_node_edges = destiny_node>current_node_edges;
} else { temp_edge = destiny_node->current_node_edges;
while (temp_edge->next) temp_edge = temp_edge->next;
temp_edge->next = (struct edges*)malloc(sizeof(struct edges));
temp_edge = temp_edge->next;
temp_edge->current_node = source;
temp_edge->next = NULL;
} } else { source_node_prev->next = source_node->next;
source_node->next = NULL;
source_node->parent = destiny_node->parent;
temp_node = original;
while(temp_node->current_node != source) temp_node = temp_node->next;
temp_node->parent = destiny_node->parent;
temp_edge = destiny_node->current_node_edges;
if (!destiny_node->current_node_edges) { destiny_node->current_node_edges = (struct edges*)malloc(sizeof(struct edges));
destiny_node->current_node_edges->next = NULL;
destiny_node->current_node_edges->current_node = source_node>current_node;
temp_node = original;
while (temp_node->current_node != destiny_node->current_node) temp_node = temp_node->next;
temp_node->current_node_edges = destiny_node>current_node_edges;
} else { temp_edge = destiny_node->current_node_edges;
while (temp_edge->next) temp_edge = temp_edge->next;
temp_edge->next = (struct edges*)malloc(sizeof(struct edges));
temp_edge = temp_edge->next;
temp_edge->current_node = source;
temp_edge->next = NULL;
} } } void SortByWeight(struct edge_list** root) { int min;
struct edge_list* temp, *temp_prev, *min_weight, *min_weight_prev;
temp_prev = *root;
temp = temp_prev->next;
min_weight = *root;
min_weight_prev = NULL;
min = (*root)->weight;
while (temp) { if (temp->weight < min) { min = temp->weight;
min_weight = temp;
min_weight_prev = temp_prev;
temp_prev = temp;
temp = temp->next;
} else { temp_prev = temp;
temp = temp->next;
} } if (!min_weight_prev) ;
else if (min_weight_prev == (*root)) { (*root)->next = min_weight->next;
min_weight->next = min_weight_prev;
(*root) = min_weight;
} else { min_weight_prev->next = min_weight->next;
min_weight->next = (*root);
(*root) = min_weight;
} } void FreeGraph(struct node* root) { struct edges* temp_edge1, *temp_edge2;
struct node* temp_node1, *temp_node2;
temp_edge1 = root->current_node_edges;
while (temp_edge1) { temp_edge2 = temp_edge1;
temp_edge1 = temp_edge1->next;
free(temp_edge2);
} temp_node1 = root->next;
while (temp_node1) { temp_edge1 = temp_node1->current_node_edges;
while (temp_edge1) { temp_edge2 = temp_edge1;
temp_edge1 = temp_edge1->next;
free(temp_edge2);
} temp_node2 = temp_node1;
temp_node1 = temp_node1->next;
free(temp_node2);
} } void FreeGraphList(struct node* root) { struct node* temp_node1, *temp_node2;
temp_node1 = root->next;
while (temp_node1) { temp_node2 = temp_node1;
temp_node1 = temp_node1->next;
free(temp_node2);
} } void FreeEdgeList(struct edge_list* temp1) { struct edge_list* temp2;
} while(temp1) { temp2 = temp1;
temp1 = temp1->next;
free(temp2);
} 
7.7.1. Valósítsa meg a Kruskal algoritmust! Tárolja halmazban az épülő feszítőfa csúcsait! Használja az UNIÓ, HOLVAN halmazműveleteket annak eldöntésére, hogy egy új él felvétele okoz-e kört a feszítőfában! Ötlet: Az algoritmus elején a gráf minden pontja egy önálló halmazt jelent. A HOLVAN művelet megadja, hogy egy elem, melyik halmazban található, az UNIÓ művelet két halmazt egyesít. Ha egy élet akarunk hozzáadni a feszítőfához, akkor meg kell vizsgálni, hogy az él két pontja ugyanabba a halmazba tartozik-e. Ha igen, akkor az él felvétele kört okozna, így a következő legkisebb súlyú élt kell vizsgálni. A halmazokat (nem bináris) fákkal reprezentáljuk. Az UNIÓ művelet két ilyen fát egyesít oly módon, hogy az első fa a gyökere a második fa gyökerének egy új gyereke lesz. A HOLVAN művelet megadja a fa gyökerét. 
7.7.2. A minimális költségű feszítőfa helyett keresünk maximális költségűt! Egy kommunikációs hálózat tartalmazza a számítógépeket és az azok közötti kétirányú kapcsolatokat. Mindegyik kapcsolathoz sávszélesség tartozik. Bármely, két gépet összekötő hálózatrész sávszélessége alatt az egyes vezetékszakaszok sávszélességének minimumát értjük. Ha két gép között több úton is létesíthető kapcsolat, akkor az összeköttetés sávszélessége ezek közül a maximum. A teljes hálózat sávszélessége alatt az azt alkotó gépek közötti sávszélességek minimumát értjük. Ha a gráf nem összefüggő, akkor 0 a sávszélesség. Írjunk programot, amely beolvassa a hálózat adatait, majd meghatározza a sávszélességét! 8. Rendezési feladatok 8.1.Tömbrendezés
7.7.2.
#include <stdio.h>
#include <stdlib.h> #define SIZE 5 struct edges { int current_node;
struct edges* next;
};
struct node { int parent;
int current_node;
struct edges* current_node_edges;
struct node* next;
};
struct edge_list { int u;
};
int v;
int weight;
struct edge_list* next;
void Union(int, int, int, struct node*, struct node*);
int Where(int, int, int, struct node*, struct node*);
void CreateDisjunctGraphs(struct node*, int);
void FreeGraph(struct node*);
void FreeGraphList(struct node*);
void SortByWeight(struct edge_list**);
void FreeEdgeList(struct edge_list*);
int main() { int temp_num, i, j;
int source, destiny;
int destiny_disjunct_graph_root, source_disjunct_graph_root;
struct node my_disjunct_graph;
struct node nodes_in_row, *nodes_in_row_temp;
struct edge_list* my_edge_list = NULL;
struct edge_list *edge_list_temp;
struct edges* edges_temp;
struct edge_list* my_sorted_edge_list;
int adjacenci_matrix[SIZE][SIZE] = { {0, 0, 5, 0, 3}, {0, 6, 9, 0, 8}, {0, 8, 0, 2, 0}, {6, 2, 5, 0, 5}, {5, 0, 5, 1, 0} };
printf("The adjacenci matrix:\n");
for (i = 0;
i < SIZE;
++i) { for (j = 0;
j < SIZE;
++j) { printf("%d ", adjacenci_matrix[i][j]);
if (adjacenci_matrix[i][j] != 0) { if (!my_edge_list) { my_edge_list = (struct edge_list*)malloc(sizeof(struct edge_list));
edge_list_temp = my_edge_list;
edge_list_temp->next = NULL;
edge_list_temp->u = i+1;
edge_list_temp->v = j+1;
edge_list_temp->weight = adjacenci_matrix[i][j];
} else { edge_list_temp->next = (struct edge_list*)malloc(sizeof(struct edge_list));
edge_list_temp = edge_list_temp->next;
edge_list_temp->next = NULL;
edge_list_temp->u = i+1;
edge_list_temp->v = j+1;
edge_list_temp->weight = adjacenci_matrix[i][j];
} } } printf("\n");
} SortByWeight(&my_edge_list);
my_sorted_edge_list = my_edge_list;
edge_list_temp = my_sorted_edge_list;
my_edge_list = my_edge_list->next;
while (my_edge_list) { SortByWeight(&my_edge_list);
edge_list_temp->next = my_edge_list;
edge_list_temp = edge_list_temp->next;
my_edge_list = my_edge_list->next;
} edge_list_temp = my_sorted_edge_list;
printf("\nList of the links from the biggest:\n");
while (edge_list_temp) { printf("Link (%d-%d), weight: %d\n", edge_list_temp->u, edge_list_temp->v, edge_list_temp->weight );
edge_list_temp = edge_list_temp->next;
} CreateDisjunctGraphs(&my_disjunct_graph, SIZE);
CreateDisjunctGraphs(&nodes_in_row, SIZE);
edge_list_temp = my_sorted_edge_list;
while (edge_list_temp) { printf("\nDisjunct graphs, before analyse link (%d-%d) with weight %d:\n", edge_list_temp->u, edge_list_temp->v, edge_list_temp->weight);
nodes_in_row_temp = &my_disjunct_graph;
while (nodes_in_row_temp) { printf("Root nood: %d the link(s): ", nodes_in_row_temp>current_node);
edges_temp = nodes_in_row_temp->current_node_edges;
while(edges_temp) { printf("%d ", edges_temp->current_node);
edges_temp = edges_temp->next;
} printf("\n");
nodes_in_row_temp = nodes_in_row_temp->next;
} destiny = edge_list_temp->u;
source = edge_list_temp->v;
destiny_disjunct_graph_root = Where(0, 0, destiny, &my_disjunct_graph, &nodes_in_row);
source_disjunct_graph_root = Where(0, 0, source, &my_disjunct_graph, &nodes_in_row);
if (destiny_disjunct_graph_root > source_disjunct_graph_root) { temp_num = destiny_disjunct_graph_root;
destiny_disjunct_graph_root = source_disjunct_graph_root;
source_disjunct_graph_root = temp_num;
} if (destiny_disjunct_graph_root != source_disjunct_graph_root) { Union(SIZE, destiny_disjunct_graph_root, source_disjunct_graph_root, &my_disjunct_graph, &nodes_in_row);
} else { printf("The nodes are in the same graph!\n");
} if (!my_disjunct_graph.next) { printf("\nPerfect, only one graph remain.\n");
printf("The network's bandwidth: %d\n", edge_list_temp>weight);
break;
} edge_list_temp = edge_list_temp->next;
} if (my_disjunct_graph.next) { printf("\nSorry, more than one graph remains.\n");
printf("The network's bandwidth: 0\n");
} } FreeGraph(&my_disjunct_graph);
FreeGraphList(&nodes_in_row);
FreeEdgeList(my_sorted_edge_list);
return 0;
void CreateDisjunctGraphs(struct node* my_node, int size) { int i;
my_node->parent = 1;
my_node->current_node = 1;
my_node->current_node_edges = NULL;
my_node->next = NULL;
for(i = 2;
i <= size;
++i) { my_node->next = (struct node*)malloc(sizeof(struct node));
my_node = my_node->next;
my_node->parent = i;
my_node->current_node = i;
my_node->current_node_edges = NULL;
my_node->next = NULL;
} } int Where(int recursion, int temp_parent, int u, struct node* actual, struct node* original) { struct node* temp;
struct edges* temp_edge;
while (actual) { if (u == actual->current_node || temp_parent) return actual->parent;
else { temp_edge = actual->current_node_edges;
while (temp_edge) { temp = original;
while(temp_edge->current_node != temp->current_node) temp = temp->next;
temp_parent = Where(1, temp_parent, u, temp, original);
if (temp_parent) return actual->parent;
temp_edge = temp_edge->next;
} } if (recursion) return 0;
actual = actual->next;
} return 0;
} void Union(int size, int destiny, int source, struct node* my_dijunct_graphs , struct node* original) { struct node* temp_node, *source_node, *source_node_prev, *destiny_node;
struct edges* temp_edge;
source_node = my_dijunct_graphs;
destiny_node = my_dijunct_graphs;
while (source_node->current_node != source) { source_node_prev = source_node;
source_node = source_node->next;
} while (destiny_node->current_node != destiny) destiny_node = destiny_node->next;
if (destiny_node->next->current_node == source) { destiny_node->next = source_node->next;
source_node->next = NULL;
konzisztens lesz source_node->parent = destiny_node->parent;
temp_node = original;
while(temp_node->current_node != source) temp_node = temp_node->next;
temp_node->parent = destiny_node->parent;
if (!destiny_node->current_node_edges) { destiny_node->current_node_edges = (struct edges*)malloc(sizeof(struct edges));
destiny_node->current_node_edges->next = NULL;
destiny_node->current_node_edges->current_node = source_node>current_node;
temp_node = original;
while (temp_node->current_node != destiny_node->current_node) temp_node = temp_node->next;
temp_node->current_node_edges = destiny_node>current_node_edges;
} else { temp_edge = destiny_node->current_node_edges;
while (temp_edge->next) temp_edge = temp_edge->next;
temp_edge->next = (struct edges*)malloc(sizeof(struct edges));
temp_edge = temp_edge->next;
temp_edge->current_node = source;
temp_edge->next = NULL;
} } else { source_node_prev->next = source_node->next;
source_node->next = NULL;
source_node->parent = destiny_node->parent;
temp_node = original;
while(temp_node->current_node != source) temp_node = temp_node->next;
temp_node->parent = destiny_node->parent;
temp_edge = destiny_node->current_node_edges;
if (!destiny_node->current_node_edges) { destiny_node->current_node_edges = (struct edges*)malloc(sizeof(struct edges));
destiny_node->current_node_edges->next = NULL;
destiny_node->current_node_edges->current_node = source_node>current_node;
temp_node = original;
while (temp_node->current_node != destiny_node->current_node) temp_node = temp_node->next;
temp_node->current_node_edges = destiny_node>current_node_edges;
} else { temp_edge = destiny_node->current_node_edges;
while (temp_edge->next) temp_edge = temp_edge->next;
temp_edge->next = (struct edges*)malloc(sizeof(struct edges));
temp_edge = temp_edge->next;
temp_edge->current_node = source;
temp_edge->next = NULL;
} } } void SortByWeight(struct edge_list** root) { int max;
struct edge_list* temp, *temp_prev, *max_weight, *max_weight_prev;
temp_prev = *root;
temp = temp_prev->next;
max_weight = *root;
max_weight_prev = NULL;
max = (*root)->weight;
while (temp) { if (temp->weight > max) { max = temp->weight;
max_weight = temp;
max_weight_prev = temp_prev;
temp_prev = temp;
temp = temp->next;
} else { temp_prev = temp;
temp = temp->next;
} } if (!max_weight_prev) ;
else if (max_weight_prev == (*root)) { (*root)->next = max_weight->next;
max_weight->next = max_weight_prev;
(*root) = max_weight;
} else { max_weight_prev->next = max_weight->next;
max_weight->next = (*root);
(*root) = max_weight;
} } void FreeGraph(struct node* root) { struct edges* temp_edge1, *temp_edge2;
struct node* temp_node1, *temp_node2;
temp_edge1 = root->current_node_edges;
while (temp_edge1) { temp_edge2 = temp_edge1;
temp_edge1 = temp_edge1->next;
free(temp_edge2);
} temp_node1 = root->next;
while (temp_node1) { temp_edge1 = temp_node1->current_node_edges;
while (temp_edge1) { temp_edge2 = temp_edge1;
temp_edge1 = temp_edge1->next;
free(temp_edge2);
} temp_node2 = temp_node1;
temp_node1 = temp_node1->next;
free(temp_node2);
} } void FreeGraphList(struct node* root) { struct node* temp_node1, *temp_node2;
temp_node1 = root->next;
while (temp_node1) { temp_node2 = temp_node1;
temp_node1 = temp_node1->next;
free(temp_node2);
} } void FreeEdgeList(struct edge_list* temp1) { struct edge_list* temp2;
} while(temp1) { temp2 = temp1;
temp1 = temp1->next;
free(temp2);
} 
