// 7.7.2. A minimális költségű feszítőfa helyett keresünk maximális költségűt! Egy kommunikációs hálózat tartalmazza a számítógépeket és az azok közötti kétirányú kapcsolatokat. Mindegyik kapcsolathoz sávszélesség tartozik. Bármely, két gépet összekötő hálózatrész sávszélessége alatt az egyes vezetékszakaszok sávszélességének minimumát értjük. Ha két gép között több úton is létesíthető kapcsolat, akkor az összeköttetés sávszélessége ezek közül a maximum. A teljes hálózat sávszélessége alatt az azt alkotó gépek közötti sávszélességek minimumát értjük. Ha a gráf nem összefüggő, akkor 0 a sávszélesség. Írjunk programot, amely beolvassa a hálózat adatait, majd meghatározza a sávszélességét! 8. Rendezési feladatok 8.1.Tömbrendezés
7.7.2.
#include <stdio.h>
#include <stdlib.h> #define SIZE 5 struct edges { int current_node;
struct edges* next;
};
struct node { int parent;
int current_node;
struct edges* current_node_edges;
struct node* next;
};
struct edge_list { int u;
};
int v;
int weight;
struct edge_list* next;
void Union(int, int, int, struct node*, struct node*);
int Where(int, int, int, struct node*, struct node*);
void CreateDisjunctGraphs(struct node*, int);
void FreeGraph(struct node*);
void FreeGraphList(struct node*);
void SortByWeight(struct edge_list**);
void FreeEdgeList(struct edge_list*);
int main() { int temp_num, i, j;
int source, destiny;
int destiny_disjunct_graph_root, source_disjunct_graph_root;
struct node my_disjunct_graph;
struct node nodes_in_row, *nodes_in_row_temp;
struct edge_list* my_edge_list = NULL;
struct edge_list *edge_list_temp;
struct edges* edges_temp;
struct edge_list* my_sorted_edge_list;
int adjacenci_matrix[SIZE][SIZE] = { {0, 0, 5, 0, 3}, {0, 6, 9, 0, 8}, {0, 8, 0, 2, 0}, {6, 2, 5, 0, 5}, {5, 0, 5, 1, 0} };
printf("The adjacenci matrix:\n");
for (i = 0;
i < SIZE;
++i) { for (j = 0;
j < SIZE;
++j) { printf("%d ", adjacenci_matrix[i][j]);
if (adjacenci_matrix[i][j] != 0) { if (!my_edge_list) { my_edge_list = (struct edge_list*)malloc(sizeof(struct edge_list));
edge_list_temp = my_edge_list;
edge_list_temp->next = NULL;
edge_list_temp->u = i+1;
edge_list_temp->v = j+1;
edge_list_temp->weight = adjacenci_matrix[i][j];
} else { edge_list_temp->next = (struct edge_list*)malloc(sizeof(struct edge_list));
edge_list_temp = edge_list_temp->next;
edge_list_temp->next = NULL;
edge_list_temp->u = i+1;
edge_list_temp->v = j+1;
edge_list_temp->weight = adjacenci_matrix[i][j];
} } } printf("\n");
} SortByWeight(&my_edge_list);
my_sorted_edge_list = my_edge_list;
edge_list_temp = my_sorted_edge_list;
my_edge_list = my_edge_list->next;
while (my_edge_list) { SortByWeight(&my_edge_list);
edge_list_temp->next = my_edge_list;
edge_list_temp = edge_list_temp->next;
my_edge_list = my_edge_list->next;
} edge_list_temp = my_sorted_edge_list;
printf("\nList of the links from the biggest:\n");
while (edge_list_temp) { printf("Link (%d-%d), weight: %d\n", edge_list_temp->u, edge_list_temp->v, edge_list_temp->weight );
edge_list_temp = edge_list_temp->next;
} CreateDisjunctGraphs(&my_disjunct_graph, SIZE);
CreateDisjunctGraphs(&nodes_in_row, SIZE);
edge_list_temp = my_sorted_edge_list;
while (edge_list_temp) { printf("\nDisjunct graphs, before analyse link (%d-%d) with weight %d:\n", edge_list_temp->u, edge_list_temp->v, edge_list_temp->weight);
nodes_in_row_temp = &my_disjunct_graph;
while (nodes_in_row_temp) { printf("Root nood: %d the link(s): ", nodes_in_row_temp>current_node);
edges_temp = nodes_in_row_temp->current_node_edges;
while(edges_temp) { printf("%d ", edges_temp->current_node);
edges_temp = edges_temp->next;
} printf("\n");
nodes_in_row_temp = nodes_in_row_temp->next;
} destiny = edge_list_temp->u;
source = edge_list_temp->v;
destiny_disjunct_graph_root = Where(0, 0, destiny, &my_disjunct_graph, &nodes_in_row);
source_disjunct_graph_root = Where(0, 0, source, &my_disjunct_graph, &nodes_in_row);
if (destiny_disjunct_graph_root > source_disjunct_graph_root) { temp_num = destiny_disjunct_graph_root;
destiny_disjunct_graph_root = source_disjunct_graph_root;
source_disjunct_graph_root = temp_num;
} if (destiny_disjunct_graph_root != source_disjunct_graph_root) { Union(SIZE, destiny_disjunct_graph_root, source_disjunct_graph_root, &my_disjunct_graph, &nodes_in_row);
} else { printf("The nodes are in the same graph!\n");
} if (!my_disjunct_graph.next) { printf("\nPerfect, only one graph remain.\n");
printf("The network's bandwidth: %d\n", edge_list_temp>weight);
break;
} edge_list_temp = edge_list_temp->next;
} if (my_disjunct_graph.next) { printf("\nSorry, more than one graph remains.\n");
printf("The network's bandwidth: 0\n");
} } FreeGraph(&my_disjunct_graph);
FreeGraphList(&nodes_in_row);
FreeEdgeList(my_sorted_edge_list);
return 0;
void CreateDisjunctGraphs(struct node* my_node, int size) { int i;
my_node->parent = 1;
my_node->current_node = 1;
my_node->current_node_edges = NULL;
my_node->next = NULL;
for(i = 2;
i <= size;
++i) { my_node->next = (struct node*)malloc(sizeof(struct node));
my_node = my_node->next;
my_node->parent = i;
my_node->current_node = i;
my_node->current_node_edges = NULL;
my_node->next = NULL;
} } int Where(int recursion, int temp_parent, int u, struct node* actual, struct node* original) { struct node* temp;
struct edges* temp_edge;
while (actual) { if (u == actual->current_node || temp_parent) return actual->parent;
else { temp_edge = actual->current_node_edges;
while (temp_edge) { temp = original;
while(temp_edge->current_node != temp->current_node) temp = temp->next;
temp_parent = Where(1, temp_parent, u, temp, original);
if (temp_parent) return actual->parent;
temp_edge = temp_edge->next;
} } if (recursion) return 0;
actual = actual->next;
} return 0;
} void Union(int size, int destiny, int source, struct node* my_dijunct_graphs , struct node* original) { struct node* temp_node, *source_node, *source_node_prev, *destiny_node;
struct edges* temp_edge;
source_node = my_dijunct_graphs;
destiny_node = my_dijunct_graphs;
while (source_node->current_node != source) { source_node_prev = source_node;
source_node = source_node->next;
} while (destiny_node->current_node != destiny) destiny_node = destiny_node->next;
if (destiny_node->next->current_node == source) { destiny_node->next = source_node->next;
source_node->next = NULL;
konzisztens lesz source_node->parent = destiny_node->parent;
temp_node = original;
while(temp_node->current_node != source) temp_node = temp_node->next;
temp_node->parent = destiny_node->parent;
if (!destiny_node->current_node_edges) { destiny_node->current_node_edges = (struct edges*)malloc(sizeof(struct edges));
destiny_node->current_node_edges->next = NULL;
destiny_node->current_node_edges->current_node = source_node>current_node;
temp_node = original;
while (temp_node->current_node != destiny_node->current_node) temp_node = temp_node->next;
temp_node->current_node_edges = destiny_node>current_node_edges;
} else { temp_edge = destiny_node->current_node_edges;
while (temp_edge->next) temp_edge = temp_edge->next;
temp_edge->next = (struct edges*)malloc(sizeof(struct edges));
temp_edge = temp_edge->next;
temp_edge->current_node = source;
temp_edge->next = NULL;
} } else { source_node_prev->next = source_node->next;
source_node->next = NULL;
source_node->parent = destiny_node->parent;
temp_node = original;
while(temp_node->current_node != source) temp_node = temp_node->next;
temp_node->parent = destiny_node->parent;
temp_edge = destiny_node->current_node_edges;
if (!destiny_node->current_node_edges) { destiny_node->current_node_edges = (struct edges*)malloc(sizeof(struct edges));
destiny_node->current_node_edges->next = NULL;
destiny_node->current_node_edges->current_node = source_node>current_node;
temp_node = original;
while (temp_node->current_node != destiny_node->current_node) temp_node = temp_node->next;
temp_node->current_node_edges = destiny_node>current_node_edges;
} else { temp_edge = destiny_node->current_node_edges;
while (temp_edge->next) temp_edge = temp_edge->next;
temp_edge->next = (struct edges*)malloc(sizeof(struct edges));
temp_edge = temp_edge->next;
temp_edge->current_node = source;
temp_edge->next = NULL;
} } } void SortByWeight(struct edge_list** root) { int max;
struct edge_list* temp, *temp_prev, *max_weight, *max_weight_prev;
temp_prev = *root;
temp = temp_prev->next;
max_weight = *root;
max_weight_prev = NULL;
max = (*root)->weight;
while (temp) { if (temp->weight > max) { max = temp->weight;
max_weight = temp;
max_weight_prev = temp_prev;
temp_prev = temp;
temp = temp->next;
} else { temp_prev = temp;
temp = temp->next;
} } if (!max_weight_prev) ;
else if (max_weight_prev == (*root)) { (*root)->next = max_weight->next;
max_weight->next = max_weight_prev;
(*root) = max_weight;
} else { max_weight_prev->next = max_weight->next;
max_weight->next = (*root);
(*root) = max_weight;
} } void FreeGraph(struct node* root) { struct edges* temp_edge1, *temp_edge2;
struct node* temp_node1, *temp_node2;
temp_edge1 = root->current_node_edges;
while (temp_edge1) { temp_edge2 = temp_edge1;
temp_edge1 = temp_edge1->next;
free(temp_edge2);
} temp_node1 = root->next;
while (temp_node1) { temp_edge1 = temp_node1->current_node_edges;
while (temp_edge1) { temp_edge2 = temp_edge1;
temp_edge1 = temp_edge1->next;
free(temp_edge2);
} temp_node2 = temp_node1;
temp_node1 = temp_node1->next;
free(temp_node2);
} } void FreeGraphList(struct node* root) { struct node* temp_node1, *temp_node2;
temp_node1 = root->next;
while (temp_node1) { temp_node2 = temp_node1;
temp_node1 = temp_node1->next;
free(temp_node2);
} } void FreeEdgeList(struct edge_list* temp1) { struct edge_list* temp2;
} while(temp1) { temp2 = temp1;
temp1 = temp1->next;
free(temp2);
} 
