3.49.1-3.49.3.
#include <stdio.h>
#include <stdlib.h> typedef struct Elem { double value;
int index;
struct Elem * next;
} Elem;
typedef struct Vector { Elem * fej;
} Vector;
void initVector(Vector * vector) { vector->fej = NULL;
} double lekerdezVector(Vector vector, int index) { Elem * tmp = vector.fej;
while (tmp && tmp->index < index) tmp = tmp->next;
if (tmp && tmp->index == index) return tmp->value;
return 0.0;
} int torolVector(Vector * vector, int pos) { Elem * prv = 0, * tmp = vector->fej;
while (tmp && tmp->index < pos) { prv = tmp;
tmp = tmp->next;
} if (tmp && tmp->index == pos) { if (prv) prv->next = tmp->next;
else vector->fej = tmp->next;
free(tmp);
return 1;
} return 0;
} void tisztitVector(Vector * vector) { Elem * tmp = vector->fej, * prv = 0;
while (tmp) { if (tmp->value == 0) { Elem * tmp2 = tmp->next;
torolVector(vector, tmp->index);
tmp = tmp2;
} else { prv = tmp;
tmp = tmp->next;
} } } void felszabaditVector(Vector * vector) { Elem * tmp1 = vector->fej;
Elem * tmp2;
while (tmp1) { tmp2 = tmp1->next;
free(tmp1);
tmp1 = tmp2;
} vector->fej = 0;
} void mutatVector(Vector vector) { int i, dim;
if ((dim = legutolsoVector(vector)) == 0) { printf("ures\n");
return;
} for (i = 0;
i <= dim;
i++) { printf("%lg", lekerdezVector(vector, i));
if (i < dim) printf(",");
} printf("\n");
} void beallitVector(Vector * vector, double value, int pos) { if (value == 0.0) return;
if (!vector->fej) { vector->fej = (Elem*) malloc(sizeof (Elem));
vector->fej->value = value;
vector->fej->index = pos;
vector->fej->next = 0;
} else { Elem * prv = NULL, * tmp = vector->fej;
while (tmp && (tmp->index < pos)) { prv = tmp;
tmp = tmp->next;
} if (tmp && tmp->index == pos) { tmp->value = value;
return;
} Elem * nm = (Elem*) malloc(sizeof (Elem));
nm->value = value;
nm->index = pos;
} } if (!tmp) { prv->next = nm;
prv->next->next = 0;
} else { if (prv) { prv->next = nm;
prv->next->next = tmp;
} else { prv = nm;
prv->next = tmp;
vector->fej = prv;
} } void rendezVector(Vector vector) { if (!vector.fej) return;
Elem * tmp1, * tmp2, * min;
double temp;
tmp1 = vector.fej;
while (tmp1->next) { min = tmp2 = tmp1;
while (tmp2) { if (tmp2->value < min->value) min = tmp2;
tmp2 = tmp2->next;
} temp = min->value;
min->value = tmp1->value;
tmp1->value = temp;
tmp1 = tmp1->next;
} } double szorozVector(Vector v1, Vector v2) { if (!v1.fej || !v2.fej) return 0.0;
double res = 0;
Elem * tmp1 = v1.fej;
while (tmp1) { Elem * tmp2 = v2.fej;
while (tmp2 && tmp2->index < tmp1->index) tmp2 = tmp2->next;
if (tmp2 && tmp2->index == tmp1->index) res += tmp1->value * tmp2->value;
tmp1 = tmp1->next;
} return res;
} void addVector(Vector * v1, Vector v2) { Elem * tmp1 = v1->fej, * tmp2;
while (tmp1) { tmp2 = v2.fej;
while (tmp2 && tmp2->index < tmp1->index) tmp2 = tmp2->next;
if (tmp2 && tmp2->index == tmp1->index) tmp1->value += tmp2->value;
tmp1 = tmp1->next;
} } tmp1 = v2.fej;
while (tmp1) { tmp2 = v1->fej;
while (tmp2 && tmp2->index < tmp1->index) tmp2 = tmp2->next;
if (!tmp2 || tmp2->index > tmp1->index) beallitVector(v1, tmp1->value, tmp1->index);
tmp1 = tmp1->next;
} tisztitVector(v1);
int meretVector(Vector vector) { Elem * tmp = vector.fej;
int count = 0;
while (tmp) { count++;
tmp = tmp->next;
} return count;
} int legutolsoVector(Vector vector) { Elem * tmp = vector.fej;
int dim = 0;
while (tmp) { dim = tmp->index;
tmp = tmp->next;
} return dim;
} int menuMutat() { int menu;
printf("Beallit: 1\n");
printf("Ertek: 2\n");
printf("Mindet torol: 3\n");
printf("Nem nullak szama: 4\n");
printf("Legutolso: 5\n");
printf("Megjelenit: 6\n");
printf("Rendez: 7\n");
printf("Hozzaad: 8\n");
printf("Szoroz: 9\n");
printf("Kilepes: 10\n");
scanf("%d", &menu);
return menu;
} int main() { Vector vector;
initVector(&vector);
Vector v2;
initVector(&v2);
beallitVector(&v2, 5, 2);
beallitVector(&v2, 1, 6);
beallitVector(&v2, 7, 10);
int menu;
do { menu = menuMutat();
if (menu == 1) { int index;
double ertek;
printf("Hanyadik elem? ");
scanf("%d", &index);
printf("Ertek? ");
scanf("%lg", &ertek);
beallitVector(&vector, ertek, index);
} if (menu == 2) { int index;
printf("Hanyadik elem? ");
scanf("%d", &index);
printf("A(z) %d. elem: %g\n\n", index, lekerdezVector(vector, index));
} if (menu == 3) { felszabaditVector(&vector);
} if (menu == 4) { printf("Nem nullak szama: %d\n\n", meretVector(vector));
} if (menu == 5) { printf("Legnagyobb nem nulla index: %d\n\n", legutolsoVector(vector));
} if (menu == 6) { mutatVector(vector);
} if (menu == 7) { rendezVector(vector);
} if (menu == 8) { addVector(&vector, v2);
} if (menu == 9) { printf("A skalaris szorzat: %lg\n", szorozVector(vector, v2));
} } while (menu != 10);
} felszabaditVector(&vector);
felszabaditVector(&v2);
return EXIT_SUCCESS;

3.49.1. Nemo kapitány alámerül a Nautilus tengeralattjáróval, hogy megvizsgálja a tenger élővilágát. Merülés közben a segédei minden tízedik méternél megszámolják, hogy mennyi halat látnak, hogy ezt felhasználhassák későbbi kutatásaikhoz. A számlálások eredményét egy vektorban tárolják el, ahol az i. komponens a 10*i méter mélyen végzett számlálás eredményét tárolja. Sajnos még nem áll rendelkezésre nagy memória kapacitású számítógép, az eredményeket lyukkártyára írják. Megfigyelték, hogy nagyon gyakran nem látnak egy halat sem, ezért úgy gondolták, oly módon tárolják az eredményeket, hogy ezt a tényt kihasználják és a ritka vektorok tárolási módszeréhez folyamodtak, így helyet takarítottak meg, és az adatok feldolgozása is gyorsabb. Írjon programot, amely egy ilyen ritka vektorokat kezel! A ritka vektorok olyan vektorok, amelyek nagyon kevés nem 0 komponenst tartalmaznak. Ezeket célszerű úgy tárolni, hogy csak a nem 0 elemeket tároljuk, azon vektoron belüli indexével. Ennek egyik módja, ha a (szám, index) párokat láncolt listában tároljuk. A vektor dimenziója nincs korlátozva. Valósítsa meg a következő műveleteket: · Beállít(index, érték): A vektor adott indexű elemét az adott értékre állítja be. Ha az érték 0, akkor az elem nem tárolódik. · Érték(index): A művelet visszaadja az adott indexű elem értékét. · Töröl: A művelet nulláza a teljes vektor tartalmát. · NemNullák: A művelet visszaadja, hogy mennyi nem 0 elem van a vektorban. · Legutolsó: A művelet visszaadja, hogy hányas indexen található a legutolsó nem 0 elem. · Megjelenít: A művelet kiírja a képernyőre a teljes vektort egészen a „Legutolsó” által meghatározott elemig. A 0-kat is meg kell jeleníteni. 
3.49.2. Előfordulhat, hogy az előző vektoron belül az elemek nem jó sorrendben követik egymást. Például lehet, hogy előbb található meg az 5-ös indexű elem a listában, mint a 3-as. Implementálja a „Rendez” műveletet, amely az indexeknek megfelelően növekvő sorrendbe rendezi a listán belüli elemeket! 
3.49.3. Bővítse ki az előző programot az összeadás és a szorzás műveletekkel! Az összeadás két ritka vektort ad össze. Ügyeljen arra, hogy a 0 elemeket ne tárolja el! A szorzás 2 ritka vektort szoroz össze skalárisan. 4. Láncolt listák feladatai 4.1. Lista két tömbbel

