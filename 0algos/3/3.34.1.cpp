3.34.1.
#include <stdio.h> #define FIRST_PLAYER 0 #define SECOND_PLAYER 1 #define TRUE 1 #define FALSE 0 #define SIGN1 'X' #define SIGN2 'O' #define SIZE 3 #define NUMTOWIN 3 typedef char TTable[SIZE][SIZE];
void InitTable(TTable T) { int i, j;
for (i = 0;
i < SIZE;
i++) for (j = 0;
j < SIZE;
j++) T[i][j] = ' ';
} void PrintTable(TTable T) { int i, j;
printf(" ");
for (i = 'A';
i < 'A' + SIZE;
i++) printf("%c ", i);
printf("\n");
printf(" -");
for (i = 0;
i < SIZE;
i++) printf("--");
printf("\n");
for (i = 0;
i < SIZE;
i++) { printf("%2d|", i + 1);
for (j = 0;
j < SIZE;
j++) printf("%c|", T[j][i]);
printf("\n ");
for (j = 0;
j < SIZE;
j++) printf("--");
printf("-\n");
} } int GetY(char y1, char y2) { return y2 > 0 ? (y1 - '0') * 10 + (y2 - '1') : y1 - '1' ;
} int Drawn(TTable T) { int i, j;
for (i = 0;
i < SIZE;
i++) for (j = 0;
j < SIZE;
j++) if (T[i][j] == ' ') return FALSE;
return TRUE;
} int Win(TTable T, char ch) { int i, j;
for (i = 0;
i < SIZE;
i++) { for (j = 0;
j < SIZE;
j++) { if (i <= SIZE - NUMTOWIN ) { if ((T[i][j] == ch) && (T[i+1][j] == ch) && (T[i+2][j] == ch)) return TRUE;
} if (j <= SIZE - NUMTOWIN ) { if ((T[i][j] == ch) && (T[i][j+1] == ch) && (T[i][j+2] == ch)) return TRUE;
} if ((i <= SIZE - NUMTOWIN ) && (j <= SIZE - NUMTOWIN )) { if ((T[i][j] == ch) && (T[i+1][j+1] == ch) && (T[i+2][j+2] == ch)) return TRUE;
} if ((i >= NUMTOWIN - 1 ) && (j <= SIZE - NUMTOWIN )) { if ((T[i][j] == ch) && (T[i-1][j+1] == ch) && (T[i-2][j+2] == ch)) return TRUE;
} } } return FALSE;
} int WrongCoord(TTable T, char x, char y1, char y2) { int y = GetY(y1, y2);
if ((x < 'A') || (x >= 'A' + SIZE ) || (y < 0) || (y >= SIZE)) { printf("Wrong coordinate!\n");
return TRUE;
} if (T[x - 'A'][y] != ' ') { printf("You already cannot choose this position!\n");
return TRUE;
} return FALSE;
} void Play(TTable T) { char target[5];
int player = FIRST_PLAYER;
do { if (player == FIRST_PLAYER) printf("First player\n");
else printf("Second player\n");
printf("Target: ");
do { scanf("%s", target);
} while ((target[0] != '0') && WrongCoord(T, target[0], target[1], target[2]));
if (target[0] != '0') { if (player == FIRST_PLAYER) { T[target[0] - 'A'][GetY(target[1], target[2])] = SIGN1;
if (Win(T, SIGN1)) { PrintTable(T);
printf("First player won!\n");
return;
} player = SECOND_PLAYER;
} else { T[target[0] - 'A'][GetY(target[1], target[2])] = SIGN2;
if (Win(T, SIGN2)) { PrintTable(T);
printf("Second player won!\n");
return;
} player = FIRST_PLAYER;
} PrintTable(T);
} } while ((target[0] != '0') && !Drawn(T));
printf("Game over!\n");
} int main() { TTable Table;
InitTable(Table);
} PrintTable(Table);
Play(Table);
return 0;

3.34.1. Írjon egy egyszerű amőba játékot, 3x3-as pályára! Két játékos játszhat a programmal, akik a saját jelüket helyezhetik a mezőkbe felváltva (X vagy O). Az a játékos nyeri a játszmát, akinek 3 jele lesz egy sorban, oszlopban vagy átlóban. Ha nincs több üres cella, vagy a játékosok valamelyike nyer, a játék véget ér. A programnak minden lépés után ki kell rajzolnia a játéktábla aktuális állását karakteresen! Feltételezzük, hogy mindkét játékos megfelelő pozíciót ad meg minden lépésben. Példa bemenet: A B C ------1| | | | ------2| | | | ------3| | | | ------First player Target: A1 A B C ------1|X| | | ------2| | | | ------3| | | | ------Second player Target: B1 A B C ------1|X|O| | ------2| | | | ------3| | | | ------- First player Target: A2 A B C ------1|X|O| | ------2|X| | | ------3| | | | ------Second player Target: A3 A B C ------1|X|O| | ------2|X| | | ------3|O| | | ------First player Target: B2 A B C ------1|X|O| | ------2|X|X| | ------3|O| | | ------- Second player Target: C1 A B C ------1|X|O|O| ------2|X|X| | ------3|O| | | ------First player Target: C3 A B C ------1|X|O|O| ------2|X|X| | ------3|O| |X| ------First player won! 3.35. Térkép
