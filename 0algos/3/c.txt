/* 3.1.1. K√©sz√≠ts√ºnk programot, amely bek√©r egy legfeljebb 6 karakter 
hossz√∫ sztringet √©s a karakteres k√©perny≈ën megjelen√≠ti azt √∫gy, hogy 
ki√≠rja az egyes karakterek √©rt√©keit, karakteresen √©s ASCII k√≥ddal 16-os 
sz√°mrendszerben, valamint ki√≠rja az egyes karakter v√°ltoz√≥knak a neveit √©s 
ezeknek a c√≠meit. √ñtlet mutat√≥k ki√≠r√°s√°hoz haszn√°lja a %p-t!  
*/

#include <iostream>
#include <iomanip>   // std::hex, std::setw
#include <string>

int main() {
    const int size = 6;
    char str[size + 1] = {};  // +1 a nulltermin√°tor miatt

    std::cout << "string = ";
    std::cin >> std::setw(size + 1) >> str; // maximum 6 karakter

    std::cout << "The string is: " << str << '\n';

    std::cout << "The static string address, str: " << static_cast<void*>(str) << '\n';
    std::cout << "The dynamic string address, &str: " << static_cast<void*>(&str) << '\n';

    std::cout << "\nCharacters: ";
    for (int i = 0; i < size; ++i) {
        std::cout << '\'' << str[i] << "' ";
    }

    std::cout << "\nASCII (hex): ";
    for (int i = 0; i < size; ++i) {
        if (str[i] == '\0') std::cout << "0x";
        std::cout << "0x" << std::hex << std::uppercase
                  << static_cast<int>(static_cast<unsigned char>(str[i])) << ' ';
    }

    std::cout << std::dec << "\nVariable names: ";
    for (int i = 0; i < size; ++i) {
        std::cout << "str[" << i << "] ";
    }

    std::cout << "\nAddresses: ";
    for (int i = 0; i < size; ++i) {
        std::cout << static_cast<void*>(&str[i]) << ' ';
    }

    std::cout << '\n';
    return 0;
}

/* c++11
3.1.2. Alak√≠tsa √°t a program ki√≠r√°s√°t √∫gy, hogy a bek√©rt sz√≥ 
f√ºgg≈ëlegesen jelenjen meg √©s a hozz√° tartoz√≥ ki√≠r√°sok az egyes 
karakterekt≈ël jobbra helyezkedjenek el! 

3.1.2.
*/


#include <iostream>
#include <iomanip>
#include <string>

int main() {
    const int size = 6;
    char str[size + 1] = {};  // +1 a null termin√°tor miatt

    std::cout << "string = ";
    std::cin >> std::setw(size + 1) >> str;

    std::cout << "\nThe string is: " << str << '\n';
    std::cout << "The static string address, str: " << static_cast<void*>(str) << '\n';
    std::cout << "The dynamic string address, &str: " << static_cast<void*>(&str) << "\n\n";

    for (int i = 0; i < size; ++i) {
        char ch = str[i];
        std::cout << "'" << ch << "'\t";

        // Hexadecim√°lis ASCII √©rt√©k
        std::cout << "0x" << std::hex << std::uppercase
                  << std::setw(2) << std::setfill('0')
                  << static_cast<int>(static_cast<unsigned char>(ch)) << std::dec;

        // Index √©s c√≠m
        std::cout << "\tstring[" << i << "]"
                  << "\t" << static_cast<void*>(&str[i]) << '\n';
    }

    return 0;
}
/*
3.2. Oszt√°s √©s marad√©kk√©pz√©s
3.2.1. T√°roljon k√©t t√∂mbben 5-5 eg√©sz sz√°mot, az oszt√≥kat √©s az 
osztand√≥kat! Az √©rt√©keket inicializ√°l√°ssal adja √°t a t√∂mb√∂knek, legyen 
k√∂zt√ºk negat√≠vok is! Tippelje meg az eg√©szoszt√°s √©s marad√©kk√©pz√©s 
eredm√©ny√©t! √çrja ki a helyes v√°laszt √©s sz√°molja, a helyes v√°laszok 
sz√°m√°t! √ñtlet: ellen≈ërizze, hogy a m√°sodik t√∂mbben ne legyen nulla! 
*/ 


#include <iostream>
#include <vector>

int main() {
    const int size = 5;
    std::vector<int> osztandok   = {10, -9, 0, 7, -12};  // op1
    std::vector<int> osztok      = {2, 3, -4, 5, -6};     // op2

    int valasz = 0;
    int pontszam = 0;

    for (int i = 0; i < size; ++i) {
        if (osztok[i] == 0) {
            std::cout << "Hiba: 0-val nem lehet osztani! (" << osztandok[i] << "/0 kihagyva)\n";
            continue;
        }

        // Eg√©sz oszt√°s tipp
        std::cout << osztandok[i] << " / " << osztok[i] << " = ";
        std::cin >> valasz;

        int helyes = osztandok[i] / osztok[i];
        std::cout << "Helyes v√°lasz: " << helyes << '\n';
        if (valasz == helyes) {
            ++pontszam;
        }

        // Marad√©kk√©pz√©s tipp
        std::cout << osztandok[i] << " % " << osztok[i] << " = ";
        std::cin >> valasz;

        helyes = osztandok[i] % osztok[i];
        std::cout << "Helyes v√°lasz: " << helyes << "\n\n";
        if (valasz == helyes) {
            ++pontszam;
        }
    }

    std::cout << "√ñsszesen " << pontszam << " pontot √©rt√©l el.\n";
    return 0;
}
// 3.2.2. Tov√°bbra is meg kell tippelni a megold√°st, de az operandusokat 
// gener√°lja v√©letlenszer≈±en -10 √©s 10 k√∂z√∂tt! V√©letlenszer≈±en d√∂ntse el 
// azt is, hogy eg√©sz vagy lebeg≈ëpontos oszt√°st v√©gez! Ut√≥bbin√°l f√ºggv√©nyt 
// kell haszn√°lni a marad√©kk√©pz√©sre. Lebeg≈ëpontos oszt√°sn√°l mindig √≠rja ki 
// a tizedes pontot az operandusokn√°l! 
// 3.2.2.

 #include <iostream>
#include <random>
#include <iomanip>

int main() {
    // Random engine √©s eloszl√°sok
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dist(-10, 10);
    std::uniform_int_distribution<> typeDist(0, 1); // 0 = int, 1 = float

    int A = dist(gen);
    int B;
    do {
        B = dist(gen); // biztosan ne legyen 0
    } while (B == 0);

    int type = typeDist(gen);

    if (type == 0) {
        // Eg√©sz oszt√°s
        std::cout << "Integer division:\n";
        std::cout << A << " / " << B << " = " << (A / B) << "\n";
    } else {
        // Lebeg≈ëpontos oszt√°s
        double result = static_cast<double>(A) / static_cast<double>(B);
        std::cout << "Floating point division:\n";
        std::cout << std::fixed << std::setprecision(4);
        std::cout << static_cast<double>(A) << " / " << static_cast<double>(B)
                  << " = " << result << "\n";
    }

    return 0;
}
// 3.3. Sztring konvert√°l√°s

// 3.3.1. K√©sz√≠tsen programot, amely statikus karaktert√∂mbben l√©v≈ë 4 sz√°mot 
// √°tkonvert√°l short int, int, float √©s double t√≠pusra! A sz√°mok √∂sszeg√©t 
// √≠rja be az eredeti t√∂mbbe! 
// 3.3.1.

#include <iostream>
#include <sstream>
#include <string>
#include <iomanip>

int main() {
    std::string input = "23 35678 1.2345e11 -9.8765432e-11";

    short shortIntValue;
    int intValue;
    float floatValue;
    double doubleValue;

    std::istringstream iss(input);
    iss >> shortIntValue >> intValue >> floatValue >> doubleValue;

    double sum = shortIntValue + intValue + floatValue + doubleValue;

    std::ostringstream oss;
    oss << std::fixed << std::setprecision(6) << sum;
    input = oss.str(); // vissza√≠rjuk az √∂sszeg sz√∂veg√©t az input stringbe

    std::cout << "The sum is " << input << std::endl;

    return 0;
}
// 3.3.2. A kezdeti sztringben 3 double t√≠pus√∫ sz√°m legyen, az els≈ët eggyel, a 
// m√°sodikat kett≈ëvel, a harmadikat h√°rommal n√∂velj√ºk meg! A megn√∂velt 
// √©rt√©keket egy √∫j t√∂mbbe √≠rjuk ki norm√°l alakban, 8 tizedes pontoss√°ggal 
// √©s el≈ëjellel! 

// 3.3.2.

#include <iostream>
#include <sstream>
#include <iomanip>
#include <vector>

int main() {
    std::string input = "48.1658745 -654686835454.321635432435421 9.8765432e-11";
    std::istringstream iss(input);

    std::vector<double> numbers(3);
    for (int i = 0; i < 3; ++i) {
        iss >> numbers[i];
        numbers[i] += (i + 1);
    }

    std::ostringstream oss;
    oss << std::showpos << std::fixed << std::setprecision(8);
    for (const auto& num : numbers) {
        oss << num << " ";
    }

    std::string output = oss.str();
    std::cout << "The new string is: " << output << '\n';

    return 0;
}

// 3.4. Sztring bek√©r√©s
// 3.4.1. K√©rjen be egy-egy sztringet gets, getchar √©s scanf seg√≠ts√©g√©vel! 
// √çrja ki a sztringeket puts, putchar √©s printf seg√≠ts√©g√©vel! 


#include <iostream>
#include <string>

int main() {
    std::string string1, string2, string3;
    char ch;

    std::cout << "String input with getchar-like (character by character).\n";
    std::cout << "Type something and press Enter (ends on newline):\n";

    // getchar alternat√≠v√°ja: karakterenk√©nt olvas√°s
    while (std::cin.get(ch) && ch != '\n') {
        string1 += ch;
    }

    std::cout << "String input with gets-like (getline): ";
    std::getline(std::cin, string2); // teljes sort beolvas

    std::cout << "String input with scanf-like (cin >>): ";
    std::cin >> string3; // sz√≥k√∂zig olvas

    std::cout << "\nstring1 with getchar = " << string1 << std::endl;
    std::cout << "string2 with gets = " << string2 << std::endl;
    std::cout << "string3 with scanf = " << string3 << std::endl;

    std::cout << "Press Enter to exit...";
    std::cin.ignore(); // elnyeli az utols√≥ sort√∂r√©st
    std::cin.get();    // v√°r Entert

    return 0;
}
// 3.4.2. Mi t√∂rt√©nik, ha a gets √©s a scanf r√©szeket felcser√©lj√ºk? 
// Hogyan kezelhet≈ë a helyzet? 

#include <iostream>
#include <string>
#include <limits>

int main() {
    std::string string2, string3;

    std::cout << "String input with scanf-like (cin >>): ";
    std::cin >> string3;

    // FONTOS: elfogyasztjuk a marad√©k sort√∂r√©st!
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    std::cout << "String input with gets-like (getline): ";
    std::getline(std::cin, string2);

    std::cout << "string3 (scanf style): " << string3 << "\n";
    std::cout << "string2 (gets style): " << string2 << "\n";

    return 0;
}
// 3.5.1. √çrjon programot, amelyben egy 5 hossz√∫ statikus float t√∂mb minden 
// elem√©be a hozz√°tartoz√≥ index gy√∂k√©t √≠rja be! Haszn√°ljon for ciklust az 
// egyes elemek el√©r√©s√©hez √©s az eredm√©ny ki√≠r√°s√°hoz! Az egyes √©rt√©kek 
// vessz≈ëvel legyenek elv√°lasztva! 
// 3.5.1


#include <iostream>
#include <array>
#include <cmath>
#include <iomanip>

int main() {
    std::array<float, 5> tomb;

    // 1. felt√∂lt√©s index gy√∂keivel
    for (size_t i = 0; i < tomb.size(); ++i) {
        tomb[i] = std::sqrt(static_cast<float>(i));
    }

    // 2. ki√≠r√°s vessz≈ëkkel
    std::cout << std::fixed << std::setprecision(4);
    for (size_t i = 0; i < tomb.size(); ++i) {
        std::cout << tomb[i];
        if (i < tomb.size() - 1)
            std::cout << ", ";
    }
    std::cout << std::endl;

    return 0;
}
// 3.5.2. Oldja meg, hogy az utols√≥ sz√°m ut√°n ne jelenjen meg vessz≈ë a 
// ki√≠r√°sn√°l √©s hogy a t√∂mb nagys√°g√°t szabadon lehessen meghat√°rozni! 
// 3.5.2.

#include <iostream>
#include <vector>
#include <cmath>
#include <iomanip>

int main() {
    int size;
    std::cout << "Size of array? ";
    std::cin >> size;

    std::vector<float> tomb(size);

    for (int i = 0; i < size; ++i) {
        tomb[i] = std::sqrt(static_cast<float>(i));
    }

    std::cout << std::fixed << std::setprecision(4);

    for (int i = 0; i < size; ++i) {
        std::cout << tomb[i];
        if (i != size - 1)
            std::cout << ", ";
    }
    std::cout << "\n";

    return 0;
}
// 3.6. T√∂mb reprezent√°l√°sa
// 3.6.1. A karakteres k√©perny≈ën reprezent√°ljon egy 4 hossz√∫ eg√©sz t√∂mb√∂t! 
// K√©rje be a t√∂mb elemeit √©s √≠rja ki az √©rt√©keket '*' szimb√≥lumokb√≥l 
// k√©sz√≠tett n√©gyzetekbe! Adja meg az egyes elemek indexeit √©s c√≠meit! √çrja 
// ki a t√∂mb mint mutat√≥ √©rt√©k√©t √©s annak a c√≠m√©t! 
// 3.6.1.


#include <iostream>
#include <iomanip>

int main() {
    const int size = 4;
    int tomb[size];

    // 1. √ârt√©kek bek√©r√©se
    for (int i = 0; i < size; ++i) {
        std::cout << "The " << i << ". value: ";
        std::cin >> tomb[i];
    }

    // 2. Fels≈ë csillagsor (keret)
    std::cout << std::setw(20) << " ";
    for (int i = 0; i < size; ++i) {
        std::cout << std::string(12, '*');
    }
    std::cout << "\n";

    // 3. √ârt√©kek sor keretben
    std::cout << std::setw(20) << " ";
    for (int i = 0; i < size; ++i) {
        std::cout << "*" << std::setw(10) << tomb[i] << "*";
    }
    std::cout << "\n";

    // 4. Als√≥ csillagsor (keret)
    std::cout << std::setw(20) << " ";
    for (int i = 0; i < size; ++i) {
        std::cout << std::string(12, '*');
    }
    std::cout << "\n";

    // 5. Indexek
    std::cout << std::setw(20) << "index: ";
    for (int i = 0; i < size; ++i) {
        std::cout << std::left << std::setw(13) << i;
    }
    std::cout << "\n";

    // 6. C√≠mek (elemek)
    std::cout << std::setw(20) << "address: ";
    for (int i = 0; i < size; ++i) {
        std::cout << std::left << std::setw(13) << static_cast<const void*>(&tomb[i]);
    }
    std::cout << "\n";

    // 7. A t√∂mb mutat√≥k√©nt √©s c√≠mk√©nt
    std::cout << std::setw(20) << "tomb: " << static_cast<const void*>(tomb) << "\n";
    std::cout << std::setw(20) << "&tomb: " << static_cast<const void*>(&tomb) << "\n";

    // 8. T√∂mb m√©rete
    std::cout << std::setw(20) << "tomb size: " << size << "\n";

    return 0;
}
// 3.6.2. Oldja meg ugyanezt a feladatot dinamikus t√∂mbre is!
//  Hol lesz elt√©r√©s? 

// ### ‚úÖ 3.6.2. feladat: Dinamikus t√∂mb√∂s v√°ltozat

// A C++11-es verzi√≥ **dinamikus t√∂mb√∂t** haszn√°l a statikus `int tomb[4]` helyett. A f≈ë elt√©r√©sek:

// | R√©sz                          | Statikus v√°ltozat             | Dinamikus v√°ltozat (`new`)        |
// | ----------------------------- | ----------------------------- | --------------------------------- |
// | T√∂mb deklar√°l√°sa              | `int tomb[size];`             | `int* tomb = new int[size];`      |
// | T√∂mbre mutat√≥ √©rt√©k (pointer) | `tomb`                        | `tomb`                            |
// | C√≠m lek√©r√©se                  | `&tomb` (t√∂mb eg√©sz√©nek c√≠me) | `&tomb` (a pointer v√°ltoz√≥ c√≠me!) |
// | Felszabad√≠t√°s sz√ºks√©ges?      | ‚ùå (automatikusan)             | ‚úÖ `delete[] tomb;`                |

// ---

// ### üßæ **C++11 megold√°s (dinamikus t√∂mbbel)**:


#include <iostream>
#include <iomanip>

int main() {
    const int size = 4;
    int* tomb = new int[size]; // dinamikus t√∂mb

    // 1. √ârt√©kek bek√©r√©se
    for (int i = 0; i < size; ++i) {
        std::cout << "The " << i << ". value: ";
        std::cin >> tomb[i];
    }

    // 2. Fels≈ë csillagsor (keret)
    std::cout << std::setw(20) << " ";
    for (int i = 0; i < size; ++i) {
        std::cout << std::string(12, '*');
    }
    std::cout << "\n";

    // 3. √ârt√©kek sor keretben
    std::cout << std::setw(20) << " ";
    for (int i = 0; i < size; ++i) {
        std::cout << "*" << std::setw(10) << tomb[i] << "*";
    }
    std::cout << "\n";

    // 4. Als√≥ csillagsor
    std::cout << std::setw(20) << " ";
    for (int i = 0; i < size; ++i) {
        std::cout << std::string(12, '*');
    }
    std::cout << "\n";

    // 5. Indexek
    std::cout << std::setw(20) << "index: ";
    for (int i = 0; i < size; ++i) {
        std::cout << std::left << std::setw(13) << i;
    }
    std::cout << "\n";

    // 6. C√≠mek
    std::cout << std::setw(20) << "address: ";
    for (int i = 0; i < size; ++i) {
        std::cout << std::left << std::setw(13) << static_cast<const void*>(&tomb[i]);
    }
    std::cout << "\n";

    // 7. Mutat√≥k√©nt √©s mutat√≥ v√°ltoz√≥k√©nt
    std::cout << std::setw(20) << "tomb: " << static_cast<const void*>(tomb) << "\n";
    std::cout << std::setw(20) << "&tomb: " << static_cast<const void*>(&tomb) << "\n";

    // 8. M√©ret
    std::cout << std::setw(20) << "tomb size: " << size << "\n";

    delete[] tomb; // ne felejtsd el!
    return 0;
}




// ### üß† Megjegyz√©s a k√ºl√∂nbs√©gekr≈ël

// * `tomb` **statikus esetben** a teljes t√∂mbre mutat, `&tomb` a t√∂mbre mint objektumra (t√≠pus: `int(*)[4]`).
// * `tomb` **dinamikus esetben** csak egy `int*` mutat√≥ az els≈ë elemre, `&tomb` az a pointer v√°ltoz√≥ c√≠me (t√≠pus: `int**` ha √©rtelmezz√ºk).
// * A c√≠mek k√∂z√∂tti k√ºl√∂nbs√©get n√©zd meg p√©ld√°ul a `static_cast<const void*>(...)` ki√≠r√°sban.

 // 3.7.1. Feladat: √çrjon programot, amelyben egy 10*10-es statikus, 
// inicializ√°lt, float √©rt√©keket tartalmaz√≥ m√°trix tengerszint feletti 
// magass√°g adatokat reprezent√°l! Adja meg a sz√°razf√∂ld √©s a tenger 
// ar√°ny√°t, ha a negat√≠v magass√°g tengerfeneket reprezent√°l! Adja meg a 
// legmagasabb pontot √©s adja meg a legmagasabb pontot a tengerben felt√©teles 
// maximum keres√©s seg√≠ts√©g√©vel! Azt az esetet is kezelni kell, amikor nincs 
// tenger! Sz√°molja ki a ter√ºlet √°tlagos magass√°g√°t! 
 
#include <iostream>
#include <array>
#include <iomanip>
#include <cfloat> // FLT_MAX

int main() {
    const int xSize = 10, ySize = 10;
    std::array<std::array<float, ySize>, xSize> matrix = {{
        {4, 5, 6, 4, 2, 3, 4, 2, 4, 2},
        {2, 2, 6, 5, 8, 7, 5, 3, 4, 2},
        {4, 3, 6, 2, 6, 3, 4, 6, 7, 2},
        {7, 2, 6, -2, -3, -3, -4, 6, 1, 2},
        {4, 1, 6, -7, -2, -3, -2, -8, 4, 2},
        {8, 1, 6, -7, -4, -3, -7, -6, -4, -2},
        {4, 3, 6, 7, 3, -3, -4, -8, -2, -2},
        {9, 2, 6, 6, 2, 2, -4, -8, -4, 2},
        {4, 3, 6, 8, 3, 2, 4, -6, 4, 2},
        {3, 3, 6, 7, 1, 3, 5, 6, 4, 2}
    }};

    int water = 0, land = 0;
    float sum = 0.0f;

    // Sz√°razf√∂ld / tenger ar√°ny √©s √∂sszeg
    for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
            float val = matrix[i][j];
            if (val < 0)
                ++water;
            else
                ++land;
            sum += val;
        }
    }

    std::cout << "The ratio of land to water is: " << land << ":" << water << "\n";

    // Legmagasabb pont
    int maxX = 0, maxY = 0;
    for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
            if (matrix[i][j] > matrix[maxX][maxY]) {
                maxX = i;
                maxY = j;
            }
        }
    }

    std::cout << "The highest point is at row: " << maxX
              << ", column: " << maxY
              << " and its height is: " << matrix[maxX][maxY] << "\n";

    // Legsek√©lyebb v√≠zpont
    float shallowMax = -FLT_MAX;
    int waterX = -1, waterY = -1;
    for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
            float val = matrix[i][j];
            if (val < 0 && val > shallowMax) {
                shallowMax = val;
                waterX = i;
                waterY = j;
            }
        }
    }

    if (waterX == -1) {
        std::cout << "There is no water so the search is meaningless.\n";
    } else {
        std::cout << "The most shallow water is at row: " << waterX
                  << ", column: " << waterY
                  << " and its depth is: " << shallowMax << "\n";
    }

    // √Åtlagos magass√°g
    float avg = sum / (xSize * ySize);
    std::cout << std::fixed << std::setprecision(4);
    std::cout << "The average height is: " << avg << "\n";

    return 0;
}

// 3.7.2. Hat√°rozza meg a legnagyobb szintk√ºl√∂nbs√©get a teljes ter√ºleten, 
// csak a sz√°razf√∂ld√∂n, csak a tengerben! 
// 3.7.2.


#include <iostream>
#include <array>
#include <iomanip>
#include <limits>

int main() {
    const int xSize = 10, ySize = 10;
    std::array<std::array<float, ySize>, xSize> matrix = {{
        {4, 5, 6, 4, 2, 3, 4, 2, 4, 2},
        {2, 2, 6, 5, 8, 7, 5, 3, 4, 2},
        {4, 3, 6, 2, 6, 3, 4, 6, 7, 2},
        {7, 2, 6, -2, -3, -3, -4, 6, 1, 2},
        {4, 1, 6, -7, -2, -3, -2, -8, 4, 2},
        {8, 1, 6, -7, -4, -3, -7, -6, -4, -2},
        {4, 3, 6, 7, 3, -3, -4, -8, -2, -2},
        {9, 2, 6, 6, 2, 2, -4, -8, -4, 2},
        {4, 3, 6, 8, 3, 2, 4, -6, 4, 2},
        {3, 3, 6, 7, 1, 3, 5, 6, 4, 2}
    }};

    float highestLand = std::numeric_limits<float>::lowest();
    float lowestLand = std::numeric_limits<float>::max();
    float shallowestWater = std::numeric_limits<float>::lowest();
    float deepestWater = std::numeric_limits<float>::max();

    bool hasLand = false, hasWater = false;

    // V√©gigmegy√ºnk a m√°trixon √©s friss√≠tj√ºk a min/max √©rt√©keket
    for (int i = 0; i < xSize; ++i) {
        for (int j = 0; j < ySize; ++j) {
            float val = matrix[i][j];
            if (val > 0) {
                hasLand = true;
                if (val > highestLand) highestLand = val;
                if (val < lowestLand)  lowestLand = val;
            } else {
                hasWater = true;
                if (val > shallowestWater) shallowestWater = val;
                if (val < deepestWater)    deepestWater = val;
            }
        }
    }

    std::cout << std::fixed << std::setprecision(4);

    if (hasLand)
        std::cout << "The level difference on land is: "
                  << (highestLand - lowestLand) << "\n";
    else
        std::cout << "There is no land.\n";

    if (hasWater)
        std::cout << "The level difference in water is: "
                  << (shallowestWater - deepestWater) << "\n";
    else
        std::cout << "There is no water.\n";

    if (hasLand && hasWater)
        std::cout << "The biggest global level difference is: "
                  << (highestLand - deepestWater) << "\n";
    else
        std::cout << "No global level difference can be computed.\n";

    return 0;
}

 // 3.8. Kockadob√°s
// 3.8.1. √çrjon programot, amely kockadob√°st szimul√°l v√©letlen sz√°mok 
// gener√°l√°s√°val! K√©rjen be egy sorozat hosszt, x-t, √©s addig gener√°ljon 
// v√©letlen sz√°mokat, am√≠g nem jelenik meg egym√°s ut√°n x darab hatos! H√°ny 
// dob√°s ut√°n kaptuk meg a k√≠v√°nt eredm√©nyt? Sz√°molja az egyes dob√°sok 
// gyakoris√°g√°t! 

// 3.8.1.

#include <iostream>
#include <vector>
#include <random>

int main() {
    int repeatRequired;
    std::cout << "How many consecutive 6s do you want: ";
    std::cin >> repeatRequired;

    if (repeatRequired <= 0) {
        std::cout << "Invalid input. Must be at least 1.\n";
        return 1;
    }

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dist(1, 6);

    std::vector<int> frequency(6, 0);
    int repeatAct = 0;
    int trial = 0;

    while (repeatAct != repeatRequired) {
        int num = dist(gen);
        frequency[num - 1]++;
        if (num == 6)
            repeatAct++;
        else
            repeatAct = 0;
        trial++;
    }

    std::cout << "It took " << trial << " rolls to get " 
              << repeatRequired << " consecutive 6s.\n\n";
    std::cout << "Roll frequencies:\n";
    for (int i = 0; i < 6; ++i) {
        std::cout << frequency[i] << " occurrences of " << (i + 1) << "\n";
    }

    return 0;
}

// 3.8.2. M√≥dos√≠tsa √∫gy az el≈ëz≈ë programot, hogy egy x √©rt√©kre 30-szor 
// fusson le a program! √Åtlagosan h√°ny dob√°s sz√ºks√©ges x darab egym√°st 
// k√∂vet≈ë hatoshoz? 
// 3.8.2.


#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <numeric> // for std::accumulate

int main() {
    int repeatRequired;
    std::cout << "How many consecutive 6s do you want: ";
    std::cin >> repeatRequired;

    const int NUM_RUNS = 30;
    std::vector<int> trials(NUM_RUNS);

    std::srand(static_cast<unsigned int>(std::time(nullptr)));

    for (int i = 0; i < NUM_RUNS; ++i) {
        int repeatCount = 0;
        int trial = 0;

        while (repeatCount < repeatRequired) {
            int roll = std::rand() % 6 + 1;
            trial++;
            if (roll == 6) {
                repeatCount++;
            } else {
                repeatCount = 0;
            }
        }

        trials[i] = trial;
    }

    int sum = std::accumulate(trials.begin(), trials.end(), 0);
    double average = static_cast<double>(sum) / NUM_RUNS;

    std::cout << "\nIt's needed on average " << average
              << " random number(s) to generate "
              << repeatRequired << " consecutive 6s.\n";

    return 0;
}
// 3.9. Cs√∫sztat√°s
// 3.9.1. √çrjon f√ºggv√©nyt, amely 3 c√≠m szerint √°tadott float param√©ter 
// √©rt√©k√©t (a, b √©s c) elcs√∫sztatja a k√∂vetkez≈ë m√≥don: ciklikus eltol√°s: 
// a ‚Üí b, b ‚Üí c, c ‚Üí a, nem ciklikus eltol√°s: a ‚Üí b, b ‚Üí c, 0 ‚Üí a! 
// Egy negyedik param√©ter jelezze, hogy az eltol√°s ciklikus-e! 
// 3.9.1.


#include <iostream>
#include <iomanip>

// Seg√©df√ºggv√©ny az √©rt√©kek ki√≠r√°s√°ra
void print(float a, float b, float c) {
    std::cout << std::fixed << std::setprecision(2);
    std::cout << "a=" << a << " b=" << b << " c=" << c << "\n";
}

// Cs√∫sztat√°s: cyclic==true eset√©n ciklikus, k√ºl√∂nben 0-t kap az els≈ë
void shift(float& a, float& b, float& c, bool cyclic) {
    float temp = c;
    c = b;
    b = a;
    if (cyclic) a = temp;
    else a = 0.0f;
}

int main() {
    float x1, x2, x3;

    std::cout << "Provide the next number: ";
    std::cin >> x1;
    std::cout << "Provide the next number: ";
    std::cin >> x2;
    std::cout << "Provide the next number: ";
    std::cin >> x3;

    std::cout << "\nOriginal: ";
    print(x1, x2, x3);

    shift(x1, x2, x3, true);
    std::cout << "After cyclic shift: ";
    print(x1, x2, x3);

    shift(x1, x2, x3, false);
    std::cout << "After non-cyclic shift: ";
    print(x1, x2, x3);

    return 0;
}
// 3.9.2. 3 v√°ltoz√≥ helyett egy 3 elem≈± t√∂mb√∂n v√©gezze el az 
// elcs√∫sztat√°st! 
// 3.9.2.

 
#include <iostream>
#include <array>

void print(const std::array<float, 3>& a) {
    for (size_t i = 0; i < a.size(); ++i)
        std::cout << "a[" << i << "] = " << a[i] << "  ";
    std::cout << "\n";
}

void shift(std::array<float, 3>& a, bool cyclic) {
    float temp = a[2];
    a[2] = a[1];
    a[1] = a[0];
    a[0] = cyclic ? temp : 0.0f;
}

int main() {
    std::array<float, 3> x;

    for (size_t i = 0; i < x.size(); ++i) {
        std::cout << "Provide the next number: ";
        std::cin >> x[i];
    }

    std::cout << "Original: ";
    print(x);

    shift(x, true);
    std::cout << "After cyclic shift: ";
    print(x);

    shift(x, false);
    std::cout << "After non-cyclic shift: ";
    print(x);

    return 0;
}
// 3.9.3. Egy plusz v√°ltoz√≥ jelezze, hogy melyik ir√°nyba t√∂rt√©nik a 
// cs√∫sztat√°s! A t√∂mb m√©rete legyen megadhat√≥! 
// 3.9.3.


#include <iostream>
#include <vector>
#include <string>
#include <iomanip>

void print(const std::vector<float>& a) {
    for (size_t i = 0; i < a.size(); ++i) {
        std::cout << "myArray[" << i << "] = " << a[i] << "  ";
    }
    std::cout << "\n";
}

void shift(std::vector<float>& a, char direction, bool cyclic) {
    int size = a.size();
    if (size == 0) return;

    float temp = (direction == 'r') ? a[size - 1] : a[0];

    if (direction == 'r') {
        for (int i = size - 1; i > 0; --i) {
            a[i] = a[i - 1];
        }
        a[0] = cyclic ? temp : 0.0f;
    } else if (direction == 'l') {
        for (int i = 0; i < size - 1; ++i) {
            a[i] = a[i + 1];
        }
        a[size - 1] = cyclic ? temp : 0.0f;
    } else {
        std::cerr << "Invalid direction. Use 'l' or 'r'.\n";
    }
}

int main() {
    int size;
    std::cout << "Array size? ";
    std::cin >> size;

    if (size <= 0) {
        std::cerr << "Size must be positive.\n";
        return 1;
    }

    std::vector<float> myArray(size);
    for (int i = 0; i < size; ++i) {
        std::cout << "Provide the next number: ";
        std::cin >> myArray[i];
    }

    std::cin.ignore(); // flush newline after number input

    std::cout << "Original array:\n";
    print(myArray);

    char direction;
    std::cout << "In which direction do you want to shift? (l/r): ";
    std::cin >> direction;

    // Ciklikus eltol√°s
    shift(myArray, direction, true);
    std::cout << "After cyclic shift:\n";
    print(myArray);

    // Nem ciklikus eltol√°s
    shift(myArray, direction, false);
    std::cout << "After non-cyclic shift:\n";
    print(myArray);

    return 0;
}
// 3.10. M≈±veletek t√∂mb√∂k√∂n
//3.10.1. √çrjon f√ºggv√©nyeket a k√∂vetkez≈ë feladatokra: hat√°rozza meg egy 
// t√∂mbben l√©v≈ë elemek √∂sszeg√©t, √°tlag√°t, minimum√°t, hogy egy adott elem 
// szerepel-e benne! Egy f√°jlban legyen a main f√ºggv√©ny √©s egy m√°sikban a 
// t√∂bbi f√ºggv√©ny! 



// inc.hpp

 
#ifndef INC_HPP_
#define INC_HPP_

// Print the array elements in [a0, a1, ‚Ä¶, aN-1] format
void print(const double* arr, int size);

// Return the sum of all elements
double sum(const double* arr, int size);

// Return the average of all elements (assumes size > 0)
double avg(const double* arr, int size);

// Return the index of the minimum element (assumes size > 0)
int minIndex(const double* arr, int size);

// Return true if value is found in the array
bool searchFor(const double* arr, int size, double value);

#endif // INC_HPP_
 
//functions.cpp


// #include "inc.hpp"
#include <iostream>

// Print the array as [e0, e1, ‚Ä¶, eN-1]
void print(const double* arr, int size) {
    std::cout << "[";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i];
        if (i + 1 < size) 
            std::cout << ", ";
    }
    std::cout << "]";
}

double sum(const double* arr, int size) {
    double s = 0.0;
    for (int i = 0; i < size; ++i) {
        s += arr[i];
    }
    return s;
}

double avg(const double* arr, int size) {
    return sum(arr, size) / size;
}

int minIndex(const double* arr, int size) {
    int mi = 0;
    for (int i = 1; i < size; ++i) {
        if (arr[i] < arr[mi]) {
            mi = i;
        }
    }
    return mi;
}

bool searchFor(const double* arr, int size, double value) {
    for (int i = 0; i < size; ++i) {
        if (arr[i] == value) {
            return true;
        }
    }
    return false;
}

// main.cpp
 

// #include "inc.hpp"
#include <iostream>

int main() {
    // sample data
    double myArray[] = { 12.0, 56.0, -7.0 };
    int size = sizeof(myArray) / sizeof(myArray[0]);
    double what = -8.0;

    std::cout << "Array: ";
    print(myArray, size);

    double s = sum(myArray, size);
    double a = avg(myArray, size);
    std::cout << "\nSum: " << s
              << ", Average: " << a << "\n";

    int idx = minIndex(myArray, size);
    std::cout << "Minimum at index " << idx
              << " ‚Üí value " << myArray[idx] << "\n";

    if (searchFor(myArray, size, what)) {
        std::cout << what << " is found.\n";
    } else {
        std::cout << what << " is not found.\n";
    }

    return 0;
}
 // 3.10.2. Eg√©sz√≠tse ki az el≈ëz≈ë programot a k√∂vetkez≈ë feladatokat 
// ell√°t√≥ f√ºggv√©nyekkel! Maxim√°lis eleme index√©nek a meghat√°roz√°sa, 
// sz√≥r√°s kisz√°m√≠t√°sa, k√©t t√∂mb elemeinek a felcser√©l√©se! 

 

// function.hpp


#ifndef FUNCTION_HPP
#define FUNCTION_HPP

// Print array elements as [e0, e1, ‚Ä¶, eN-1]
void print(const double* arr, int size);

// Sum of elements
double sum(const double* arr, int size);

// Average of elements (size > 0)
double avg(const double* arr, int size);

// Index of minimum element (size > 0)
int minIndex(const double* arr, int size);

// Index of maximum element (size > 0)
int maxIndex(const double* arr, int size);

// Population standard deviation: sqrt( Œ£(xi‚ÄìŒº)¬≤ / N )
double stdDev(const double* arr, int size);

// Swap the contents of arr1 and arr2 (both length size)
void change(double* arr1, double* arr2, int size);

// Return true if value exists in arr
bool searchFor(const double* arr, int size, double value);

#endif // FUNCTION_HPP


// functions.cpp


// #include "function.hpp"
#include <iostream>
#include <cmath>

void print(const double* arr, int size) {
    std::cout << "[";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i];
        if (i + 1 < size) std::cout << ", ";
    }
    std::cout << "]";
}

double sum(const double* arr, int size) {
    double s = 0.0;
    for (int i = 0; i < size; ++i) {
        s += arr[i];
    }
    return s;
}

double avg(const double* arr, int size) {
    return sum(arr, size) / size;
}

int minIndex(const double* arr, int size) {
    int mi = 0;
    for (int i = 1; i < size; ++i) {
        if (arr[i] < arr[mi]) mi = i;
    }
    return mi;
}

int maxIndex(const double* arr, int size) {
    int ma = 0;
    for (int i = 1; i < size; ++i) {
        if (arr[i] > arr[ma]) ma = i;
    }
    return ma;
}

double stdDev(const double* arr, int size) {
    double mean = avg(arr, size);
    double sumSq = 0.0;
    for (int i = 0; i < size; ++i) {
        double diff = arr[i] - mean;
        sumSq += diff * diff;
    }
    return std::sqrt(sumSq / size);
}

void change(double* arr1, double* arr2, int size) {
    for (int i = 0; i < size; ++i) {
        double tmp   = arr1[i];
        arr1[i]      = arr2[i];
        arr2[i]      = tmp;
    }
}

bool searchFor(const double* arr, int size, double value) {
    for (int i = 0; i < size; ++i) {
        if (arr[i] == value) return true;
    }
    return false;
}

// main.cpp


// #include "function.hpp"
#include <iostream>
#include <iomanip>

int main() {
    double A[] = { 12.0, 56.0, -7.0 };
    double B[] = { 24.0, -26.0,  4.0 };
    int size   = sizeof(A) / sizeof(A[0]);
    double what = -8.0;

    std::cout << "Array A: "; print(A, size); 
    std::cout << "\nArray B: "; print(B, size);
    
    double s  = sum(A, size);
    double m  = avg(A, size);
    int    iMin = minIndex(A, size);
    int    iMax = maxIndex(A, size);
    double sd = stdDev(A, size);
    
    std::cout << "\n\n-- Statistics for A --\n"
              << "Sum:       " << s  << "\n"
              << "Average:   " << m  << "\n"
              << "Min index: " << iMin 
                 << " (value " << A[iMin] << ")\n"
              << "Max index: " << iMax
                 << " (value " << A[iMax] << ")\n"
              << "Std Dev:   " << std::fixed << std::setprecision(4) << sd << 
"\n";

    std::cout << "\n-- Swapping A and B --\n";
    change(A, B, size);
    std::cout << "A: "; print(A, size);
    std::cout << "\nB: "; print(B, size);

    std::cout << "\n\n-- Search --\n";
    if (searchFor(A, size, what))
        std::cout << what << " is in A\n";
    else
        std::cout << what << " is NOT in A\n";

    return 0;
}
 // 3.10.3. Eg√©sz√≠tse ki az el≈ëz≈ë programot a k√∂vetkez≈ë feladatokat 
// ell√°t√≥ f√ºggv√©nyekkel! Adott elem els≈ë el≈ëfordul√°s√°nak meghat√°roz√°sa, 
// utols√≥ el≈ëfordul√°s√°nak meghat√°roz√°sa, k√©t t√∂mb k√∂z√∂tt az 
// alapm≈±veletek elv√©gz√©se az azonos index≈± elemek k√∂z√∂tt, skal√°ris szorzat 
// meghat√°roz√°sa.  


// function.hpp


#ifndef FUNCTION_HPP
#define FUNCTION_HPP

// Print array elements as [e0, e1, ‚Ä¶, eN-1]
void print(const double* arr, int size);

// Sum of elements
double sum(const double* arr, int size);

// Average of elements (size > 0)
double avg(const double* arr, int size);

// Index of minimum element (size > 0)
int minIndex(const double* arr, int size);

// Index of maximum element (size > 0)
int maxIndex(const double* arr, int size);

// Swap the contents of a1 and a2 (both length size)
void change(double* a1, double* a2, int size);

// Element-wise basic operations (+, ‚Äì, *, /) between a1 and a2, printed to stdout
void elementWiseOps(const double* a1, const double* a2, int size);

// Scalar (dot) product of a1 and a2
double dotProduct(const double* a1, const double* a2, int size);

// First occurrence of value in arr, or ‚Äì1 if not found
int firstOccurrence(const double* arr, int size, double value);

// Last occurrence of value in arr, or ‚Äì1 if not found
int lastOccurrence(const double* arr, int size, double value);

// Returns true if value is found in arr
bool searchFor(const double* arr, int size, double value);

#endif // FUNCTION_HPP

// functions.cpp


// #include "function.hpp"
#include <iostream>
#include <cmath>

// Print array as [e0, e1, ‚Ä¶]
void print(const double* arr, int size) {
    std::cout << "[";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i];
        if (i + 1 < size) std::cout << ", ";
    }
    std::cout << "]";
}

double sum(const double* arr, int size) {
    double s = 0.0;
    for (int i = 0; i < size; ++i) {
        s += arr[i];
    }
    return s;
}

double avg(const double* arr, int size) {
    return sum(arr, size) / size;
}

int minIndex(const double* arr, int size) {
    int mi = 0;
    for (int i = 1; i < size; ++i) {
        if (arr[i] < arr[mi]) mi = i;
    }
    return mi;
}

int maxIndex(const double* arr, int size) {
    int ma = 0;
    for (int i = 1; i < size; ++i) {
        if (arr[i] > arr[ma]) ma = i;
    }
    return ma;
}

void change(double* a1, double* a2, int size) {
    for (int i = 0; i < size; ++i) {
        double tmp = a1[i];
        a1[i] = a2[i];
        a2[i] = tmp;
    }
}

void elementWiseOps(const double* a1, const double* a2, int size) {
    std::cout << "\nElement-wise operations:\n";
    for (int i = 0; i < size; ++i) {
        std::cout << "Index " << i << ":\n";
        std::cout << "  " << a1[i] << " + " << a2[i]
                  << " = " << (a1[i] + a2[i]) << "\n";
        std::cout << "  " << a1[i] << " - " << a2[i]
                  << " = " << (a1[i] - a2[i]) << "\n";
        std::cout << "  " << a1[i] << " * " << a2[i]
                  << " = " << (a1[i] * a2[i]) << "\n";
        std::cout << "  " << a1[i] << " / " << a2[i]
                  << " = " << (a1[i] / a2[i]) << "\n";
    }
}

double dotProduct(const double* a1, const double* a2, int size) {
    double dot = 0.0;
    for (int i = 0; i < size; ++i) {
        dot += a1[i] * a2[i];
    }
    return dot;
}

int firstOccurrence(const double* arr, int size, double value) {
    for (int i = 0; i < size; ++i) {
        if (arr[i] == value) return i;
    }
    return -1;
}

int lastOccurrence(const double* arr, int size, double value) {
    for (int i = size - 1; i >= 0; --i) {
        if (arr[i] == value) return i;
    }
    return -1;
}

bool searchFor(const double* arr, int size, double value) {
    return firstOccurrence(arr, size, value) != -1;
}

// main.cpp

// #include "function.hpp"
#include <iostream>
#include <iomanip>

int main() {
    double A[]     = { 12.0, 56.0, -7.0, 56.0 };
    double B[]     = { 24.0, -26.0, 4.0,  19.0 };
    int    size    = sizeof(A) / sizeof(A[0]);
    double what1   = -8.0;
    double what2   = 56.0;

    std::cout << "Array A: "; print(A, size);
    std::cout << "\nArray B: "; print(B, size);

    // basic stats on A
    double s       = sum(A, size);
    double m       = avg(A, size);
    int    iMin    = minIndex(A, size);
    int    iMax    = maxIndex(A, size);

    std::cout << "\n\n-- Statistics for A --\n"
              << "Sum:     " << s << "\n"
              << "Average: " << m << "\n"
              << "Min idx: " << iMin
              << " (value " << A[iMin] << ")\n"
              << "Max idx: " << iMax
              << " (value " << A[iMax] << ")\n";

    // presence test
    std::cout << "\n-- Search for " << what1 << " in A --\n";
    if (searchFor(A, size, what1))
        std::cout << what1 << " is found in A\n";
    else
        std::cout << what1 << " is NOT found in A\n";

    // swap A and B
    std::cout << "\n-- Swap A and B --\n";
    change(A, B, size);
    std::cout << "A: "; print(A, size);
    std::cout << "\nB: "; print(B, size);

    // element-wise ops
    elementWiseOps(A, B, size);

    // dot product
    double dot = dotProduct(A, B, size);
    std::cout << "\n\nDot product: " << dot << "\n";

    // first & last occurrence in B
    int firstIdx = firstOccurrence(B, size, what2);
    int lastIdx  = lastOccurrence(B, size, what2);
    std::cout << "\n-- Occurrences of " << what2 << " in B --\n";
    if (firstIdx != -1) {
        std::cout << "First at index " << firstIdx
                  << ", last at index " << lastIdx << "\n";
    } else {
        std::cout << what2 << " not found in B\n";
    }

    return 0;
}
// 3.11.1. √çrjon programot, amely egy sz√∂veg minden negyedik karakter√©t 
// kihagyja, ha az nem white space! inicializ√°lja √∫gy a sztringet, hogy abban 
// t√∂bb sor legyen √©s ezek a sorok a program k√≥dban is sorokban legyenek 
// (k√ºl√∂n id√©z≈ëjel p√°rok felhaszn√°l√°s√°val)! A n√©ggyel val√≥ 
// oszthat√≥s√°got k√ºl√∂n f√ºggv√©nnyel val√≥s√≠tsa meg! 
// 3.11.1.


#include <iostream>
#include <string>
#include <cctype>

// Ellen≈ërzi, hogy a sz√°m oszthat√≥-e 4-gyel
bool divisibleBy4(int num) {
    return num % 4 == 0;
}

int main() {
    std::string s = 
        "The project will scale up to 1,200 marine sites,\n"
        "including different conditions such as surface waters,\n"
        "waters near methane emissions from the sea floor, and deep-sea sediments.";

    int visibleCharIndex = 0; // csak nem-whitespace karakterek indexel√©s√©re

    for (size_t i = 0; i < s.length(); ++i) {
        char c = s[i];
        if (std::isspace(static_cast<unsigned char>(c))) {
            std::cout << c; // whitespace-eket mindig ki√≠rjuk
        } else {
            if (!divisibleBy4(visibleCharIndex)) {
                std::cout << c;
            }
            ++visibleCharIndex; // csak nem-whitespace-ekre n√∂velj√ºk
        }
    }

    return 0;
}
// 3.11.2. M√≥dos√≠tsa √∫gy a programot, hogy a mag√°nhangz√≥kat hagyja ki, de 
// csak akkor, ha nem egy sz√≥ elej√©n vannak! 
// 3.11.2.

 #include <iostream>
#include <string>
#include <cctype>
#include <set>

// Seg√©df√ºggv√©ny: eld√∂nti, hogy a karakter mag√°nhangz√≥-e (angol)
bool isVowel(char c) {
    static const std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};
    return vowels.count(std::tolower(static_cast<unsigned char>(c))) > 0;
}

int main() {
    std::string text =
        "The project will scale up to 1,200 marine sites,\n"
        "including different conditions such as surface waters,\n"
        "waters near methane emissions from the sea floor, and "
        "deep sea sediments.";

    bool atWordStart = true;

    for (size_t i = 0; i < text.length(); ++i) {
        char c = text[i];

        if (std::isspace(static_cast<unsigned char>(c)) || std::ispunct(static_cast<unsigned char>(c))) {
            atWordStart = true;
            std::cout << c; // minden sz√≥k√∂z √©s √≠r√°sjel v√°ltozatlanul kimegy
        } else {
            if (isVowel(c) && !atWordStart) {
                // nem √≠rjuk ki a nem sz√≥beli mag√°nhangz√≥t
            } else {
                std::cout << c;
            }
            atWordStart = false;
        }
    }

    return 0;
}
// 3.12.1. K√©sz√≠tsen mag√°nhangz√≥ statisztik√°t egy bek√©rt sorr√≥l! A 
// mag√°nhangz√≥ kis √©s nagy bet≈±s alakj√°t nem k√ºl√∂nb√∂ztetj√ºk meg, csak az 
// angol mag√°nhangz√≥kat tekintj√ºk. 
// 3.12.1.


#include <iostream>
#include <string>
#include <cctype>
#include <map>

int main() {
    std::string line;
    std::cout << "text=\n";
    std::getline(std::cin, line);

    std::map<char, int> vowelCount = {
        {'A', 0}, {'E', 0}, {'I', 0}, {'O', 0}, {'U', 0}
    };

    for (char ch : line) {
        char upper = std::toupper(static_cast<unsigned char>(ch));
        if (vowelCount.count(upper)) {
            vowelCount[upper]++;
        }
    }

    std::cout << "\nVowel statistics:\n";
    for (const auto& pair : vowelCount) {
        std::cout << " " << static_cast<char>(std::tolower(pair.first)) << "," << pair.first << ": " << pair.second << "\n";
    }

    return 0;
}
// 3.12.2. K√©sz√≠tsen statisztik√°t egy sz√∂vegben l√©v≈ë szavak √©s mondatok 
// sz√°m√°r√≥l! 
// 3.12.2.


#include <iostream>
#include <string>

int main() {
    std::string text;
    std::cout << "Text: ";
    std::getline(std::cin, text);

    int sentence = 0;
    int word = 0;
    bool inWord = false;

    for (char c : text) {
        if (std::isspace(static_cast<unsigned char>(c))) {
            if (inWord) {
                word++;
                inWord = false;
            }
        } else {
            inWord = true;
        }

        if (c == '.' || c == '!' || c == '?') {
            sentence++;
        }
    }

    // If the last character was part of a word
    if (inWord) {
        word++;
    }

    std::cout << "\nText statistics:\n";
    std::cout << "Words: " << word << "\n";
    std::cout << "Sentences: " << sentence << "\n";

    return 0;
}
// 3.13. K√≥dolt besz√©d
// 3.13.1. √çrja meg a ‚Äûtuvudsz ivigy beveszevelnivi‚Äù programot! A kimenet 
// csupa nagybet≈± legyen! √≠rja meg azt a f√ºggv√©nyt, amely eld√∂nti, hogy egy 
// bet≈± mag√°nhangz√≥-e! 
// 3.13.1.


#include <iostream>
#include <string>
#include <cctype>
#include <algorithm>

bool isVowel(char c) {
    static const std::string vowels = "AEIOU";
    return vowels.find(c) != std::string::npos;
}

std::string convertToTuvudsz(const std::string& sentence) {
    std::string result;
    for (char ch : sentence) {
        char upper = std::toupper(ch);
        result += upper;
        if (isVowel(upper)) {
            result += 'V';
            result += upper;
        }
    }
    return result;
}

int main() {
    std::string input;
    std::cout << "sentence = \n";
    std::getline(std::cin, input);

    std::string transformed = convertToTuvudsz(input);
    std::cout << transformed << "\n";

    return 0;
}
// 3.13.2. B≈ëv√≠tse √∫gy a programot, hogy az √∫j sztring egy megfelel≈ëen 
// hossz√∫ dinamikus t√∂mbbe ker√ºlj√∂n! K√©sz√≠tse el a visszafele k√≥dol√≥ 
// f√ºggv√©nyt! 

// 3.13.2.


#include <iostream>
#include <string>
#include <cctype>
#include <memory>

int main() {
    std::string original;
    std::cout << "Sentence: ";
    std::getline(std::cin, original);

    size_t len = original.length();
    // Dinamikus t√∂mb a feldolgozott karakterekhez (+1 a null termin√°tor miatt)
    std::unique_ptr<char[]> newVer(new char[len + 1]);

    size_t idxJ = 0;
    for (size_t idxI = 0; idxI < len; ++idxI) {
        char current = std::toupper(original[idxI]);

        if (current != 'V') {
            newVer[idxJ++] = current;
        } else {
            if (idxI + 2 < len &&
                std::toupper(original[idxI]) == std::toupper(original[idxI + 2])) {
                newVer[idxJ++] = std::toupper(original[idxI++]);
                newVer[idxJ++] = std::toupper(original[idxI++]);
                idxI++; // skip 3rd (visszafele k√≥dolt karakter)
            } else {
                // csak kihagyjuk a V-t
            }
        }
    }

    newVer[idxJ] = '\0'; // null-termin√°tor

    std::cout << newVer.get() << std::endl;

    return 0;
}
// 3.14. Sztring kivon√°s
// 3.14.1. √çrjon programot, amely egy sztringb≈ël kivon egy m√°sikat! 
// P√©ld√°ul: almafavir√°g - fa = almavir√°g. Ha a m√°sodik param√©ter nincs az 
// els≈ëben, akkor ne v√°ltozzon az els≈ë param√©ter √©r√©tke! 
// 3.14.1.

#include <iostream>
#include <string>

// kivon√°s f√ºggv√©ny
void subtract(std::string& from, const std::string& what) {
    size_t pos = from.find(what);
    if (pos != std::string::npos) {
        from.erase(pos, what.length());
    }
}

int main() {
    std::string from, what;

    std::cout << "Subtract from: ";
    std::cin >> from;

    std::cout << "Subtract what: ";
    std::cin >> what;

    subtract(from, what);

    std::cout << "\nThe reduced word is: " << from << "\n";

    return 0;
}

// 3.14.2. M√≥dos√≠tsa √∫gy a programot, hogy a m√°sodik sztring minden 
// el≈ëfordul√°s√°t kiveszi az els≈ëb≈ël! 
// 3.14.2.



#include <iostream>
#include <string>

void substractAll(std::string& from, const std::string& what) {
    size_t pos;
    while ((pos = from.find(what)) != std::string::npos) {
        from.erase(pos, what.length());
    }
}

int main() {
    std::string from, what;

    std::cout << "Substract from = ";
    std::cin >> from;

    std::cout << "Substract what = ";
    std::cin >> what;

    substractAll(from, what);

    std::cout << "\nThe reduced word is: " << from << "\n";

    return 0;
}
// 3.15. Kisbet≈± - nagybet≈±

// 3.15.1. √çrjon programot, amely bek√©rt mondatot form√°z adott v√°laszt√°s 
// szerint! Men√ºb≈ël v√°laszthat√≥ak a k√∂vetkez≈ë lehet≈ës√©gek: UPPER CASE 
// (mindent nagybet≈±re), lower case (mindent kisbet≈±re), tOGGLE CASE (kis 
// bet≈±ket nagyra √©s nagyokat kicsire), Sentense case (a sor els≈ë bet≈±je nagy 
// csak), Title Case (minden sz√≥kezd≈ë bet≈± nagy). Mind a konvert√°l√°sok, mind 
// a men√º f√ºggv√©nnyel legyen megoldva! 
// 3.15.1.

#include <iostream>
#include <string>
#include <cctype>
#include <sstream>

// UPPER CASE
std::string toUpperCase(const std::string& input) {
    std::string result = input;
    for (char& c : result)
        c = std::toupper(c);
    return result;
}

// lower case
std::string toLowerCase(const std::string& input) {
    std::string result = input;
    for (char& c : result)
        c = std::tolower(c);
    return result;
}

// tOGGLE CASE
std::string toggleCase(const std::string& input) {
    std::string result = input;
    for (char& c : result) {
        if (std::islower(c)) c = std::toupper(c);
        else if (std::isupper(c)) c = std::tolower(c);
    }
    return result;
}

// Sentence case
std::string sentenceCase(const std::string& input) {
    std::string result = toLowerCase(input);
    for (size_t i = 0; i < result.size(); ++i) {
        if (!std::isspace(result[i])) {
            result[i] = std::toupper(result[i]);
            break;
        }
    }
    return result;
}

// Title Case
std::string titleCase(const std::string& input) {
    std::string result = toLowerCase(input);
    bool newWord = true;
    for (char& c : result) {
        if (std::isspace(c)) {
            newWord = true;
        } else if (newWord) {
            c = std::toupper(c);
            newWord = false;
        }
    }
    return result;
}

int menu() {
    int choice;
    std::cout << "1. UPPER CASE\n";
    std::cout << "2. lower case\n";
    std::cout << "3. tOGGLE CASE\n";
    std::cout << "4. Sentence case\n";
    std::cout << "5. Title Case\n";
    std::cout << "Select an option: ";
    std::cin >> choice;
    std::cin.ignore(); // remove leftover newline
    return choice;
}

int main() {
    std::string myString;
    std::cout << "Original string: ";
    std::getline(std::cin, myString);

    int choice = menu();

    std::string result;
    switch (choice) {
        case 1: result = toUpperCase(myString); break;
        case 2: result = toLowerCase(myString); break;
        case 3: result = toggleCase(myString); break;
        case 4: result = sentenceCase(myString); break;
        case 5: result = titleCase(myString); break;
        default: std::cout << "Invalid choice.\n"; return 1;
    }

    std::cout << "\nResult: \"" << result << "\"\n";
    return 0;
}

// 3.15.2. Val√≥s√≠tsa meg a ‚ÄûNice Title Case‚Äù form√°z√°st! A szavak els≈ë 
// bet≈±je nagy kiv√©ve az al√°bbi szavak eset√©n: and, of, the, a, an, from, for, 
// in. A kiv√©telt nem kell figyelembe venni a sor els≈ë karakter√©n√©l √©s egy 
// kett≈ës pont ut√°n. P√©ld√°ul: ‚ÄûThe Life of an English Man and the War‚Äù 
// 3.15.2.


#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <set>
#include <cctype>
#include <algorithm>

std::string toLower(const std::string& str) {
    std::string res = str;
    std::transform(res.begin(), res.end(), res.begin(), ::tolower);
    return res;
}

std::string toTitleCaseWord(const std::string& word) {
    if (word.empty()) return word;
    std::string result = toLower(word);
    result[0] = std::toupper(result[0]);
    return result;
}

std::string niceTitleCase(const std::string& input) {
    std::set<std::string> exceptions = {"and", "of", "the", "a", "an", "from", "for", "in"};

    std::istringstream iss(input);
    std::vector<std::string> words;
    std::string word;
    char prevEnd = '\0'; // store previous punctuation (for colon detection)
    bool forceCapitalize = true;

    while (iss >> word) {
        std::string cleanWord = toLower(word);

        // Remove trailing punctuation for colon detection
        char lastChar = word.back();
        bool endsWithColon = (lastChar == ':');
        if (endsWithColon) cleanWord = cleanWord.substr(0, cleanWord.size() - 1);

        if (forceCapitalize || exceptions.find(cleanWord) == exceptions.end()) {
            word = toTitleCaseWord(cleanWord);
        } else {
            word = toLower(cleanWord);
        }

        if (endsWithColon) word += ":";

        words.push_back(word);
        forceCapitalize = endsWithColon; // reset flag if colon
        prevEnd = lastChar;
    }

    // Join back into sentence
    std::ostringstream oss;
    for (size_t i = 0; i < words.size(); ++i) {
        if (i > 0) oss << " ";
        oss << words[i];
    }

    return oss.str();
}

int main() {
    std::string input;
    std::cout << "Original string: ";
    std::getline(std::cin, input);

    std::string result = niceTitleCase(input);

    std::cout << "\nResult: \"" << result << "\"\n";
    return 0;
}
// 3.16. T√∂mbn√∂vel√©s

// 3.16.1. √çrjon programot, amely bek√©ri egy t√∂mb m√©ret√©t, lefoglalja a 
// helyet a t√∂mb sz√°m√°ra √©s felt√∂lti elemekkel! N√∂velje meg a t√∂mb 
// m√©ret√©t dupl√°j√°ra √∫gy, hogy l√©trehoz egy √∫j t√∂mb√∂t, √©s belem√°solja a 
// r√©gi t√∂mb√∂t! T√∂ltse fel a marad√©k helyet is √∫j √©rt√©kekkel! 
// 3.16.1.


#include <iostream>
#include <vector>
#include <iomanip>

int main() {
    int size;
    std::cout << "Array size: ";
    std::cin >> size;

    std::vector<double> array(size);

    // 1. Elemek bek√©r√©se
    for (int i = 0; i < size; ++i) {
        std::cout << i << ". element: ";
        std::cin >> array[i];
    }

    // 2. M√©ret dupl√°z√°sa
    int oldSize = size;
    size *= 2;
    array.resize(size);

    // 3. √öj elemek felt√∂lt√©se
    for (int i = oldSize; i < size; ++i) {
        std::cout << i << ". element: ";
        std::cin >> array[i];
    }

    // 4. Ki√≠r√°s (opcion√°lis)
    std::cout << "\nThe full array:\n";
    for (int i = 0; i < size; ++i) {
        std::cout << std::fixed << std::setprecision(2) << array[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}

// 3.16.2. Alak√≠tsa √°t √∫gy az el≈ëz≈ë programot, hogy f√ºggv√©nyben k√©rje 
// be t√∂mb m√©retet √©s ott hozza azt l√©tre!  
// 3.16.2.


#include <iostream>
#include <vector>
#include <iomanip>

// A t√∂mb l√©trehoz√°sa √©s felt√∂lt√©se
std::vector<double> allocArray(int& size) {
    std::cout << "\nArray size: ";
    std::cin >> size;

    std::vector<double> result(size);
    for (int i = 0; i < size; ++i) {
        std::cout << i << ". element: ";
        std::cin >> result[i];
    }

    return result;
}

int main() {
    int size;
    
    // 1. Kezdeti t√∂mb l√©trehoz√°sa
    std::vector<double> array = allocArray(size);

    // 2. M√©ret dupl√°z√°sa (√∫j elemeket hozz√°f≈±z√ºnk)
    array.resize(size * 2);
    for (int i = size; i < size * 2; ++i) {
        std::cout << i << ". element: ";
        std::cin >> array[i];
    }

    size *= 2; // friss√≠tett m√©ret

    // 3. Ki√≠r√°s
    std::cout << "\nThe full array:\n";
    for (int i = 0; i < size; ++i) {
        std::cout << std::fixed << std::setprecision(2) << array[i] << " ";
    }
    std::cout << "\n";

    return 0;
}
// 3.17.1. √çrjon programot k√©t dinamikus m√°trix √∂sszeszorz√°s√°ra! 
// F√ºggv√©nyben foglaljon helyet a m√°trixoknak, amelyeket v√©letlen eg√©szekkel 
// t√∂lts√∂n fel! √çrjon f√ºggv√©nyt a m√°trixszoroz√°sra, ellen≈ërizze, hogy a 
// m√°trix m√©rtek kompatibilisek-e, a f√ºggv√©ny visszat√©r√©si √©rt√©ke legyen 
// az √∫j eredm√©ny m√°trix! √çrassa ki az eredetei √©s az eredm√©ny m√°trixokat 
// f√ºggv√©nyben, majd szabad√≠tsa fel azokat! 
// 3.17.1.


#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <iomanip>

using Matrix = std::vector<std::vector<double>>;

Matrix allocMatrix(int rows, int cols) {
    return Matrix(rows, std::vector<double>(cols, 0.0));
}

void randMatrix(Matrix& mat, int min, int max) {
    std::srand(static_cast<unsigned int>(std::time(nullptr)));
    for (auto& row : mat)
        for (auto& val : row)
            val = std::rand() % (max - min + 1) + min;
}

void printMatrix(const Matrix& mat) {
    for (const auto& row : mat) {
        std::cout << "[ ";
        for (double val : row)
            std::cout << std::setw(6) << val << " ";
        std::cout << "]\n";
    }
}

Matrix multMatrix(const Matrix& A, const Matrix& B) {
    int rowA = A.size();
    int colA = A[0].size();
    int rowB = B.size();
    int colB = B[0].size();

    if (colA != rowB) {
        std::cerr << "Matrix dimensions incompatible for multiplication!\n";
        return Matrix(); // √ºres m√°trix
    }

    Matrix C = allocMatrix(rowA, colB);

    for (int i = 0; i < rowA; ++i) {
        for (int j = 0; j < colB; ++j) {
            double sum = 0.0;
            for (int k = 0; k < colA; ++k) {
                sum += A[i][k] * B[k][j];
            }
            C[i][j] = sum;
        }
    }
    return C;
}

int main() {
    int rowA, colA, rowB, colB;

    std::cout << "Number of rows of matrix A: ";
    std::cin >> rowA;
    std::cout << "Number of columns of matrix A: ";
    std::cin >> colA;

    std::cout << "Number of rows of matrix B: ";
    std::cin >> rowB;
    std::cout << "Number of columns of matrix B: ";
    std::cin >> colB;

    Matrix A = allocMatrix(rowA, colA);
    Matrix B = allocMatrix(rowB, colB);

    randMatrix(A, 12, 16);
    randMatrix(B, -4, 5);

    std::cout << "Matrix A:\n";
    printMatrix(A);
    std::cout << "Matrix B:\n";
    printMatrix(B);

    Matrix C = multMatrix(A, B);

    if (!C.empty()) {
        std::cout << "Matrix A * B:\n";
        printMatrix(C);
    } else {
        std::cout << "No result due to dimension mismatch.\n";
    }

    return 0;
}
// 3.17.2. K√©sz√≠tse el az √∫jram√©retez f√ºggv√©nyt, amely vagy lev√°g a 
// m√°trixb√≥l egy darabot, √©s/vagy a m√°trix jobb oldal√°hoz illetve alj√°hoz 
// hozz√°f≈±z egy √∫j r√©szt! Az √∫j r√©sz egys√©gm√°trix szer≈±en tartalmazzon 
// 0-kat √©s 1-ket, ha az √∫j r√©sz nem n√©gyzet alak√∫, akkor az egyesek 
// f≈±r√©szfog szer≈±en helyezkedjenek el! 1 1 1 1 1 1 1 3.3. √°bra: T√©glalap 
// alak√∫ egys√©gm√°trix 
// 3.17.2.

#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <iomanip>

using Matrix = std::vector<std::vector<double>>;

Matrix allocMatrix(int rows, int cols) {
    return Matrix(rows, std::vector<double>(cols));
}

void randMatrix(Matrix& mat, int min, int max) {
    std::srand(static_cast<unsigned>(std::time(nullptr)));
    for (auto& row : mat)
        for (auto& val : row)
            val = std::rand() % (max - min + 1) + min;
}

void printMatrix(const Matrix& mat) {
    for (const auto& row : mat) {
        std::cout << "[ ";
        for (double val : row) {
            std::cout << std::setw(5) << val << " ";
        }
        std::cout << "]\n";
    }
}

Matrix generatePattern(int rows, int cols) {
    Matrix result(rows, std::vector<double>(cols, 0));
    for (int i = 0; i < rows && i < cols; ++i)
        result[i][i] = 1;

    // f≈±r√©szfog-szer≈± minta nem n√©gyzetes esetben
    if (rows != cols) {
        for (int i = 0; i < rows; ++i)
            for (int j = 0; j < cols; ++j)
                if ((i + j) % std::max(1, std::min(rows, cols)) == 0)
                    result[i][j] = 1;
    }
    return result;
}

Matrix cutAndResizeMatrix(const Matrix& original, int option) {
    int rows = original.size();
    int cols = original[0].size();
    int cutRows = 0, addCols = 0;

    if (option == 1 || option == 2) {
        std::cout << "How many rows would you like to delete? ";
        std::cin >> cutRows;
        if (cutRows >= rows) cutRows = rows - 1;
    }

    if (option == 1 || option == 3) {
        std::cout << "How many columns would you like to add? ";
        std::cin >> addCols;
    }

    int newRows = rows - cutRows;
    int newCols = cols + addCols;
    Matrix newMat = allocMatrix(newRows, newCols);

    // Copy old data
    for (int i = 0; i < newRows; ++i)
        for (int j = 0; j < cols; ++j)
            newMat[i][j] = original[i][j];

    // Generate pattern and fill extended part
    if (addCols > 0) {
        Matrix pattern = generatePattern(newRows, addCols);
        for (int i = 0; i < newRows; ++i)
            for (int j = 0; j < addCols; ++j)
                newMat[i][cols + j] = pattern[i][j];
    }

    return newMat;
}

int main() {
    int rows, cols;
    std::cout << "Number of rows: ";
    std::cin >> rows;
    std::cout << "Number of columns: ";
    std::cin >> cols;

    Matrix mat = allocMatrix(rows, cols);
    randMatrix(mat, 12, 16);

    std::cout << "\nOriginal matrix:\n";
    printMatrix(mat);

    std::cout << "\nResize options:\n"
              << "1. Cut rows and add columns\n"
              << "2. Cut rows only\n"
              << "3. Add columns only\n"
              << "Choose: ";
    int choice;
    std::cin >> choice;

    Matrix newMat = cutAndResizeMatrix(mat, choice);

    std::cout << "\nNew matrix:\n";
    printMatrix(newMat);

    return 0;
}
// 3.18. Virtu√°lis mem√≥ria
// 3.18.1. K√©rje be egy lebeg≈ëpontos t√∂mb m√©ret√©t! Ha az 5 vagy kisebb, 
// akkor hozzon l√©tre dinamikus t√∂mb√∂t a mem√≥ri√°ban, ha nagyobb, akkor pedig 
// bin√°ris f√°jlt a h√°tt√©rt√°ron! K√©sz√≠tsen strukt√∫r√°t, amely tartalmaz egy 
// FILE*, double* √©s m√©ret adattagot! K√©sz√≠tsen f√ºggv√©nyeket: t√°rol√≥ 
// inicializ√°l√°s√°ra √©s felszabad√≠t√°s√°ra, t√°rol√≥ adott poz√≠ci√≥j√°ban 
// t√∂rt√©n≈ë olvas√°sra √©s √≠r√°sra. Men√ºben k√©rje be, hogy √≠rni vagy olvasni 
// akar, a f≈ë f√ºggv√©ny sz√°m√°ra a t√°rol√°s m√≥dja legyen transzparens! 
// 3.18.1.


#include <iostream>
#include <vector>
#include <fstream>
#include <limits>

const int limit = 5;
const std::string tempFilename = "temp.bin";

struct Store {
    std::fstream file;
    std::vector<double> memory;
    long size = 0;
    bool useFile = false;
};

void initStore(Store& store) {
    std::cout << "Size of the array: ";
    std::cin >> store.size;

    if (store.size > limit) {
        store.useFile = true;
        store.file.open(tempFilename, std::ios::in | std::ios::out | std::ios::binary | std::ios::trunc);
        if (!store.file) {
            std::cerr << "Failed to open temporary file!\n";
            std::exit(1);
        }

        // Initialize file with zeros
        double zero = 0.0;
        for (long i = 0; i < store.size; ++i) {
            store.file.write(reinterpret_cast<char*>(&zero), sizeof(double));
        }
    } else {
        store.memory.resize(store.size, 0.0);
    }
}

void delStore(Store& store) {
    if (store.useFile) {
        store.file.close();
        std::remove(tempFilename.c_str()); // clean up file
    } else {
        store.memory.clear();
    }
}

void readStore(Store& store) {
    int idx;
    std::cout << "Index of element to read: ";
    std::cin >> idx;

    if (idx < 0 || idx >= store.size) {
        std::cerr << "Invalid index.\n";
        return;
    }

    double result = 0.0;
    if (store.useFile) {
        store.file.seekg(idx * sizeof(double), std::ios::beg);
        store.file.read(reinterpret_cast<char*>(&result), sizeof(double));
    } else {
        result = store.memory[idx];
    }

    std::cout << "At " << idx << " there is: " << result << "\n";
}

void writeStore(Store& store) {
    int idx;
    double value;
    std::cout << "Index of element to write: ";
    std::cin >> idx;
    std::cout << "Value: ";
    std::cin >> value;

    if (idx < 0 || idx >= store.size) {
        std::cerr << "Invalid index.\n";
        return;
    }

    if (store.useFile) {
        store.file.seekp(idx * sizeof(double), std::ios::beg);
        store.file.write(reinterpret_cast<const char*>(&value), sizeof(double));
        store.file.flush();
    } else {
        store.memory[idx] = value;
    }

    std::cout << value << " is written at " << idx << "\n";
}

int main() {
    Store store;
    initStore(store);

    int selection = 0;
    while (selection != 3) {
        std::cout << "\nRead - 1\nWrite - 2\nQuit - 3\n";
        std::cin >> selection;

        switch (selection) {
            case 1:
                readStore(store);
                break;
            case 2:
                writeStore(store);
                break;
            case 3:
                break;
            default:
                std::cout << "Invalid selection.\n";
        }
    }

    delStore(store);
    return 0;
}
// 3.19. G√©pel√©s

// 3.19.1. K√©sz√≠tsen g√©pel√©st tan√≠t√≥ programot! Sztring t√∂mbben 
// t√°roljon 20 k√ºl√∂nf√©le sz√≥t! K√©rje be, hogy h√°ny sz√≥t akar g√©pelni, 
// v√©letlenszer≈±en v√°lasszon ki egyet, amit megjelen√≠t, √©s azt√°n v√°rja azt 
// bemenetk√©nt! Hib√°s bevitel eset√©n k√©rje be √∫jb√≥l a sz√≥t! A gyakorl√°s 
// v√©g√©n √≠rja ki az eltelt id≈ët √©s a helyes √©s elrontott szavak sz√°m√°t! 

// 3.19.1.


#include <iostream>
#include <vector>
#include <string>
#include <random>
#include <chrono>

int main() {
    std::vector<std::string> words = {
        "element", "size", "love", "ball", "toy", "gambit", "cruiser", "shadow",
        "console", "Atlantis", "port", "staple", "Leonardo", "bug", "hope",
        "vanity", "time", "issue", "fan", "strength"
    };

    int trial;
    int errors = 0;
    std::string input;

    std::cout << "How many words would you like to type: ";
    std::cin >> trial;
    std::cin.ignore(); // clear newline after number

    // Random number generator
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dist(0, words.size() - 1);

    // Start timer
    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i < trial; ++i) {
        std::string target = words[dist(gen)];
        std::cout << "type: " << target << std::endl;

        std::getline(std::cin, input);
        while (input != target) {
            std::cout << "error!\n";
            ++errors;
            std::getline(std::cin, input);
        }
    }

    // Stop timer
    auto finish = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> duration = finish - start;

    // Output
    std::cout << "Elapsed time: " << duration.count() << " seconds\n";
    std::cout << "Number of good trials: " << trial
              << ", bad trials: " << errors << "\n";

    return 0;
}

//  3.20. Nagy sz√°mok √∂sszead√°sa

// 3.20.1. √çrjon programot k√©t nagyon nagy pozit√≠v eg√©sz sz√°m 
// √∂sszead√°s√°ra! A sz√°mok legfeljebb 100 jegy≈±ek. √çrja ki a k√©perny≈ëre a 
// k√©t sz√°mot, majd az √∂sszeg√ºket, a k√∂vetkez≈ë form√°tumban. A k√©t sz√°mot 
// f√°jlb√≥l olvassa be, a sz√°mok sz√≥k√∂zzel vannak elv√°lasztva. A sz√°mokat 
// statikus karaktert√∂mb√∂kben t√°rolja! P√©lda bemenet: 434234643643746 
// 575434253245430 Kimenet: 434234643643746 + 575434253245430 = 1009668896889176 

// 3.20.1.


#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>

const int MAX_NUMBER_LENGTH = 101;
const std::string INPUT_FILE = "numbers.txt";

// Egyjegy≈± karakterek √∂sszead√°sa '0'-hoz viszony√≠tva
char addDigit(char a, char b, char carry, char& nextCarry) {
    int sum = (a - '0') + (b - '0') + (carry - '0');
    nextCarry = (sum >= 10) ? '1' : '0';
    return (sum % 10) + '0';
}

std::string addBigNumbers(const std::string& num1, const std::string& num2) {
    std::string a = num1;
    std::string b = num2;

    // Igaz√≠tsuk a r√∂videbb stringet null√°kkal
    while (a.length() < b.length()) a = "0" + a;
    while (b.length() < a.length()) b = "0" + b;

    std::string result(a.length() + 1, '0');
    char carry = '0';

    for (int i = a.length() - 1; i >= 0; --i) {
        char nextCarry = '0';
        result[i + 1] = addDigit(a[i], b[i], carry, nextCarry);
        carry = nextCarry;
    }

    result[0] = carry;
    if (result[0] == '0') {
        result.erase(0, 1); // ha nincs √©rtelme az els≈ë '0'-nak, t√∂r√∂lj√ºk
    }

    return result;
}

int main() {
    std::ifstream file(INPUT_FILE);
    if (!file) {
        std::cerr << "Error opening file: " << INPUT_FILE << "\n";
        return 1;
    }

    std::string num1, num2;
    file >> num1 >> num2;

    std::string sum = addBigNumbers(num1, num2);

    std::cout << num1 << " + " << num2 << " = " << sum << "\n";

    return 0;
}
//  3.21.1. √çrjon programot, amely sz√°mokat olvas be f√°jlb√≥l, majd 
// kisz√°m√≠tja ezek √°tlag√°t √©s medi√°nj√°t! A program √≠rja ki a k√©perny≈ëre 
// a sz√°mokat, az √°tlagot, √©s a medi√°nt is! A medi√°n kisz√°m√≠t√°s√°hoz 
// el≈ësz√∂r sorba kell rendeznie a sz√°mokat. P√°ratlan sz√°m√∫ adat eset√©n a 
// medi√°n ebben a sorban a k√∂z√©ps≈ë elem, p√°ros sz√°m√∫ adat eset√©n a k√©t 
// k√∂z√©ps≈ë elem √°tlaga. Az input f√°jl form√°tuma: Els≈ë sor: Az adatok 
// sz√°ma. M√°sodik sor: A sz√°mok, egy-egy sz√≥k√∂z karakterrel elv√°lasztva. 
// P√©lda bemenet: 

// 4 2 5 3 4 2 5 1 3 5 1 5 5 5 4 4 3 4 4 2 5 5 1 5 5 3 2 5 2 5 

// Kimenet: 
// 30 numbers:
// 4 2 5 3 4 2 5 1 3 5 1 5 5 5 4 4 3 4 4 2 5 5 1 5 5 3 2 5 2 5
// The average is 3.63333
// The median is: 4.00000



#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <numeric>
#include <iomanip>

const std::string DEFAULT_INPUT = "datas.txt";

// Adatok beolvas√°sa f√°jlb√≥l
int readNumbers(const std::string& filename, std::vector<int>& numbers) {
    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Error opening file: " << filename << "\n";
        return 0;
    }

    int count;
    file >> count;
    numbers.resize(count);

    for (int i = 0; i < count; ++i) {
        file >> numbers[i];
    }

    return count;
}

// √Åtlag sz√°m√≠t√°sa
double average(const std::vector<int>& nums) {
    if (nums.empty()) return 0.0;
    long long sum = std::accumulate(nums.begin(), nums.end(), 0LL);
    return static_cast<double>(sum) / nums.size();
}

// Medi√°n sz√°m√≠t√°sa
double median(std::vector<int> nums) {
    if (nums.empty()) return 0.0;

    std::sort(nums.begin(), nums.end());
    size_t n = nums.size();
    if (n % 2 == 1) {
        return nums[n / 2];
    } else {
        return (nums[n / 2 - 1] + nums[n / 2]) / 2.0;
    }
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : DEFAULT_INPUT;
    std::vector<int> numbers;

    int count = readNumbers(filename, numbers);
    if (count == 0) return 1;

    std::cout << count << " numbers:\n";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";

    std::cout << std::fixed << std::setprecision(5);
    std::cout << "The average is " << average(numbers) << "\n";
    std::cout << "The median is: " << median(numbers) << "\n";

    return 0;
}
// 3.22. √ñszt√∂nd√≠j
// 3.22.1. √çrjon programot, amely kisz√°m√≠tja a hallgat√≥k √∂szt√∂nd√≠j√°t a 
// tanulm√°nyi √°tlaguk alapj√°n! F√°jl tartalmazza a hallgat√≥k adatait: neptun 
// k√≥djukat, √©s a t√°rgyaik kredit√©rt√©k√©t, illetve a szerzett √©rdemjegyeket. 
// A program √≠rja ki a k√©perny≈ëre minden hallgat√≥ eset√©ben a neptun k√≥dot, a 
// felvett t√°rgyak sz√°m√°t, a szerzett √©rdemjegyek kredittel s√∫lyozott 
// √°tlag√°t, a felvett √©s a teljes√≠tett kreditek √∂sszeg√©t, √©s a hallgat√≥ 
// sz√°m√°ra meg√≠t√©lt √∂szt√∂nd√≠jat! Egy t√°rgy teljes√≠tett, ha a hallgat√≥ 
// √°tment az adott t√°rgyb√≥l. Az √°tlagba a felvett t√°rgyak √©s nem a 
// teljes√≠tettek tartoznak. Az √∂szt√∂nd√≠jak √∂sszege: ¬∑ 0 <= √°tlag < 2 ‚Üí 0 
// HUF ¬∑ 2 <= √°tlag < 3 ‚Üí 15 000 HUF ¬∑ 3 <= √°tlag < 4 ‚Üí 20 000 HUF ¬∑ 4 <= 
// √°tlag < 4.5 ‚Üí 25 000 HUF ¬∑ 4.5 <= √°tlag <= 5 ‚Üí 30 000 HUF Az input f√°jl 
// form√°tuma: Els≈ë sor: A hallgat√≥k sz√°ma. A hallgat√≥k adatait tartalmaz√≥ 
// sor: Sztring number1 Az egyes t√°rgyakhoz tartoz√≥ sor: number2 number3 P√©lda 
// bemenet: 2 TGDS32 3 4 2 3 5 3 4 FBG4SW 3 4 5 2 3 4 1 A TGDS32 √©s FBG4SW neptun 
// k√≥d√∫ hallgat√≥ adatait l√°tjuk. TGDS32 3 t√°rgyat vett fel, az els≈ë t√°rgya 
// 4 kredit √©rt√©k≈±, az √©rdemjegye bel≈ële 2. Kimenet: Neptun: TGDS32 3 
// subjects Neptun: FBG4SW 3 subjects TGDS32: Credits: 10/10 Average: 3.5 Bursary: 
// 20000 HUF FBG4SW: Credits: 10/6 Average: 3 Bursary: 20000 HUF 
// 3.22.1.

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>

const std::string INPUT_FILE = "students.txt";

// √ñszt√∂nd√≠j szintek
const double MIN_AVERAGE = 2.0;
const double MIDDLE_AVERAGE = 3.0;
const double GOOD_AVERAGE = 4.0;
const double EXCELLENT_AVERAGE = 4.5;

const int MIN_BURSARY = 15000;
const int MIDDLE_BURSARY = 20000;
const int GOOD_BURSARY = 25000;
const int EXCELLENT_BURSARY = 30000;

// T√°rgy
struct Subject {
    int credit;
    int mark;
};

// Hallgat√≥
struct Student {
    std::string neptun;
    std::vector<Subject> subjects;
};

// Hallgat√≥ beolvas√°sa f√°jlb√≥l
void readStudent(std::ifstream& in, Student& student) {
    int subjCount;
    in >> student.neptun >> subjCount;
    std::cout << "Neptun: " << student.neptun << " " << subjCount << " subjects" << std::endl;

    for (int i = 0; i < subjCount; ++i) {
        Subject s;
        in >> s.credit >> s.mark;
        student.subjects.push_back(s);
    }
}

// √ñszt√∂nd√≠j sz√°m√≠t√°s
void calculateAndDisplay(const std::vector<Student>& students) {
    for (const auto& student : students) {
        int sumCredits = 0;
        int passedCredits = 0;
        int weightedSum = 0;

        for (const auto& subj : student.subjects) {
            weightedSum += subj.credit * subj.mark;
            sumCredits += subj.credit;
            if (subj.mark >= 2)
                passedCredits += subj.credit;
        }

        double average = static_cast<double>(weightedSum) / sumCredits;

        int bursary = 0;
        if (average >= 2.0 && average < 3.0)
            bursary = MIN_BURSARY;
        else if (average < 4.0)
            bursary = MIDDLE_BURSARY;
        else if (average < 4.5)
            bursary = GOOD_BURSARY;
        else if (average <= 5.0)
            bursary = EXCELLENT_BURSARY;

        std::cout << student.neptun << ":\n"
                  << "\tCredits: " << sumCredits << "/" << passedCredits << "\n"
                  << "\tAverage: " << std::fixed << std::setprecision(2) << average << "\n"
                  << "\tBursary: " << bursary << " HUF\n";
    }
}

int main() {
    std::ifstream infile(INPUT_FILE);
    if (!infile) {
        std::cerr << "Error opening file: " << INPUT_FILE << std::endl;
        return 1;
    }

    int studentCount;
    infile >> studentCount;

    std::vector<Student> students(studentCount);
    for (int i = 0; i < studentCount; ++i) {
        readStudent(infile, students[i]);
    }

    calculateAndDisplay(students);

    return 0;
}

// 3.23. Szavak keres√©se
// 3.23.1. √çrjon programot, amely beolvassa a ‚Äûdune.txt‚Äù nev≈± f√°jlt √©s 
// keresi benne az ‚ÄûAtreides‚Äù sz√≥t! A program √≠rja ki a k√©perny≈ëre az 
// √∂sszes tal√°latot az el≈ëtte l√©v≈ë sz√≥val egy√ºtt! √çrja ki a tal√°latok 
// sz√°m√°t is! Ha egy √≠r√°sjel szerepel az Atreides sz√≥ ut√°n, pl. 
// ‚ÄûAtreides.‚Äù, ‚ÄûAtreides,‚Äù, az j√≥ tal√°latnak min≈ës√ºl, azonban amikor 
// az Atreides sz√≥ egy r√©szsztringje egy sz√≥nak, azt nem tekintj√ºk j√≥ 
// tal√°latnak, pl. ‚ÄûAtreides-Harkonnen‚Äù, ‚ÄûAtreides's‚Äù. Az input f√°jl 
// form√°tuma: A szavak sz√≥k√∂z karakterekkel vannak elv√°lasztva. P√©lda 
// bemenet: Leto Atreides is the head of the Atreides house. Leto Atreides's son 
// is Paul. Kimenet: Leto Atreides the Atreides 2 hits 
// 3.23.1.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_LENGTH 100
#define DEFAULT_INPUTFILE "dune.txt"
#define DEFAULT_WORD "Atreides"

// Ellen≈ërzi, hogy a len hossz√∫ el≈ëtag ut√°n csak √≠r√°sjel van-e
int CheckWord(const char *W, int len) {
    int l = strlen(W);
    for (int i = len; i < l; i++) {
        if (isalpha(W[i])) return 0; // Rossz: m√©g bet≈± j√∂n
        if (W[i] == '-' || W[i] == '\'') return 0; // Rossz: k√∂t≈ëjel, aposztr√≥f
    }
    return 1; // J√≥: csak √≠r√°sjelek
}

// Megkeresi a sz√≥t a f√°jlban
int SearchWord(FILE *fd, const char *target) {
    int count = 0;
    int len = strlen(target);
    char ReadedWord[MAX_LENGTH] = {0};
    char BeforeWord[MAX_LENGTH] = {0};

    while (fscanf(fd, "%s", ReadedWord) == 1) {
        if (strncmp(ReadedWord, target, len) == 0) {
            if (CheckWord(ReadedWord, len)) {
                printf("%s %s\n", BeforeWord, ReadedWord);
                count++;
            }
        }
        strcpy(BeforeWord, ReadedWord);
    }

    return count;
}

int main(int argc, char *argv[]) {
    const char *filename = (argc > 1) ? argv[1] : DEFAULT_INPUTFILE;
    const char *searchWord = (argc > 2) ? argv[2] : DEFAULT_WORD;

    FILE *fd = fopen(filename, "r");
    if (!fd) {
        perror(filename);
        return EXIT_FAILURE;
    }

    int hits = SearchWord(fd, searchWord);
    printf("%d hits\n", hits);

    fclose(fd);
    return EXIT_SUCCESS;
}

// 3.24. Egyszer≈± sztringford√≠t√≥
// 3.24.1. √çrjon programot, amely beolvas egy f√°jlb√≥l utas√≠t√°sokat √©s 
// v√©grehajtja a benne foglaltakat! Az utas√≠t√°sok h√°rom integer t√≠pus√∫ 
// v√°ltoz√≥t haszn√°lhatnak: A, B, C. A script elej√©n a v√°ltoz√≥k √©rt√©ke 0. A 
// lehets√©ges utas√≠t√°sok a k√∂vetkez≈ëk: GET Op: Op lehet egy v√°ltoz√≥ (A, B, 
// or C), ez a parancs beolvas egy t√≠zes sz√°mrendszerbeli sz√°mot a 
// billenty≈±zetr≈ël, √©s az Op-ban t√°rolja. WRITE Op: Op √©rt√©k√©t a 
// k√©perny≈ëre √≠rja. ADD Op1 Op2: Hozz√°adja Op2-t Op1-hez, azaz Op1 = Op1 + 
// Op2. SUB Op1 Op2: Kivonja Op2-t Op1-b≈ël, azaz Op1 = Op1 - Op2. MUL Op1 Op2: 
// Megszorozza Op1-et Op2-vel, azaz Op1 = Op1 * Op2. DIV Op1 Op2: Elosztja Op1-et 
// Op2-vel, azaz Op1 = Op1 / Op2. STOP: Ez a parancs a script v√©g√©t jelzi. 
// Minden sorban csak egy parancs szerepel. Ha a sor # karakterrel kezd≈ëdik, azt 
// a sort megjegyz√©snek tekintj√ºk. Ezeknek a soroknak a v√©g√©t is egy # 
// karakter jelzi. Az els≈ë # ut√°n egy sz√≥k√∂z karakter k√∂vetkezik. A program 
// √≠rja ki ezeket a sorokat a k√©perny≈ëre, a # karakterek kiv√©tel√©vel! 
// P√©ld√°ul ha a sor a k√∂vetkez≈ë ‚Äû# This is a comment! #‚Äù, a program a 
// k√∂vetkez≈ët √≠rja ki: ‚ÄûThis is a comment!‚Äù P√©lda bemenet: # Type A: # GET 
// A # Type B: # GET B ADD A B # The sum: # WRITE A STOP Kimenet: Type A: 1 Type 
// B: 2 The sum: 3 
// 3.24.1.

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>

#define DEFAULT_INPUTFILE "script.txt"

void get(std::istream& in, std::map<char, int>& vars) {
    std::string op;
    in >> op;
    int value;
    std::cin >> value;
    vars[op[0]] = value;
}

void write(std::istream& in, const std::map<char, int>& vars) {
    std::string op;
    in >> op;
    std::cout << vars.at(op[0]) << std::endl;
}

void add(std::istream& in, std::map<char, int>& vars) {
    std::string op1, op2;
    in >> op1 >> op2;
    vars[op1[0]] += vars[op2[0]];
}

void sub(std::istream& in, std::map<char, int>& vars) {
    std::string op1, op2;
    in >> op1 >> op2;
    vars[op1[0]] -= vars[op2[0]];
}

void mul(std::istream& in, std::map<char, int>& vars) {
    std::string op1, op2;
    in >> op1 >> op2;
    vars[op1[0]] *= vars[op2[0]];
}

void div(std::istream& in, std::map<char, int>& vars) {
    std::string op1, op2;
    in >> op1 >> op2;
    if (vars[op2[0]] != 0) {
        vars[op1[0]] /= vars[op2[0]];
    } else {
        std::cerr << "Error: Division by zero\n";
    }
}

void writeComment(const std::string& line) {
    auto first = line.find('#');
    auto last = line.rfind('#');
    if (first != std::string::npos && last != std::string::npos && last > first) {
        std::string comment = line.substr(first + 1, last - first - 1);
        std::cout << comment << std::endl;
    }
}

void run(std::istream& in) {
    std::map<char, int> vars = {{'A', 0}, {'B', 0}, {'C', 0}};
    std::string line;

    while (std::getline(in, line)) {
        if (line.empty()) continue;

        std::istringstream iss(line);
        std::string command;
        iss >> command;

        if (command == "#") {
            writeComment(line);
        } else if (command == "GET") {
            get(iss, vars);
        } else if (command == "WRITE") {
            write(iss, vars);
        } else if (command == "ADD") {
            add(iss, vars);
        } else if (command == "SUB") {
            sub(iss, vars);
        } else if (command == "MUL") {
            mul(iss, vars);
        } else if (command == "DIV") {
            div(iss, vars);
        } else if (command == "STOP") {
            break;
        }
    }
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : DEFAULT_INPUTFILE;
    std::ifstream infile(filename);

    if (!infile) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return 1;
    }

    run(infile);
    return 0;
}

// 3.25. Riemann integr√°l
// 3.25.1. √çrjon programot, amely n√©gy f√ºggv√©ny Riemann-integr√°lj√°t 
// sz√°m√≠tja ki 0 √©s 1 k√∂z√∂tt! Els≈ëk√©nt az [a, b] intervallumot felosztjuk N 
// db (1000000) r√©szre, azaz egy kis intervallum hossza: h = (b - a)/N. N 
// t√©glalapot k√©pz√ºnk √∫gy, hogy egyik t√©glalap se l√≥gjon a f√ºggv√©ny 
// f√∂l√©. Az i-dik t√©glalap alapja teh√°t h magass√°ga pedig f(h*i) √©s f(h*(i + 
// 1)) k√∂z√ºl a kisebbik. Az integr√°l a t√©glalapok √∂sszege. A sz√°moland√≥ 
// f√ºggv√©nyek: f1(x) = f2(x) = x2 f3(x) = sin(x) f4(x) = tan(x) √Åbra: Riemann 
// integr√°l szeml√©ltet√©se P√©lda bemenet: The Riemann integral of f1(x) over x 
// from 0 to 1: 3.14159 The Riemann integral of f2(x) over x from 0 to 1: 0.333332 
// The Riemann integral of sin(x) over x from 0 to 1: 0.459696 The Riemann 
// integral of tan(x) over x from 0 to 1: 0.615624 
// 3.25.1.


#include <iostream>
#include <cmath>
#include <string>

#define DEFAULT_A 0
#define DEFAULT_B 1
#define DEFAULT_NUM 1000000

inline double my_min(double a, double b) {
    return (a < b) ? a : b;
}

// F√ºggv√©nyek
double f1(double x) {
    return std::sqrt((2.0 - x) * x) * 4.0;
}

double f2(double x) {
    return x * x;
}

// Integr√°l kisz√°m√≠t√°sa
void Integral(int a, int b, int num, double (*fptr)(double), const std::string& name) {
    double res = 0.0;
    double h = static_cast<double>(b - a) / num;
    for (int i = 0; i < num; ++i) {
        double x1 = a + i * h;
        double x2 = a + (i + 1) * h;
        double height = my_min(fptr(x1), fptr(x2));
        res += height * h;
    }
    std::cout << "The Riemann integral of " << name
              << " over x from " << a << " to " << b << ": "
              << res << "\n";
}

int main(int argc, char* argv[]) {
    int a = (argc > 1) ? std::atoi(argv[1]) : DEFAULT_A;
    int b = (argc > 2) ? std::atoi(argv[2]) : DEFAULT_B;
    int num = (argc > 3) ? std::atoi(argv[3]) : DEFAULT_NUM;

    std::cout << std::endl;
    Integral(a, b, num, f1, "f1(x)");
    Integral(a, b, num, f2, "f2(x)");
    Integral(a, b, num, std::sin, "sin(x)");
    Integral(a, b, num, std::tan, "tan(x)");
    std::cout << std::endl;

    return 0;
}

// 3.26. Polinomok √∂sszead√°sa
// 3.26.1. √çrjon programot, amely polinomokat ad √∂ssze! Olvasson be f√°jlb√≥l 
// k√©t polinomot! √çrja ki a k√©perny≈ëre a k√©t polinomot, illetve ezek 
// √∂sszeg√©t! A polinomok t√°rol√°s√°ra haszn√°ljon dinamikus t√∂mb√∂ket √©s 
// strukt√∫r√°kat. Az input f√°jl form√°tuma: Els≈ë sor: Number1 - az els≈ë 
// polinom foka M√°sodik sor: Number1 + 1 eg√©sz sz√°m, az els≈ë polinom 
// egy√ºtthat√≥i (az utols√≥ sz√°m a konstans). Harmadik sor: Number2 - a m√°sodik 
// polinom foka Negyedik sor: Number2 + 1 eg√©sz sz√°m, a m√°sodik polinom (az 
// utols√≥ sz√°m a konstans). A sz√°mok egy-egy sz√≥k√∂z karakterrel vannak 
// elv√°lasztva P√©lda bemenet: 5 -3 5 -4 0 4 2 4 5 4 5 -1 0 Kimenet: - 3x^5 + 
// 5x^4 - 4x^3 + 4x + 2 + 5x^4 + 4x^3 + 5x^2 - x = - 3x^5 + 10x^4 + 5x^2 + 3x + 2 
// 3.26.1.


#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <cstdlib>
#include <cmath>

struct Polynomial {
    int degree;
    std::vector<int> coeffs; // coeffs[0] is highest degree term

    void read(std::ifstream& in) {
        in >> degree;
        coeffs.resize(degree + 1);
        for (int i = 0; i <= degree; ++i)
            in >> coeffs[i];
    }

    void print() const {
        bool firstTerm = true;
        for (int i = 0; i <= degree; ++i) {
            int exp = degree - i;
            int coeff = coeffs[i];
            if (coeff == 0) continue;

            if (!firstTerm) std::cout << (coeff > 0 ? " + " : " - ");
            else if (coeff < 0) std::cout << "-";

            if (std::abs(coeff) != 1 || exp == 0)
                std::cout << std::abs(coeff);
            else if (exp == 0 && std::abs(coeff) == 1)
                std::cout << "1";

            if (exp > 0) {
                std::cout << "x";
                if (exp > 1)
                    std::cout << "^" << exp;
            }

            firstTerm = false;
        }
        if (firstTerm) std::cout << "0"; // if all coefficients were 0
    }
};

Polynomial add(const Polynomial& A, const Polynomial& B) {
    int maxDegree = std::max(A.degree, B.degree);
    int minDegree = std::min(A.degree, B.degree);

    Polynomial result;
    result.degree = maxDegree;
    result.coeffs.resize(maxDegree + 1, 0);

    int offsetA = maxDegree - A.degree;
    int offsetB = maxDegree - B.degree;

    for (int i = 0; i <= A.degree; ++i)
        result.coeffs[i + offsetA] += A.coeffs[i];
    for (int i = 0; i <= B.degree; ++i)
        result.coeffs[i + offsetB] += B.coeffs[i];

    // Trim leading zeros
    while (result.degree > 0 && result.coeffs[0] == 0) {
        result.coeffs.erase(result.coeffs.begin());
        result.degree--;
    }

    return result;
}

int main(int argc, char* argv[]) {
    const std::string filename = (argc > 1) ? argv[1] : "polynoms.txt";
    std::ifstream in(filename);
    if (!in) {
        std::cerr << "Error opening file: " << filename << "\n";
        return 1;
    }

    Polynomial A, B;
    A.read(in);
    B.read(in);

    std::cout << "First polynomial: ";
    A.print();
    std::cout << "\nSecond polynomial: ";
    B.print();

    Polynomial C = add(A, B);
    std::cout << "\nSum: ";
    C.print();
    std::cout << "\n";

    return 0;
}
// 3.27. Caesar dek√≥dol√≥
// 3.27.1. A C√©z√°r-k√≥dol√°s a k√∂vetkez≈ëk√©ppen m≈±k√∂dik: Minden karaktert 
// egy el≈ëre meghat√°rozott N poz√≠ci√≥val eltolunk. P√©ld√°ul, ha N = 1, az 
// ‚ÄûAPPLE‚Äù sz√≥ BQQMD lesz, ugyanis A-b√≥l B lett, P-b≈ël Q, stb. Ha N = 1, 
// Z-b≈ël A lesz. P√©lda N = 3-ra: eredeti sz√∂veg: THE QUICK BROWN FOX JUMPS OVER 
// THE LAZY DOG k√≥dolt sz√∂veg: WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ Az 
// ellens√©gt≈ël egy k√≥dolt √ºzenetet kaptunk. Nem ismerj√ºk N √©rt√©k√©t, de a 
// k√©m√ºnk azt √°ll√≠tja, hogy az eredeti √ºzenet szavai k√∂zt szerepel a 
// ‚ÄûTHE‚Äù sz√≥. √çrjon programot, amely beolvassa a k√≥dolt √ºzenetet a 
// ‚Äûcodedmessage.txt‚Äù f√°jlb√≥l, √©s megfejti, mi volt az eredeti √ºzenet! N 
// √©rt√©ke 1 √©s 26 k√∂zt van, a programnak teh√°t meg kell vizsg√°lnia minden 
// N-t, am√≠g az √ºzenet nem tartalmazza a ‚ÄûTHE‚Äù sz√≥t. Az √ºzenet 
// t√°rol√°s√°ra haszn√°ljon dinamikus t√∂mb√∂t! √Åbra: Caesar k√≥dol√°s 
// szeml√©ltet√©se Az input f√°jl form√°tuma: Els≈ë sor: Az √ºzenet szavainak 
// sz√°ma. M√°sodik sor: Az √ºzenet szavai, egy-egy sz√≥k√∂z karakterrel 
// elv√°lasztva. P√©lda bemenet: 9 WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ 
// Kimenet: The coded message: WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ The 
// original message: THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 
// 3.27.1.


#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>

const std::string DEFAULT_FILENAME = "codedmsg.txt";
const std::string KNOWN_WORD = "THE";
const int ALPHABET_LEN = 26;

using Message = std::vector<std::string>;

bool readMessage(const std::string& filename, Message& msg) {
    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Error: Cannot open file: " << filename << "\n";
        return false;
    }

    int wordCount;
    file >> wordCount;
    msg.resize(wordCount);

    for (int i = 0; i < wordCount; ++i) {
        file >> msg[i];
    }

    return true;
}

void printMessage(const Message& msg) {
    for (const auto& word : msg)
        std::cout << word << " ";
    std::cout << "\n";
}

std::string caesarShift(const std::string& word, int shift) {
    std::string result = word;
    for (char& ch : result) {
        ch = 'A' + (ch - 'A' + shift + ALPHABET_LEN) % ALPHABET_LEN;
    }
    return result;
}

Message shiftMessage(const Message& msg, int shift) {
    Message shifted = msg;
    for (auto& word : shifted) {
        word = caesarShift(word, shift);
    }
    return shifted;
}

bool containsWord(const Message& msg, const std::string& word) {
    for (const auto& w : msg) {
        if (w == word) return true;
    }
    return false;
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : DEFAULT_FILENAME;
    Message codedMessage;

    if (!readMessage(filename, codedMessage))
        return 1;

    std::cout << "The coded message:\n";
    printMessage(codedMessage);

    for (int shift = 1; shift < ALPHABET_LEN; ++shift) {
        Message decoded = shiftMessage(codedMessage, shift);
        if (containsWord(decoded, KNOWN_WORD)) {
            std::cout << "\nThe original message (shift = " << shift << "):\n";
            printMessage(decoded);
            return 0;
        }
    }

    std::cout << "\nNo matching message containing \"" << KNOWN_WORD << "\" was found.\n";
    return 0;
}
// 3.27.2. Legyen a tartalmazott sz√≥, a mostani ‚ÄûTHE‚Äù is bemenet! Ha t√∂bb 
// lehets√©ges visszak√≥dol√°s van, akkor jelen√≠tse meg az √∂sszest! 
// 3.27.2.

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>

const std::string DEFAULT_INPUTFILE = "codedmsg.txt";
const int MAX_WORD_LEN = 15;
const int ALPHABET_LEN = 26;

using Message = std::vector<std::string>;

int readMessage(const std::string& filename, Message& msg) {
    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Cannot open file!\n";
        return 0;
    }

    int num;
    file >> num;
    msg.resize(num);
    for (int i = 0; i < num; ++i) {
        file >> msg[i];
    }

    return num;
}

std::string shiftChar(char c, int shift) {
    return std::string(1, static_cast<char>('A' + (c - 'A' + shift + ALPHABET_LEN) % ALPHABET_LEN));
}

Message shiftMessage(const Message& msg, int shift) {
    Message shifted = msg;
    for (std::string& word : shifted) {
        for (char& ch : word) {
            ch = 'A' + (ch - 'A' + shift + ALPHABET_LEN) % ALPHABET_LEN;
        }
    }
    return shifted;
}

bool containsKnownWord(const Message& msg, const std::string& knownWord) {
    for (const auto& word : msg) {
        if (word.find(knownWord) != std::string::npos) {
            return true;
        }
    }
    return false;
}

void printMessage(const Message& msg) {
    for (const auto& word : msg)
        std::cout << word << " ";
    std::cout << '\n';
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : DEFAULT_INPUTFILE;
    Message codedMessage;

    if (readMessage(filename, codedMessage) == 0)
        return 1;

    std::string knownWord;
    std::cout << "Known word: ";
    std::cin >> knownWord;

    // Convert known word to uppercase for consistency
    std::transform(knownWord.begin(), knownWord.end(), knownWord.begin(), ::toupper);

    std::cout << "\nThe coded message:\n";
    printMessage(codedMessage);

    std::cout << "\nPossible decodings containing \"" << knownWord << "\":\n";
    for (int shift = 1; shift < ALPHABET_LEN; ++shift) {
        Message decoded = shiftMessage(codedMessage, shift);
        if (containsKnownWord(decoded, knownWord)) {
            std::cout << "Shift " << shift << ": ";
            printMessage(decoded);
        }
    }

    return 0;
}

// 3.28. CD  katal√≥gus
// 3.28.1. Rendelkezik egy CD katal√≥gussal, amit f√°jlban t√°rol. √çrjon 
// programot, amely k√©pes arra, hogyha beg√©peli egy szoftver nev√©t, akkor 
// megmondja, melyik CD-n van a szoftver! A szoftverek nevei maximum 15 karakter 
// hossz√∫ak, √©s minden CD-nek van egy neve, amely szint√©n maximum 15 karakter 
// hossz√∫. Haszn√°ljon strukt√∫r√°kat, illetve dinamikus t√∂mb√∂ket a f√°jlb√≥l 
// beolvasott adatok t√°rol√°s√°ra! Az input f√°jl form√°tuma: Els≈ë sor: A CD-k 
// sz√°ma. A tov√°bbi sorok: String: A CD neve Eg√©sz sz√°m: A CD-n l√©v≈ë 
// szoftverek sz√°ma Ezut√°n a CD-n l√©v≈ë szoftverek neve k√∂vetkezik. P√©lda 
// bemenet: 2 2007/11 2 BurningStudio RadioRama 2005/4 3 Doc2PDF Apollo Stellarium 
// A p√©ld√°ban Jamesnek 2 CD-je van, az els≈ë neve ‚Äû2007/11‚Äù, ezen a CD-n 
// k√©t szoftver van: BurningStudio √©s RadioRama. A m√°sik CD 3 szoftvert 
// tartalmaz. Kimenet: Software name: Apollo The Apollo is here: 2005/4 
// 3.28.1.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define DEFAULT_INPUTFILE "cds.txt"
#define MAX_WORD_LENGTH 16

typedef char TWord[MAX_WORD_LENGTH];

struct TCD {
    char Name[MAX_WORD_LENGTH];
    int Num;
    TWord* P; // Dinamikusan foglalt szoftverlista
};

void ReadCD(FILE* fd, struct TCD* cd) {
    fscanf(fd, "%s", cd->Name);
    fscanf(fd, "%d", &cd->Num);
    cd->P = (TWord*)malloc(sizeof(TWord) * cd->Num);
    for (int i = 0; i < cd->Num; ++i) {
        fscanf(fd, "%s", cd->P[i]);
    }
}

int ReadCDs(FILE* fd, struct TCD** outCDs) {
    int count;
    fscanf(fd, "%d", &count);
    *outCDs = (struct TCD*)malloc(sizeof(struct TCD) * count);
    for (int i = 0; i < count; ++i) {
        ReadCD(fd, &(*outCDs)[i]);
    }
    return count;
}

void Search(struct TCD* cds, int num, const char* query) {
    for (int i = 0; i < num; ++i) {
        for (int j = 0; j < cds[i].Num; ++j) {
            if (strcmp(cds[i].P[j], query) == 0) {
                printf("The %s is here: %s\n", query, cds[i].Name);
                return;
            }
        }
    }
    printf("%s does not exist!\n", query);
}

void FreeCDs(struct TCD* cds, int num) {
    for (int i = 0; i < num; ++i) {
        free(cds[i].P);
    }
    free(cds);
}

int main(int argc, char* argv[]) {
    const char* filename = (argc > 1) ? argv[1] : DEFAULT_INPUTFILE;
    FILE* fd = fopen(filename, "r");

    if (!fd) {
        perror("Error opening file");
        return EXIT_FAILURE;
    }

    struct TCD* cds = NULL;
    int cdCount = ReadCDs(fd, &cds);
    fclose(fd);

    TWord software;
    printf("Program name: ");
    scanf("%15s", software);

    Search(cds, cdCount, software);

    FreeCDs(cds, cdCount);
    return EXIT_SUCCESS;
}

// 3.28.2. √çrja √°t √∫gy az el≈ëz≈ë programot, hogy lehessen a keres√©sn√©l egy ? 
// vagy egy * karaktert haszn√°lni! A ? egy tetsz≈ëleges karakter helyett √°llhat, 
// a * pedig a sztring v√©g√©n lehet √©s azt jelezi, hogy m√©g valamennyi karakter 
// h√°tra van. Ha egy minta t√∂bb program nev√©re is illeszkedik, akkor jelen√≠tse 
// meg mindet! 
// 3.28.2.

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstring>

const std::string DEFAULT_INPUTFILE = "cds.txt";
const size_t MAX_WORD_LENGTH = 16;

struct CD {
    std::string name;
    std::vector<std::string> programs;
};

// Wildcard string comparison with support for ? and terminal *
bool wildcardMatch(const std::string& pattern, const std::string& text) {
    size_t pLen = pattern.length();
    size_t tLen = text.length();

    for (size_t i = 0; i < pLen; ++i) {
        if (pattern[i] == '*') {
            return text.substr(0, i) == pattern.substr(0, i);
        }
        if (i >= tLen || (pattern[i] != '?' && pattern[i] != text[i])) {
            return false;
        }
    }
    return tLen == pLen;
}

std::vector<CD> readCDs(std::ifstream& file) {
    int cdCount;
    file >> cdCount;
    std::vector<CD> cds(cdCount);

    for (int i = 0; i < cdCount; ++i) {
        file >> cds[i].name;
        int progCount;
        file >> progCount;
        cds[i].programs.resize(progCount);
        for (int j = 0; j < progCount; ++j) {
            file >> cds[i].programs[j];
        }
    }
    return cds;
}

void searchPrograms(const std::vector<CD>& cds, const std::string& pattern) {
    bool found = false;
    for (const auto& cd : cds) {
        for (const auto& prog : cd.programs) {
            if (wildcardMatch(pattern, prog)) {
                std::cout << "The " << prog << " is here: " << cd.name << "\n";
                found = true;
            }
        }
    }
    if (!found) {
        std::cout << pattern << " does not exist!\n";
    }
}

int main(int argc, char* argv[]) {
    std::string filename = argc > 1 ? argv[1] : DEFAULT_INPUTFILE;
    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Error opening file: " << filename << "\n";
        return 1;
    }

    auto cds = readCDs(file);
    file.close();

    std::string pattern;
    std::cout << "Program name (use * or ? as wildcards): ";
    std::cin >> pattern;

    searchPrograms(cds, pattern);

    return 0;
}
// 3.29. Lelt√°r
// 3.29.1. Egy c√©g term√©kek v√°s√°rl√°s√°val √©s elad√°s√°val foglalkozik. Az 
// √©v elej√©n 10.000 Ft-ja van. Egy f√°jlban t√°rolja az inform√°ci√≥kat a 
// term√©kekr≈ël, az elad√°sokr√≥l √©s a beszerz√©sekr≈ël. √çrjon programot, amely 
// a f√°jlb√≥l beolvassa az adatokat, √©s megmondja az egyes term√©kek 
// mennyis√©g√©t, illetve a c√©g egyenleg√©t az elad√°sok √©s beszerz√©sek ut√°n! 
// Haszn√°ljon dinamikus t√∂mb√∂ket √©s strukt√∫r√°kat az adatok t√°rol√°s√°ra! Az 
// input f√°jl form√°tuma: Els≈ë sor: Number1 - a term√©kek sz√°ma A k√∂vetkez≈ë 
// Number1 db sor: String Number2 Number3 Number4 String: az i-edik term√©k neve 
// Number2: az i-edik term√©k mennyis√©ge Number3: az i-edik term√©k beszerz√©si 
// √°ra Number4: az i-edik term√©k elad√°si √°ra Number5: a term√©kekkel 
// kapcsolatos ad√°s-v√©telek sz√°ma Az ezut√°n k√∂vetkez≈ë Number5 db sor: 
// Number6 Number7 Number6: Az aktu√°lis term√©k indexe (nem a neve, hanem a 
// sorsz√°ma) Number7: Ha ez a sz√°m pozit√≠v, a c√©g beszerzett a Number6-os 
// term√©kb≈ël Number7 db-ot, beszerz√©si √°ron;
// ha negat√≠v, akkor a c√©g a Number6-os term√©kb≈ël eladott Number7 abszol√∫t 
// √©rt√©k√©nek megfelel≈ë sz√°m√∫ darabot, elad√°si √°ron. P√©lda bemenet: 2 
// hammer 100 500 800 screwdriver 50 300 400 2 1 10 2 -5 A p√©ldaf√°jl eset√©ben 
// k√©tf√©le term√©k√ºnk van: 100 db hammer √©s 50 db screwdriver. A c√©g 500 
// Ft-√©rt tud hammer-t beszerezni, √©s 800 Ft-√©rt tudja eladni. 2 f√©le 
// term√©kmozg√°s t√∂rt√©nt, el≈ësz√∂r v√°s√°roltak 500 Ft/db √°ron 10 db 
// hammer-t, majd 400 Ft/db √°ron eladtak 5 db screwdriver-t. Kimenet: Inventory: 
// **************************************** hammer: Count: 100 Purchase price: 500 
// Shop price: 800 screwdriver: Count: 50 Purchase price: 300 Shop price: 400 
// Inventory: **************************************** hammer: Count: 110 Purchase 
// price: 500 Shop price: 800 screwdriver: Count: 45 Purchase price: 300 Shop 
// price: 400 We have got 7000 HUF 
// 3.29.1.


#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>
#include <iomanip>

const std::string DEFAULT_INPUTFILE = "inventory.txt";
const int START_MONEY = 10000;

struct Good {
    std::string name;
    int count;
    int purchasePrice;
    int shopPrice;
};

void printInventory(const std::vector<Good>& goods) {
    std::cout << "Inventory:\n****************************************\n";
    for (const auto& g : goods) {
        std::cout << g.name << ":\n"
                  << "\tCount: " << g.count << "\n"
                  << "\tPurchase price: " << g.purchasePrice << "\n"
                  << "\tShop price: " << g.shopPrice << "\n";
    }
}

std::vector<Good> readGoods(std::ifstream& in) {
    int num;
    in >> num;
    std::vector<Good> goods(num);
    for (int i = 0; i < num; ++i) {
        in >> goods[i].name >> goods[i].count >> goods[i].purchasePrice >> goods[i].shopPrice;
    }
    return goods;
}

int applyTransactions(std::ifstream& in, std::vector<Good>& goods, int startingMoney) {
    int numLogs;
    in >> numLogs;
    int balance = startingMoney;

    for (int i = 0; i < numLogs; ++i) {
        int productIndex, amount;
        in >> productIndex >> amount;

        --productIndex; // zero-based indexing

        if (productIndex < 0 || productIndex >= static_cast<int>(goods.size())) {
            std::cerr << "Invalid product index: " << productIndex + 1 << "\n";
            continue;
        }

        goods[productIndex].count += amount;

        if (amount > 0)
            balance -= amount * goods[productIndex].purchasePrice;
        else
            balance += std::abs(amount) * goods[productIndex].shopPrice;
    }

    return balance;
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : DEFAULT_INPUTFILE;
    std::ifstream in(filename);
    if (!in) {
        std::cerr << "Error opening file: " << filename << "\n";
        return EXIT_FAILURE;
    }

    try {
        std::vector<Good> goods = readGoods(in);

        printInventory(goods);

        int finalMoney = applyTransactions(in, goods, START_MONEY);

        printInventory(goods);

        std::cout << "We have got " << finalMoney << " HUF\n";
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << "\n";
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

// 3.30. K√∂nyvt√°ri rendszer
// 3.30.1. A k√∂nyvt√°rakban a k√∂nyvek az Egyetemes Tizedes Oszt√°lyoz√°s (ETO, 
// angolul UDC) szerint vannak oszt√°lyozva. Minden k√∂nyvnek van egy ETO sz√°ma, 
// amit a k√∂nyv t√©m√°ja hat√°roz meg. Az ETO sz√°m els≈ë sz√°mjegye a f≈ë 
// t√©m√°t hat√°rozza meg: 0. √Åltal√°nos m≈±vek, bibliogr√°fia, k√∂nyvt√°r√ºgy. 
// 1. Filoz√≥fia, pszichol√≥gia, logika, etika. 2. Vall√°s, egyh√°zak, teol√≥gia. 
// 3. T√°rsadalomtudom√°nyok, k√∂zigazgat√°s, jog, oktat√°s. 4. Nem haszn√°lt 5. 
// Matematika, term√©szettudom√°nyok, fizika, k√©mia. 6. Alkalmazott tudom√°nyok, 
// m≈±szaki tudom√°nyok, orvostudom√°nyok. 7. M≈±v√©szetek, j√°t√©k, sport, 
// sz√≥rakoz√°s. 8. Nyelv√©szet, irodalom 9. R√©g√©szet, f√∂ldrajz, √©letrajz, 
// t√∂rt√©nelem P√©ld√°ul egy 543-as ETO sz√°m√∫ k√∂nyvr≈ël tudjuk, hogy 
// matematik√°val, vagy term√©szettudom√°nyokkal foglalkozik. A t√∂bbi sz√°mjegy a 
// program szempontj√°b√≥l nem fontos. A ‚Äûlib1.txt‚Äù f√°jlban k√∂nyvek adatai 
// szerepelnek. A f√°jl tartalmazza a szerz≈ë nev√©t, a k√∂nyv c√≠m√©t, a kiad√°si 
// √©vet √©s a k√∂nyv ETO sz√°m√°t. √çrjon programot, amely beolvassa ezt a 
// f√°jlt, list√°zza az egyes k√∂nyveket, v√©g√ºl √∂sszes√≠t√©st ad, hogy h√°ny 
// k√∂nyv tal√°lhat√≥ a k√∂nyvt√°rban egy-egy a t√©m√°ban! Haszn√°ljon dinamikus 
// t√∂mb√∂ket √©s strukt√∫r√°kat az adatok t√°rol√°s√°ra! Az input f√°jl 
// form√°tuma: Els≈ë sor: A k√∂nyvek sz√°ma. A t√∂bbi sor form√°tuma: Szerz≈ë 
// R√∂vid_C√≠m Kiad√°si √©v ETO (sz√≥k√∂z karakterekkel elv√°lasztva). A szerz≈ë 
// neve √©s a k√∂nyv c√≠me maximum 20 karakterb≈ël √°ll, mindkett≈ë egy-egy sz√≥ 
// csak. Az ETO sz√°m 3 karakterb≈ël √°ll. P√©lda bemenet: 
// 3
// Asimov Foundation 1980 820
// Herbert Dune 1990 820
// Dancs Terror 2001 512

// Kimenet: 
// Author: Asimov
// Title: Foundation
// Year of edition: 1980
// UDC: 820 Language, Linguistics, Literature

// Author: Herbert
// Title: Dune
// Year of edition: 1990
// UDC: 820 Language, Linguistics, Literature

// Author: Dancs
// Title: Terror
// Year of edition: 2001
// UDC: 512 Mathematics and natural sciences

// **************************************

// Generalities: 0 books
// Philosophy, Psychology: 0 books
// Religion, Theology: 0 books
// Social sciences: 0 books
// vacant: 0 books
// Mathematics and natural sciences: 1 books
// Applied sciences, Medicine, Technology: 0 books
// Arts, Recreation, Entertainment, Sport: 0 books
// Language, Linguistics, Literature: 2 books
// Geography, Biography, History: 0 books

// 3.30.1.


#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <array>

const std::string DEFAULT_INPUTFILE = "lib1.txt";
const int MAX_UDC_CLASSES = 10;

const std::array<std::string, MAX_UDC_CLASSES> UDC_CLASSES = {
    "Generalities",
    "Philosophy, Psychology",
    "Religion, Theology",
    "Social sciences",
    "vacant",
    "Mathematics and natural sciences",
    "Applied sciences, Medicine, Technology",
    "Arts, Recreation, Entertainment, Sport",
    "Language, Linguistics, Literature",
    "Geography, Biography, History"
};

struct Book {
    std::string author;
    std::string title;
    int year;
    std::string udc;
};

std::vector<Book> readBooks(const std::string& filename) {
    std::ifstream in(filename);
    if (!in) {
        throw std::runtime_error("Could not open file: " + filename);
    }

    int n;
    in >> n;
    std::vector<Book> books(n);

    for (int i = 0; i < n; ++i) {
        in >> books[i].author >> books[i].title >> books[i].year >> books[i].udc;
    }

    return books;
}

void printBooksAndStats(const std::vector<Book>& books) {
    std::array<int, MAX_UDC_CLASSES> counts = {0};

    for (const auto& book : books) {
        int mainClass = book.udc[0] - '0';
        std::cout << "Author: " << book.author << "\n"
                  << "Title: " << book.title << "\n"
                  << "Year of edition: " << book.year << "\n"
                  << "UDC: " << book.udc << " " << UDC_CLASSES[mainClass] << "\n\n";

        if (mainClass >= 0 && mainClass < MAX_UDC_CLASSES) {
            counts[mainClass]++;
        }
    }

    std::cout << "**************************************\n\n";
    for (int i = 0; i < MAX_UDC_CLASSES; ++i) {
        std::cout << UDC_CLASSES[i] << ": " << counts[i] << " books\n";
    }
}

int main(int argc, char* argv[]) {
    try {
        std::string filename = (argc > 1) ? argv[1] : DEFAULT_INPUTFILE;
        auto books = readBooks(filename);
        printBooksAndStats(books);
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
// 3.31. Kik√∂lcs√∂nz√∂tt k√∂nyvek

// 3.31.1. A k√∂nyvt√°rak nyilv√°ntart√°st vezetnek a kik√∂lcs√∂nz√∂tt 
// k√∂nyvekr≈ël. Ez tartalmazza a k√∂nyvek szerz≈ëj√©t, c√≠m√©t, illetve a 
// k√∂lcs√∂nz√©s lej√°rat√°nak idej√©t. T√©telezz√ºk fel, hogy az aktu√°lis d√°tum 
// 2008. december 15. √çrjon programot, amely beolvassa a kik√∂lcs√∂nz√∂tt 
// k√∂nyvek list√°j√°t egy f√°jlb√≥l, √©s kilist√°zza azoknak a k√∂nyveknek az 
// adatait, amelyek k√∂lcs√∂nz√©si ideje m√°r lej√°rt! Haszn√°ljon dinamikus 
// t√∂mb√∂ket √©s strukt√∫r√°kat az adatok t√°rol√°s√°ra! Az input f√°jl 
// form√°tuma: Els≈ë sor: A k√∂nyvek sz√°ma. A t√∂bbi sor: Szerz≈ë R√∂vid_c√≠m √âv 
// H√≥nap Nap A szerz≈ë neve √©s a k√∂nyv c√≠me is egy-egy sz√≥ csak. Az √©v, 
// h√≥nap, nap a lej√°rat idej√©t jel√∂lik. P√©lda bemenet: 3 Asimov Foundation 
// 2009 1 20 Herbert Dune 2008 12 1 Dancs Terror 2008 11 30 Kimenet: Title: 
// Herbert Author: Dune Expiraton: 2008 12 1 Title: Dancs Author: Terror 
// Expiraton: 2008 11 30 
// 3.31.1.


#include <iostream>
#include <fstream>
#include <vector>
#include <string>

constexpr int YEAR = 2008;
constexpr int MONTH = 12;
constexpr int DAY = 15;

struct Book {
    std::string author;
    std::string title;
    int year, month, day;
};

bool isExpired(int y, int m, int d) {
    if (y < YEAR) return true;
    if (y == YEAR && m < MONTH) return true;
    if (y == YEAR && m == MONTH && d < DAY) return true;
    return false;
}

std::vector<Book> readBooks(std::ifstream& file) {
    int count;
    file >> count;
    std::vector<Book> books(count);
    for (int i = 0; i < count; ++i) {
        file >> books[i].author >> books[i].title
             >> books[i].year >> books[i].month >> books[i].day;
    }
    return books;
}

void printExpiredBooks(const std::vector<Book>& books) {
    std::cout << "\nLej√°rt k√∂nyvek:\n\n";
    for (const auto& book : books) {
        if (isExpired(book.year, book.month, book.day)) {
            std::cout << "Title: " << book.author << '\n';
            std::cout << "Author: " << book.title << '\n';
            std::cout << "Expiration: " << book.year << " "
                      << book.month << " " << book.day << "\n\n";
        }
    }
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : "lib1.txt";
    std::ifstream file(filename);

    if (!file) {
        std::cerr << "Hiba a f√°jl megnyit√°sakor: " << filename << "\n";
        return 1;
    }

    std::vector<Book> books = readBooks(file);
    file.close();

    printExpiredBooks(books);

    return 0;
}
// 3.32. Sz√≥t√°r

// 3.32.1. √çrjon angol-magyar sz√≥t√°r programot! F√°jl tartalmazza az 
// angol-magyar sz√≥p√°rokat! A program olvasson be egy sz√≥t a billenty≈±zetr≈ël! 
// A sz√≥ a k√©t nyelv b√°rmelyik√©n lehet. Ezut√°n olvassa be a sz√≥p√°rokat a 
// f√°jlb√≥l, √©s keresse meg a megadott sz√≥hoz tartoz√≥ sz√≥p√°rt! Az is 
// tal√°latnak sz√°m√≠t, ha a beg√©pelt sz√≥, az el≈ëtagja az egyik sz√≥t√°ri 
// bejegyz√©snek. √çrja ki a k√©perny≈ëre a tal√°latokat! Az input f√°jl 
// form√°tuma: Els≈ë sor: A sz√≥p√°rok sz√°ma A t√∂bbi sor: Angol_sz√≥ Magyar_sz√≥ 
// (sz√≥k√∂z karakterrel elv√°lasztva) Egy-egy sz√≥ maxim√°lis hossza 20 karakter. 
// P√©lda bemenet: 5 SUN NAP DOG KUTYA BICYCLE BICIKLI VILLAGE FALU SUNSHINE 
// NAPSUTES Kimenet: Type the word: NAP Hun->Eng: NAP SUN 1 hits Kimenet: Type the 
// word: SUN Eng->Hun: SUN NAP Eng->Hun: SUNSHINE NAPSUTES 2 hits 

// 3.32.1.


#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>

struct WordPair {
    std::string eng;
    std::string hun;
};

void search(const std::vector<WordPair>& dict, const std::string& word) {
    int hits = 0;

    for (const auto& pair : dict) {
        // Angol->Magyar: el≈ëtag egyez√©s vagy teljes egyez√©s
        if (pair.eng.find(word) == 0) {
            std::cout << "Eng->Hun: " << pair.eng << " " << pair.hun << "\n";
            ++hits;
        }
        // Magyar->Angol: csak teljes egyez√©s
        if (pair.hun == word) {
            std::cout << "Hun->Eng: " << pair.hun << " " << pair.eng << "\n";
            ++hits;
        }
    }

    std::cout << "\n" << hits << " hits\n";
}

int main(int argc, char* argv[]) {
    const std::string filename = (argc > 1) ? argv[1] : "dict.txt";
    std::ifstream file(filename);

    if (!file) {
        std::cerr << "Hiba a f√°jl megnyit√°sakor: " << filename << "\n";
        return 1;
    }

    int num;
    file >> num;

    std::vector<WordPair> dict(num);
    for (int i = 0; i < num; ++i) {
        file >> dict[i].eng >> dict[i].hun;
    }

    std::string word;
    std::cout << "\nType the word: ";
    std::cin >> word;

    std::cout << '\n';
    search(dict, word);

    return 0;
}
// 3.33. Sudoku  ellen≈ërz≈ë

// 3.33.1. √çrjon programot, amely leellen≈ëriz egy kit√∂lt√∂tt Sudoku t√°bl√°t! A 
// t√°bla √©rt√©keit olvassa be f√°jlb√≥l! Egy t√°bla akkor van helyesen 
// kit√∂ltve, ha minden sorban, minden oszlopban √©s minden kis 3x3-as kis 
// n√©gyzetben az 1-9 k√∂zti sz√°mjegyek mindegyike egyszer szerepel. Az √°br√°n 
// egy helyesen kit√∂lt√∂tt t√°bla szerepel. 9 5 8 2 7 4 6 3 1 1 4 7 5 3 6 9 2 8 2 
// 6 3 9 8 1 4 7 5 8 3 1 4 6 9 2 5 7 4 2 5 3 1 7 8 9 6 7 9 6 8 5 2 1 4 3 3 1 4 7 2 
// 8 5 6 9 5 8 9 6 4 3 7 1 2 6 7 2 1 9 5 3 8 4 √Åbra: Sudoku t√°bla Az input f√°jl 
// form√°tuma: Az input f√°jl 9 sort √©s 9 oszlopot tartalmaz. A sz√°mjegyek 
// egy-egy sz√≥k√∂z karakterrel vannak elv√°lasztva. P√©lda bemenet: 7 4 6 8 3 1 5 
// 9 2 9 2 3 5 7 4 8 6 1 8 1 5 2 9 6 4 7 3 1 3 4 7 5 2 6 8 9 6 9 7 3 1 8 2 5 4 5 8 
// 2 4 6 9 1 3 7 4 7 9 6 2 8 3 1 8 3 6 8 1 4 7 9 2 5 2 5 1 9 8 3 7 4 6 Kimenet: 
// This is a wrong table! 


// 3.33.1.


#include <stdio.h>
#include <stdlib.h>

#define SIZE 9
#define TRUE 1
#define FALSE 0
#define DEFAULT_INPUTFILE "sudoku1.txt"

typedef int TTable[SIZE][SIZE];

void ReadTable(FILE* fd, TTable T) {
    for (int i = 0; i < SIZE; ++i)
        for (int j = 0; j < SIZE; ++j)
            fscanf(fd, "%d", &T[i][j]);
}

void PrintTable(TTable T) {
    printf("\nSudoku Table:\n");
    for (int i = 0; i < SIZE; ++i) {
        for (int j = 0; j < SIZE; ++j)
            printf("%d ", T[i][j]);
        printf("\n");
    }
    printf("\n");
}

int isValidGroup(int values[SIZE]) {
    int seen[SIZE + 1] = {0}; // index 1..9
    for (int i = 0; i < SIZE; ++i) {
        int val = values[i];
        if (val < 1 || val > 9 || seen[val])
            return FALSE;
        seen[val] = 1;
    }
    return TRUE;
}

int CheckRows(TTable T) {
    for (int i = 0; i < SIZE; ++i) {
        int row[SIZE];
        for (int j = 0; j < SIZE; ++j)
            row[j] = T[i][j];
        if (!isValidGroup(row)) return FALSE;
    }
    return TRUE;
}

int CheckColumns(TTable T) {
    for (int j = 0; j < SIZE; ++j) {
        int col[SIZE];
        for (int i = 0; i < SIZE; ++i)
            col[i] = T[i][j];
        if (!isValidGroup(col)) return FALSE;
    }
    return TRUE;
}

int CheckBoxes(TTable T) {
    for (int boxY = 0; boxY < 3; ++boxY) {
        for (int boxX = 0; boxX < 3; ++boxX) {
            int values[SIZE];
            int idx = 0;
            for (int i = 0; i < 3; ++i)
                for (int j = 0; j < 3; ++j)
                    values[idx++] = T[boxY * 3 + i][boxX * 3 + j];
            if (!isValidGroup(values)) return FALSE;
        }
    }
    return TRUE;
}

void Check(TTable T) {
    if (CheckRows(T) && CheckColumns(T) && CheckBoxes(T)) {
        printf("This table is correct!\n");
    } else {
        printf("This is a wrong table!\n");
    }
}

int main(int argc, char* argv[]) {
    TTable table;
    FILE* fd = fopen(argc > 1 ? argv[1] : DEFAULT_INPUTFILE, "r");
    if (!fd) {
        perror("Error opening input file");
        return 1;
    }

    ReadTable(fd, table);
    fclose(fd);

    PrintTable(table);
    Check(table);

    return 0;
}
// 3.34. Am≈ëba j√°t√©k

// 3.34.1. √çrjon egy egyszer≈± am≈ëba j√°t√©kot, 3x3-as p√°ly√°ra! K√©t j√°t√©kos 
// j√°tszhat a programmal, akik a saj√°t jel√ºket helyezhetik a mez≈ëkbe 
// felv√°ltva (X vagy O). Az a j√°t√©kos nyeri a j√°tszm√°t, akinek 3 jele lesz 
// egy sorban, oszlopban vagy √°tl√≥ban. Ha nincs t√∂bb √ºres cella, vagy a 
// j√°t√©kosok valamelyike nyer, a j√°t√©k v√©get √©r. A programnak minden l√©p√©s 
// ut√°n ki kell rajzolnia a j√°t√©kt√°bla aktu√°lis √°ll√°s√°t karakteresen! 
// Felt√©telezz√ºk, hogy mindk√©t j√°t√©kos megfelel≈ë poz√≠ci√≥t ad meg minden 
// l√©p√©sben. 
// P√©lda bemenet: 
// A B C ------
// 1| | | | ------
// 2| | | | ------
// 3| | | | 
// // ------
// First player 
// Target: A1 A B C ------1|X| | | ------2| | | | ------3| | | 
// | ------Second player Target: B1 A B C ------1|X|O| | ------2| | | | ------3| | 
// | | ------- First player Target: A2 A B C ------1|X|O| | ------2|X| | | 
// ------3| | | | ------Second player Target: A3 A B C ------1|X|O| | ------2|X| | 
// | ------3|O| | | ------First player Target: B2 A B C ------1|X|O| | 
// ------2|X|X| | ------3|O| | | ------- Second player Target: C1 A B C 
// ------1|X|O|O| ------2|X|X| | ------3|O| | | ------First player Target: C3 A B 
// C ------1|X|O|O| ------2|X|X| | ------3|O| |X| ------First player won! 

// 3.34.1.

#include <iostream>
#include <string>
#include <cctype>

const int SIZE = 3;
const char SIGN1 = 'X';
const char SIGN2 = 'O';

using TTable = char[SIZE][SIZE];

void InitTable(TTable table) {
    for (int i = 0; i < SIZE; ++i)
        for (int j = 0; j < SIZE; ++j)
            table[i][j] = ' ';
}

void PrintTable(const TTable table) {
    std::cout << "   A   B   C\n";
    for (int i = 0; i < SIZE; ++i) {
        std::cout << " " << i + 1 << " ";
        for (int j = 0; j < SIZE; ++j) {
            std::cout << "|" << table[j][i];
        }
        std::cout << "|\n";
        std::cout << "  ---+---+---\n";
    }
}

bool Win(const TTable table, char ch) {
    for (int i = 0; i < SIZE; ++i) {
        if ((table[0][i] == ch && table[1][i] == ch && table[2][i] == ch) || // row
            (table[i][0] == ch && table[i][1] == ch && table[i][2] == ch))   // col
            return true;
    }
    return (table[0][0] == ch && table[1][1] == ch && table[2][2] == ch) ||
           (table[2][0] == ch && table[1][1] == ch && table[0][2] == ch);
}

bool Drawn(const TTable table) {
    for (int i = 0; i < SIZE; ++i)
        for (int j = 0; j < SIZE; ++j)
            if (table[i][j] == ' ')
                return false;
    return true;
}

bool ValidCoord(char col, char row, int& x, int& y) {
    col = toupper(col);
    if (col < 'A' || col >= 'A' + SIZE || row < '1' || row >= '1' + SIZE)
        return false;
    x = col - 'A';
    y = row - '1';
    return true;
}

void Play(TTable table) {
    int player = 0;
    std::string input;
    int x, y;

    while (true) {
        PrintTable(table);
        std::cout << (player == 0 ? "First player" : "Second player") << " turn (e.g., A1): ";
        std::cin >> input;
        if (input == "0") {
            std::cout << "Game cancelled.\n";
            return;
        }

        if (input.size() < 2 || !ValidCoord(input[0], input[1], x, y)) {
            std::cout << "Invalid input! Try again.\n";
            continue;
        }

        if (table[x][y] != ' ') {
            std::cout << "Cell already taken! Try another.\n";
            continue;
        }

        table[x][y] = (player == 0 ? SIGN1 : SIGN2);

        if (Win(table, table[x][y])) {
            PrintTable(table);
            std::cout << (player == 0 ? "First" : "Second") << " player won!\n";
            return;
        }

        if (Drawn(table)) {
            PrintTable(table);
            std::cout << "Draw! Game over.\n";
            return;
        }

        player = 1 - player;
    }
}

int main() {
    TTable table;
    InitTable(table);
    Play(table);
    return 0;
}

// 3.35.  T√©rk√©p

// 3.35.1. Egy f√°jl egy magass√°gi t√©rk√©pet tartalmaz. A magass√°gok pozit√≠v 
// eg√©sz sz√°mok. √çrjon programot, amely beolvassa ezt a t√©rk√©pet egy 
// m√°trixba, ki√≠rja a k√©perny≈ëre √©s kisz√°m√≠tja az adott ter√ºleten az 
// alf√∂ld, dombs√°g, hegys√©g √©s magashegys√©g ar√°ny√°t! A m√°trix legyen 
// dinamikus! A magass√°gi intervallumok a k√∂vetkez≈ëk: 0 <= magass√°g < 250 250 
// <= magass√°g < 500 500 <= magass√°g < 1500 1500 <= magass√°g alf√∂ld dombs√°g 
// hegys√©g magashegys√©g Az input f√°jl form√°tuma: Els≈ë sor: number1 number2 A 
// number1 a sorok, number2 az oszlopok sz√°m√°t adja meg. Ezut√°n number1 db sor 
// k√∂vetkezik, minden sorban number2 db, sz√≥k√∂z karakterrel elv√°lasztott 
// √©rt√©k tal√°lhat√≥. 

// P√©lda bemenet: 5 5 200 210 220 218 230 0 1600 322 31 1000 
// 332 320 43 1 545 2000 32 252 0 321 1320 2123 324 21 43 

// Kimenet: 200 210 220 218 
// 230 0 1600 322 31 1000 332 320 1 545 2000 32 252 0 321 1320 2123 324 Lowland: 
// 52 % Hill: 24 % Mountain: 12 % High mountain: 12 % 

// 3.35.1.

#include <iostream>
#include <vector>
#include <fstream>
#include <iomanip>

const int HILL = 250;
const int MOUNTAIN = 500;
const int HIGHMOUNTAIN = 1500;

using Map = std::vector<std::vector<int>>;

void readMap(std::ifstream& file, Map& map, int& rows, int& cols) {
    file >> rows >> cols;
    map.resize(rows, std::vector<int>(cols));

    for (int i = 0; i < rows; ++i)
        for (int j = 0; j < cols; ++j)
            file >> map[i][j];
}

void printMap(const Map& map) {
    std::cout << "\nThe map:\n\n";
    for (const auto& row : map) {
        for (int val : row)
            std::cout << std::setw(5) << val;
        std::cout << '\n';
    }
}

void countTerrains(const Map& map) {
    int lowland = 0, hill = 0, mountain = 0, highmountain = 0;
    int total = 0;

    for (const auto& row : map) {
        for (int h : row) {
            ++total;
            if (h < HILL)
                ++lowland;
            else if (h < MOUNTAIN)
                ++hill;
            else if (h < HIGHMOUNTAIN)
                ++mountain;
            else
                ++highmountain;
        }
    }

    std::cout << std::fixed << std::setprecision(2);
    std::cout << "\nLowland: "       << (lowland * 100.0 / total)      << " %\n";
    std::cout << "Hill: "            << (hill * 100.0 / total)         << " %\n";
    std::cout << "Mountain: "        << (mountain * 100.0 / total)     << " %\n";
    std::cout << "High mountain: "   << (highmountain * 100.0 / total) << " %\n\n";
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : "map1.txt";
    std::ifstream file(filename);

    if (!file) {
        std::cerr << "Hiba a f√°jl megnyit√°sakor: " << filename << '\n';
        return 1;
    }

    Map map;
    int rows, cols;
    readMap(file, map, rows, cols);
    file.close();

    printMap(map);
    countTerrains(map);

    return 0;
}

// 3.36. Inverz m√°trix
// 3.36.1. √çrjon programot, amely kisz√°m√≠tja egy 3x3-as m√°trix inverz√©t! A 
// program √≠rja ki a k√©perny≈ëre a m√°trix adjung√°ltj√°t, determin√°nst √©s az 
// inverz m√°trixot. Az inverz m√°trixot a k√∂vetkez≈ëk√©ppen sz√°m√≠thatjuk ki: 
// A-1 = adj(A) / det(A), ahol adj(A) az A m√°trix adjung√°ltja, √©s det(A) az A 
// m√°trix determin√°nsa. Ha det(A) = 0, akkor A nem invert√°lhat√≥. = √Åbra: 
// M√°trix elemeinek az indexel√©se Determin√°ns: A 2x2-es m√°trix determin√°nsa a 
// k√∂vetkez≈ë: a11*a22 - a21*a12 A 3x3-as m√°trix determin√°nsa: a11 * a22 * a33 
// + a12 * a23 * a31 + a13 * a21 * a32 - a13 * a22 * a31 - a12 * a21 * a33 - a11 * 
// a23 * a32 Adjung√°lt: A A ‚éõ A adj( ) = ‚éú- ‚éú A A + ‚éù A + ahol A A A A 
// A A A A A + A A - A - = det A A A A A A A A A - A A + A + A A A A A A ‚éû 
// ‚éü ‚éü ‚é† ;
// P√©lda bemenet: Original matrix: 1 2 3 2 4 5 3 5 6 Adjugate matrix: -1 3 -2 3 
// -3 1 -2 1 0 Determinant of the matrix: -1 Inverse matrix: 1 -3 2 -3 3 -1 2 -1 
// -0 

// 3.36.1.


#include <iostream>
#include <array>
#include <iomanip>

constexpr int SIZE = 3;
using Matrix = std::array<std::array<double, SIZE>, SIZE>;

// M√°trix ki√≠r√°s
void printMatrix(const Matrix& m) {
    std::cout << '\n';
    for (int i = 0; i < SIZE; ++i) {
        for (int j = 0; j < SIZE; ++j)
            std::cout << std::setw(6) << m[i][j] << ' ';
        std::cout << '\n';
    }
    std::cout << '\n';
}

// 3x3 determin√°ns sz√°m√≠t√°sa
double getDeterminant(const Matrix& m) {
    return  m[0][0] * m[1][1] * m[2][2]
          + m[0][1] * m[1][2] * m[2][0]
          + m[0][2] * m[1][0] * m[2][1]
          - m[0][2] * m[1][1] * m[2][0]
          - m[0][1] * m[1][0] * m[2][2]
          - m[0][0] * m[1][2] * m[2][1];
}

// Kofaktor egy (i, j) helyen
double getMinor(const Matrix& m, int row, int col) {
    std::array<double, 4> vals;
    int idx = 0;
    for (int i = 0; i < SIZE; ++i) {
        if (i == row) continue;
        for (int j = 0; j < SIZE; ++j) {
            if (j == col) continue;
            vals[idx++] = m[i][j];
        }
    }
    return vals[0]*vals[3] - vals[1]*vals[2];
}

// Adjung√°lt m√°trix (transzpon√°lt kofaktor m√°trix)
Matrix makeAdjugate(const Matrix& m) {
    Matrix adj;
    for (int i = 0; i < SIZE; ++i) {
        for (int j = 0; j < SIZE; ++j) {
            double minor = getMinor(m, i, j);
            adj[j][i] = ((i + j) % 2 == 0 ? 1 : -1) * minor; // transzpon√°lt
        }
    }
    return adj;
}

// Inverz m√°trix
bool invertMatrix(const Matrix& m, Matrix& inverse) {
    double det = getDeterminant(m);
    std::cout << "Determinant of the matrix: " << det << '\n';

    if (det == 0.0) {
        std::cout << "We cannot invert this matrix!\n";
        return false;
    }

    Matrix adj = makeAdjugate(m);

    std::cout << "Adjugate matrix:\n";
    printMatrix(adj);

    for (int i = 0; i < SIZE; ++i)
        for (int j = 0; j < SIZE; ++j)
            inverse[i][j] = adj[i][j] / det;

    return true;
}

int main() {
    Matrix matrix = {{
        {1, 2, 3},
        {2, 4, 5},
        {3, 5, 6}
    }};

    std::cout << "Original matrix:\n";
    printMatrix(matrix);

    Matrix inverse;
    if (invertMatrix(matrix, inverse)) {
        std::cout << "Inverse matrix:\n";
        printMatrix(inverse);
    }

    return 0;
}
// 3.37. M√°trixm≈±veletek
// 3.37.1. √çrjon programot m√°trix√∂sszead√°s √©s skal√°rral val√≥ szorz√°s 
// megval√≥s√≠t√°s√°ra! A program olvassa be f√°jlb√≥l k√©t m√°trixot! Adja √∂ssze 
// a k√©t m√°trixot, √©s az eredm√©nyt szorozza meg 2-vel! A m√°trixokat 
// dinamikusan hozza l√©tre! Ha A, B √©s C azonos m√©ret≈± m√°trixok, akkor Cij = 
// Aij + Bij , ahol C az A √©s B m√°trixok √∂sszege. Egy m√°trix ‚Äûd‚Äù 
// skal√°rral val√≥ szorz√°sakor a m√°trix minden elem√©t ‚Äûd‚Äù-vel szorozzuk. 
// Az input f√°jl form√°tuma: Els≈ë sor: K√©t sz√°m, az els≈ë a sorok, a m√°sodik 
// az oszlopok sz√°ma. A t√∂bbi sorban a k√©t m√°trix tal√°lhat√≥, a p√©ld√°ban 
// l√°that√≥ m√≥don. Minden sorban egy-egy m√°trix-sor van, a sz√°mok sz√≥k√∂z 
// karakterekkel vannak elv√°lasztva. A m√°trixok elemei eg√©sz sz√°mok. P√©lda 
// bemenet: 2 3 4 3 4 3 1 5 2 4 1 1 7 3 Kimenet: A : 4 3 4 3 1 5 B : 2 4 1 1 7 3 
// ************************ (A + B) * 2 = 12 14 10 8 16 16 

// 3.37.1.


#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>

using Matrix = std::vector<std::vector<int>>;

Matrix readMatrix(std::ifstream& in, int rows, int cols) {
    Matrix mat(rows, std::vector<int>(cols));
    for (int i = 0; i < rows; ++i)
        for (int j = 0; j < cols; ++j)
            in >> mat[i][j];
    return mat;
}

void printMatrix(const Matrix& mat) {
    for (const auto& row : mat) {
        for (int val : row)
            std::cout << std::setw(4) << val;
        std::cout << '\n';
    }
    std::cout << '\n';
}

Matrix addAndMultiplyMatrix(const Matrix& A, const Matrix& B, int scalar) {
    int rows = A.size();
    int cols = A[0].size();
    Matrix C(rows, std::vector<int>(cols));

    for (int i = 0; i < rows; ++i)
        for (int j = 0; j < cols; ++j)
            C[i][j] = (A[i][j] + B[i][j]) * scalar;

    return C;
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : "3.37.1.txt";
    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Nem siker√ºlt megnyitni a f√°jlt: " << filename << '\n';
        return 1;
    }

    int rows, cols;
    file >> rows >> cols;

    Matrix A = readMatrix(file, rows, cols);
    Matrix B = readMatrix(file, rows, cols);

    std::cout << "A:\n";
    printMatrix(A);

    std::cout << "B:\n";
    printMatrix(B);

    Matrix C = addAndMultiplyMatrix(A, B, 2);

    std::cout << "************************\n(A + B) * 2 =\n\n";
    printMatrix(C);

    return 0;
}
// 3.38. Morze k√≥d

// 3.38.1. √çrjon programot, ami egy √ºzenetet Morze k√≥dd√° alak√≠t! Az √ºzenet 
// beg√©pel√©se ut√°n a program foglaljon le mem√≥ri√°t a k√≥dolt √ºzenet 
// sz√°m√°ra, k√≥dolja az √ºzenetet √©s jelen√≠tse meg azt! Haszn√°lja az al√°bbi 
// sztring t√∂mb√∂t az egye karakterek lek√©pez√©s√©re! A sz√≥k√∂z karakter k√≥dja 
// 5 pont. char* morsecodes[26] = { ".=", "=...", "=.=.", "=..", ".", "..=.", 
// "==.", "....", "..", ".===", "=.=", ".=..", "==", "=.", "===", ".==.", "==.=", 
// ".=.", "...", "=", "..=", "...=", ".==", "=..=", "=.==", "==.."};
// P√©lda bemenet: Az √ºzenet: SOS I AM WRITING A TEST √úzenet: "SOS I AM WRITING 
// A TEST" A k√≥dolt √ºzenet: 
// "...===................===......==.=...=..=.==.......=.....=....=" 

// 3.38.1.:

#include <iostream>
#include <string>
#include <vector>
#include <cctype>

const std::string morsecodes[26] = {
    ".=", "=...", "=.=.", "=..", ".", "..=.", "==.", "....", "..", ".===",
    "=.=", ".=..", "==", "=.", "===", ".==.", "==.=", ".=.", "...", "=",
    "..=", "...=", ".==", "=..=", "=.==", "==.."
};

const std::string SZOKOZ = ".....";

std::string toUpper(const std::string& input) {
    std::string result;
    for (char ch : input)
        result += std::toupper(static_cast<unsigned char>(ch));
    return result;
}

std::string morseEncode(const std::string& message) {
    std::string result;
    for (char ch : message) {
        if (ch == ' ') {
            result += SZOKOZ;
        } else if (std::isupper(ch)) {
            result += morsecodes[ch - 'A'];
        }
        // Optional: ignore other characters or handle them
    }
    return result;
}

int main() {
    std::string message;
    std::cout << "The message: ";
    std::getline(std::cin, message);

    message = toUpper(message);

    std::cout << "Message: \"" << message << "\"\n";

    std::string morse = morseEncode(message);

    std::cout << "The coded message: \"" << morse << "\"\n";

    return 0;
}

 
// 3.39.  M√°trix szorz√°sa vektorral

// 3.39.1. √çrjon programot, amely megszoroz egy m√°trixot egy vektorral! A 
// m√°trixot √©s a vektort f√°jlb√≥l olvassa be √©s t√°rolja ≈ëket dinamikus 
// adatszerkezetekkel! √çrja ki a k√©perny≈ëre az eredeti m√°trixot √©s vektort, 
// majd a szorzatvektort! A szorzatvektor annyi √©rt√©ket tartalmaz, amennyi a 
// m√°trix sorainak sz√°ma. Ha ‚ÄûP‚Äù a szorzatvektor, ‚ÄûA‚Äù a m√°trix, √©s 
// ‚ÄûV‚Äù az eredeti vektor, akkor Pi = Sum(j=1‚Ä¶c, Aij*Vj), ahol Aij a m√°trix 
// i-edik sor√°nak j-edik oszlop√°ban van, c a m√°trix oszlopainak sz√°ma. Az 
// input f√°jl form√°tuma: Els≈ë sor: num1 num2 num1: a m√°trix sorainak sz√°ma 
// num2: a m√°trix oszlopainak sz√°ma, amely egyben az eredeti vektor elemeinek 
// sz√°ma is A k√∂vetkez≈ë num1 db sor a m√°trix sorait tartalmazza, mindegyik 
// sorban num2 db √©rt√©k tal√°lhat√≥, sz√≥k√∂z karakterrel elv√°lasztva. A 
// m√°trix ut√°n num2 db sz√°m k√∂vetkezik, az eredeti vektor elemei. P√©lda 
// bemenet: 2 3 4 1 3 7 2 2 6 2 3 Kimenet: Matrix : 4 1 7 2 Vector : 6 3 2 2 3 
// ************************ Matrix * Vector =  

// 3.39.1

#include <iostream>
#include <vector>
#include <fstream>
#include <iomanip>

using Matrix = std::vector<std::vector<int>>;
using Vector = std::vector<int>;

void readMatrix(std::ifstream& in, Matrix& matrix, int rows, int cols) {
    matrix.resize(rows, std::vector<int>(cols));
    for (int i = 0; i < rows; ++i)
        for (int j = 0; j < cols; ++j)
            in >> matrix[i][j];
}

void readVector(std::ifstream& in, Vector& vec, int size) {
    vec.resize(size);
    for (int i = 0; i < size; ++i)
        in >> vec[i];
}

void printMatrix(const Matrix& matrix) {
    for (const auto& row : matrix) {
        for (int val : row)
            std::cout << std::setw(4) << val;
        std::cout << '\n';
    }
}

void printVector(const Vector& vec) {
    for (int val : vec)
        std::cout << std::setw(4) << val << '\n';
}

Vector multiply(const Matrix& mat, const Vector& vec) {
    Vector result(mat.size(), 0);
    for (size_t i = 0; i < mat.size(); ++i)
        for (size_t j = 0; j < vec.size(); ++j)
            result[i] += mat[i][j] * vec[j];
    return result;
}

int main(int argc, char* argv[]) {
    std::string filename = (argc > 1) ? argv[1] : "3.39.1.txt";
    std::ifstream file(filename);

    if (!file) {
        std::cerr << "Nem siker√ºlt megnyitni a f√°jlt: " << filename << '\n';
        return 1;
    }

    int rows, cols;
    file >> rows >> cols;

    Matrix matrix;
    Vector vector;

    readMatrix(file, matrix, rows, cols);
    readVector(file, vector, cols);

    Vector result = multiply(matrix, vector);

    std::cout << "Matrix:\n";
    printMatrix(matrix);
    std::cout << "\nVector:\n";
    printVector(vector);
    std::cout << "\n************************\nMatrix * Vector = \n\n";
    printVector(result);

    return 0;
}

// 3.40. Sztring tokeniz√°l√≥

// 3.40.1. √çrjon sztring tokeniz√°l√≥ programot! A felhaszn√°l√≥ egy sztringet 
// g√©pel be, amely t√∂bb sz√≥b√≥l √°llhat, a szavakat egy vagy t√∂bb sz√≥k√∂z 
// karakter v√°lasztja el. Ezut√°n a program sz√°molja meg a sztringben l√©v≈ë 
// szavakat, foglaljon le dinamikus t√∂mb√∂ket a szavak sz√°m√°ra, √©s m√°solja be 
// az egyes szavakat a lefoglalt karaktert√∂mb√∂kbe! √çrja ki a program a 
// k√©perny≈ëre az eredeti sztringet, √©s az egyes szavakat! 
// P√©lda bemenet: 
// This is a simple example. 
// The typed text: "This is a 
// 1.: "This" 
// 2.: "is" 
// 3.: "a" 
// 4.: "simple" 
// 5.: "example." simple example." 

// 3.40.1.


#include <iostream>
#include <sstream>
#include <vector>
#include <string>

int main() {
    std::string line;

    std::cout << "Enter a sentence: ";
    if (!std::getline(std::cin, line)) {
        std::cerr << "Input error!\n";
        return 1;
    }

    std::cout << "The typed text: \"" << line << "\"\n";

    std::istringstream iss(line);
    std::vector<std::string> tokens;
    std::string word;

    while (iss >> word) {
        tokens.push_back(word);
    }

    for (size_t i = 0; i < tokens.size(); ++i) {
        std::cout << (i + 1) << ".: \"" << tokens[i] << "\"\n";
    }

    return 0;
}
// 3.41. Szavak kicser√©l√©se

// 3.41.1. Egy f√°jlban egy legfeljebb 1000 karakter hossz√∫ sztring tal√°lhat√≥. 
// √çrjon programot, amely beolvassa ezt a f√°jlt, majd bek√©r a felhaszn√°l√≥t√≥l 
// k√©t sz√≥t! A m√°sodik sz√≥ nem lehet hosszabb az els≈ën√©l. A program keresse 
// meg az els≈ë sz√≥ minden el≈ëfordul√°s√°t a sz√∂vegben, √©s cser√©lje ki a 
// m√°sodik sz√≥ra. √çrja ki a k√©perny≈ëre az √∫j sz√∂veget, √©s a tal√°latok 
// sz√°m√°t! 

// P√©lda: 
// The original text: "This is a very simple text that can help 
// for you to understand the task. " 
// Type a word: simple 
// Type the new word: easy 1 hits 
// The new text: "This is a very easy text that can help for you to 
// understand the task. " 

// 3.41.1.

#include <iostream>
#include <fstream>
#include <string>

int replaceWords(std::string& text, const std::string& from, const std::string& to) {
    if (to.size() > from.size()) {
        std::cerr << "Hiba: a csere sz√≥ nem lehet hosszabb, mint az eredeti!\n";
        return -1;
    }

    int hits = 0;
    size_t pos = 0;
    while ((pos = text.find(from, pos)) != std::string::npos) {
        text.replace(pos, to.length(), to);
        // ha r√∂videbb lett a sz√≥, a sz√∂veget igaz√≠tjuk
        if (to.length() < from.length()) {
            text.erase(pos + to.length(), from.length() - to.length());
        }
        ++hits;
        pos += to.length(); // l√©p√©s a k√∂vetkez≈ë lehets√©ges tal√°latra
    }
    return hits;
}

int main(int argc, char* argv[]) {
    const std::string filename = (argc > 1) ? argv[1] : "text.txt";
    std::ifstream file(filename);

    if (!file) {
        std::cerr << "Nem siker√ºlt megnyitni a f√°jlt: " << filename << '\n';
        return 1;
    }

    std::string text((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();

    std::cout << "The original text: \"" << text << "\"\n\n";

    std::string word1, word2;
    std::cout << "Type a word: ";
    std::cin >> word1;

    std::cout << "Type the new word: ";
    std::cin >> word2;

    int hits = replaceWords(text, word1, word2);
    if (hits >= 0) {
        std::cout << "\n" << hits << " hits\n";
        std::cout << "The new text: \"" << text << "\"\n";
    }

    return 0;
}

// 3.42. Ellen≈ërz≈ë √∂sszeg
// 3.42.1. √çrjon programot, amely k√©pes ellen≈ërz≈ë √∂sszeg gener√°l√°s√°ra egy 
// √ºzenethez, √©s ezen √∂sszeg alapj√°n ellen≈ërizni tudja a bej√∂v≈ë 
// √ºzeneteket! Az ellen≈ërz≈ë √∂sszeg kisz√°m√≠t√°sa a k√∂vetkez≈ëk√©ppen 
// t√∂rt√©nik: Adjuk √∂ssze az √ºzenet minden b√°jtj√°t, ha az √∂sszeg nagyobb, 
// mint 255, akkor az √∂sszegnek csak a legkisebb b√°jtj√°t tekintj√ºk. Az √≠gy 
// kapott b√°jt kettes komplemense (255 - sum + 1) lesz az ellen≈ërz≈ë √∂sszeg. 
// P√©ld√°ul az ‚ÄûABCD‚Äù √ºzenet b√°jtjai: 0x41, 0x42, 0x43 and 0x44, √≠gy az 
// √∂sszeg = 0x41 + 0x42 + 0x43 + 0x44 = 0x10A. Ebb≈ël legkisebb b√°jt: 0xA, a 
// kettes komplemens pedig: 0xFF - 0xA + 0x1 = 0xF6. Az ellen≈ërz√©s menete: Az 
// √ºzenettel egy√ºtt az ellen≈ërz≈ë √∂sszeg is meg√©rkezik egy f√°jlban. A 
// programnak √∂ssze kell adnia a be√©rkezett √ºzenet minden b√°jtj√°t √©s az 
// ellen≈ërz≈ë √∂sszeget. Ha az eredm√©ny utols√≥ b√°jtja 0, akkor a be√©rkezett 
// √ºzenet val√≥sz√≠n≈±leg nem s√©r√ºlt. Egy f√°jl t√∂bb √ºzenetet tartalmaz, az 
// ellen≈ërz≈ë √∂sszeg√ºkkel egy√ºtt. A program olvassa be ezeket, √©s 
// ellen≈ërizze ≈ëket! √çrja ki a k√©perny≈ëre az √ºzeneteket, az ellen≈ërz≈ë 
// √∂sszegeket, √©s azt, hogy az √ºzenetek hib√°sak vagy helyesek! V√©g√ºl 
// sz√°molja ki a ‚ÄûThis is a simple checksum example.‚Äù √ºzenet ellen≈ërz≈ë 
// √∂sszeg√©t! Az input f√°jl form√°tuma: Els≈ë sor: Az √ºzenetek sz√°ma A t√∂bbi 
// sor felv√°ltva tartalmaz √ºzeneteket √©s ellen≈ërz≈ë √∂sszegeket. Az √ºzenetek 
// soraiban t√∂bb sz√≥ is szerepelhet. Az √ºzenet ut√°n k√∂vetkez≈ë sor az √ºzenet 
// ellen≈ërz≈ë √∂sszeg√©t tartalmazza hexadecim√°lis form√°ban. P√©lda bemenet: 2 
// This is the first row of the message. C2 This is the second row ov the message. 
// 6E Kimenet: "This is the first row of the message." C2 ===> Correct! "This is 
// the second row ov the message." 6E ===> Faulty! Sum of "This is a simple 
// checksum example.": C6C The checksum: 94 

// 3.42.1.


#include <iostream>
#include <fstream>
#include <string>
#include <iomanip>

using ubyte = unsigned char;

ubyte getChecksum(const std::string& msg) {
    unsigned int sum = 0;
    for (char c : msg)
        sum += static_cast<ubyte>(c);

    std::cout << "\nSum of \"" << msg << "\": " << std::hex << std::uppercase << sum << '\n';

    ubyte reduced = static_cast<ubyte>(sum);  // Only the least significant byte
    ubyte checksum = 0xFF - reduced + 1;

    std::cout << "The checksum: " << std::hex << static_cast<int>(checksum) << std::dec << '\n';

    return checksum;
}

bool checkMessage(const std::string& msg, ubyte checksum) {
    unsigned int sum = checksum;
    for (char c : msg)
        sum += static_cast<ubyte>(c);

    return (static_cast<ubyte>(sum) == 0);
}

void readMessages(std::istream& in) {
    int count;
    in >> count;
    in.ignore(); // skip newline

    for (int i = 0; i < count; ++i) {
        std::string msg;
        std::getline(in, msg);

        std::string checksum_line;
        std::getline(in, checksum_line);
        unsigned int checksum;
        std::stringstream(checksum_line) >> std::hex >> checksum;

        std::cout << "\"" << msg << "\" " << std::uppercase << checksum << " ===> ";
        if (checkMessage(msg, static_cast<ubyte>(checksum))) {
            std::cout << "Correct!\n";
        } else {
            std::cout << "Faulty!\n";
        }
    }
}

int main(int argc, char* argv[]) {
    const std::string filename = (argc > 1) ? argv[1] : "message.txt";
    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Hiba a f√°jl megnyit√°sakor: " << filename << '\n';
        return 1;
    }

    readMessages(file);
    file.close();

    getChecksum("This is a simple checksum example.");

    return 0;
}
/*
3.43. Statisztika

3.43.1. Egy 5000 f≈ës telep√ºl√©s lakosainak adatait kell feldolgoznunk. Van 
egy f√°jlunk, amely a lakosok √©letkor√°t tartalmazza. √çrjon programot, amely 
ki√≠rja a k√©perny≈ëre, hogy mennyi kiskor√∫, feln≈ëtt, nyugd√≠jas √©l a 
tele√ºl√©sen! Kiskor√∫nak sz√°m√≠t az, aki m√©g nem t√∂lt√∂tte be a 18. 
√©let√©v√©t, egy√©bk√©nt a feln≈ëttek k√∂z√© soroljuk. A nyugd√≠jkorhat√°r 62 
√©v. 

3.43.2. B≈ëv√≠tse ki az el≈ëz≈ë programot √∫gy, hogy a program ki√≠rja, hogy 
h√°nyan sz√ºlettek a m√°sodik vil√°gh√°bor√∫ alatt (1939-1945). Az aktu√°lis 
√©v 2010. 

3.43.3. B≈ëv√≠tse ki az el≈ëz≈ë programot √∫gy, hogy a program ki√≠rja azt is, 
hogy h√°nyan sz√ºlettek sz√∂k≈ë√©vben! Sz√∂k≈ë√©vnek sz√°m√≠tanak azok az 
√©vek, ahol az √©vsz√°m oszthat√≥ 4-el, de a 100-asra v√©gz≈ëd≈ëek k√∂z√ºl csak 
azok, amelyek oszthat√≥ak 400-al. Ez alapj√°n sz√∂k≈ë√©v volt 1992, 1996, de 
1900 nem, viszont 2000 igen. 

3.43.1.-3.34.3.

 
*/

 
#include <iostream>
#include <fstream>
#include <string>

constexpr int AKTUALIS_EV = 2010;

bool szokoev(int ev) {
    return (ev % 4 == 0 && ev % 100 != 0) || (ev % 400 == 0);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Haszn√°lat: " << argv[0] << " fajlnev.txt\n";
        return EXIT_FAILURE;
    }

    std::ifstream file(argv[1]);
    if (!file) {
        std::cerr << "Nem siker√ºlt megnyitni a f√°jlt: " << argv[1] << '\n';
        return EXIT_FAILURE;
    }

    int kiskoru = 0;
    int felnott = 0;
    int nyugdijas = 0;
    int vh2 = 0;
    int szokoevben = 0;

    int eletkor;
    while (file >> eletkor) {
        int ev = AKTUALIS_EV - eletkor;

        // √âletkori kateg√≥ri√°k
        if (eletkor < 18) {
            ++kiskoru;
        } else {
            ++felnott;
            if (eletkor >= 62) {
                ++nyugdijas;
            }
        }

        // 2. vil√°gh√°bor√∫ alatt sz√ºletettek
        if (ev >= 1939 && ev <= 1945) {
            ++vh2;
        }

        // Sz√∂k≈ë√©v ellen≈ërz√©s
        if (szokoev(ev)) {
            ++szokoevben;
        }
    }

    // Ki√≠r√°s
    std::cout << "Kiskor√∫ak sz√°ma: " << kiskoru << '\n';
    std::cout << "Feln≈ëttek sz√°ma: " << felnott << '\n';
    std::cout << "Nyugd√≠jasok sz√°ma: " << nyugdijas << '\n';
    std::cout << "M√°sodik vil√°gh√°bor√∫ alatt sz√ºletettek: " << vh2 << '\n';
    std::cout << "Sz√∂k≈ë√©vben sz√ºletettek: " << szokoevben << '\n';

    return 0;
}

/* 3.44. Ker√≠t√©s

3.44.1. Egy 400 m√©ter ker√ºlet≈± telket szeretn√©nk k√∂r√ºlvenni 
dr√≥tker√≠t√©ssel. T√∂bb k√∂teg dr√≥tker√≠t√©s√ºnk van, amelyek hossz√°t 
egyenk√©nt ismerj√ºk. √çrjon programot, amely 0 v√©gjelig beolvassa az egyes 
k√∂tegek hosszait, majd a v√©g√©n ki√≠rja, hogy √∂sszesen h√°ny m√©ternyi 
ker√≠t√©s√ºnk van √©s, ha kell-e m√©g ker√≠t√©st venn√ºnk, akkor √∂sszesen 
mennyit! 

3.44.1.
*/

#include <iostream>

int main() {
    int koteg = 0;
    int osszeg = 0;

    std::cout << "Adja meg a ker√≠t√©sk√∂tetek hossz√°t (0 v√©gjelig):\n";

    do {
        std::cout << "K√∂teg hossza (m): ";
        std::cin >> koteg;
        if (koteg > 0) {
            osszeg += koteg;
        }
    } while (koteg != 0);

    std::cout << "√ñsszesen van " << osszeg << " m√©ter ker√≠t√©s√ºnk.\n";

    if (osszeg < 400) {
        std::cout << "M√©g sz√ºks√©g van " << 400 - osszeg << " m√©ternyi ker√≠t√©sre.\n";
    } else {
        std::cout << "Megvan a sz√ºks√©ges ker√≠t√©smennyis√©g.\n";
    }

    return 0;
}

/*
3.45. Jegyek √°tlaga Alad√°r √©v v√©g√©n szeretn√© kisz√°molni, hogy 
mely tant√°rgyb√≥l h√°nyasra √°ll. Minden t√°rgyb√≥l sok jegyet szerzett, 
ez√©rt √∫gy v√©li, f√°raszt√≥ munka lenne k√©zzel √°tlagokat sz√°molni, ez√©rt 
sz√°m√≠t√≥g√©pes seg√≠ts√©ghez folyamodik.

3.45.1. √çrjon programot Alad√°rnak, amely beolvas 10 jegyet, majd kisz√°molja 
azok sz√°mtani √°tlag√°t! 

3.45.1.
*/


#include <iostream>
#include <vector>

constexpr int N = 10;

int main() {
    std::vector<int> jegyek(N);
    int osszeg = 0;

    std::cout << "K√©rem a " << N << " jegyet:\n";

    for (int i = 0; i < N; ++i) {
        std::cout << i + 1 << ". jegy: ";
        std::cin >> jegyek[i];
        osszeg += jegyek[i];
    }

    double atlag = static_cast<double>(osszeg) / N;

    std::cout << "A jegyek sz√°mtani √°tlaga: " << atlag << std::endl;

    return 0;
}


// 3.45.2. B≈ëv√≠tse ki az el≈ëz≈ë programot √∫gy, hogy 0 v√©gjelig olvassa be a 
// jegyeket √©s √∫gy v√©gzi el a sz√°mol√°st! 

// 3.45.3. Fejlessze tov√°bb a programot √∫gy, hogy a jegyek sz√≥r√°s√°t is 
// meghat√°rozza! Hat√°rozza meg az egyes jegyek √°tlagt√≥l val√≥ elt√©r√©sit, 
// ut√°na ezen elt√©r√©sek n√©gyezeteinek az √°tlag√°t, majd az √≠gy kapott 
// eredm√©ny gy√∂k√©t! 

// 3.45.2-3.45.3.


#include <iostream>
#include <vector>
#include <cmath>
#include <iomanip>

int main() {
    std::vector<int> jegyek;
    int jegy, i = 1;
    int osszeg = 0;

    std::cout << "Jegyek beolvas√°sa (0 v√©gjelig):\n";
    do {
        std::cout << i++ << ". jegy: ";
        std::cin >> jegy;
        if (jegy > 0) {
            jegyek.push_back(jegy);
            osszeg += jegy;
        }
    } while (jegy > 0);

    if (jegyek.empty()) {
        std::cout << "Nincsenek √©rv√©nyes jegyek!\n";
        return 0;
    }

    double atlag = static_cast<double>(osszeg) / jegyek.size();

    // Sz√≥r√°s sz√°m√≠t√°sa
    double elteres_osszeg = 0.0;
    for (int j : jegyek) {
        elteres_osszeg += std::pow(j - atlag, 2);
    }

    double szoras = std::sqrt(elteres_osszeg / jegyek.size());

    // Eredm√©nyek ki√≠r√°sa
    std::cout << std::fixed << std::setprecision(2);
    std::cout << "\nA jegyek sz√°mtani √°tlaga: " << atlag << '\n';
    std::cout << "A jegyek sz√≥r√°sa: " << szoras << '\n';

    return 0;
}
// 3.46. Ny√∫lteny√©szt√©s

// 3.46.1. Mr. Fibonacci elhat√°rozta, hogy belev√°g a ny√∫lteny√©szt√©sbe. Az 
// els≈ë h√≥napban vesz egy √∫jsz√ºl√∂tt ny√∫lp√°rt. Minden ny√∫l 2 h√≥nap ut√°n 
// v√°lik term√©kenny√©. Minden h√≥napban minden term√©keny ny√∫lp√°r egy √∫j 
// ny√∫lp√°rt sz√ºl. A nyulakat etetni kell, minden ny√∫l egy zs√°k ny√∫lt√°pot 
// fogyaszt el minden h√≥napban √©s egy ny√∫lp√°r se pusztul el. √çrjon programot, 
// amely meghat√°rozza, hogy h√°ny zs√°k ny√∫lt√°pot kell v√°s√°rolni egy √©vre, 
// ha az els≈ë h√≥napban 1 ny√∫lp√°r van! 

// 3.46.2. B≈ëv√≠tse ki az el≈ëz≈ë programot √∫gy, hogy 3 √©vre el≈ëre sz√°moljon, 
// figyelembe v√©ve, hogy Mr. Fibonacci minden √©v elej√©n eladja a term√©keny 
// nyulak 90 %-√°t, √©s a term√©ketlenek 95 %-√°t! Amennyiben az eladand√≥ nyulak 
// mennyis√©ge nem eg√©sz sz√°m, √∫gy ezt az √©rt√©ket mindig lefele kerek√≠tj√ºk. 
// P√©ld√°ul 101 term√©keny ny√∫l eset√©n 90-et adunk el. 3.47. Jegyek

// 3.46.1.-3.46.2.


#include <iostream>
#include <cmath>
#include <iomanip>

int main() {
    using ull = unsigned long long;
    
    ull termeketlen = 1; // 1 p√°r ny√∫l az elej√©n (√∫jsz√ºl√∂tt)
    ull egyhonapos = 0;
    ull termekeny = 0;

    ull total_nyulpar = 1;
    ull total_tap = 2; // 1 p√°r ny√∫l = 2 ny√∫l = 2 zs√°k

    const int evek = 3;

    for (int ev = 1; ev <= evek; ++ev) {
        for (int honap = 1; honap <= 12; ++honap) {
            ull uj_nyulpar = termekeny;

            // Friss√≠tj√ºk az √°llapotokat
            termekeny += egyhonapos;
            egyhonapos = termeketlen;
            termeketlen = uj_nyulpar;

            ull havi_nyulpar = termekeny + egyhonapos + termeketlen;
            total_nyulpar += uj_nyulpar;
            total_tap += havi_nyulpar * 2;
        }

        // √âv v√©g√©n elad√°sok
        ull eladott_termekeny = static_cast<ull>(std::floor(termekeny * 0.9));
        ull eladott_termeketlen = static_cast<ull>(std::floor((termeketlen + egyhonapos) * 0.95));

        std::cout << "\n[√âv " << ev << " v√©ge] Elad√°s el≈ëtt:\n";
        std::cout << "  Termekeny: " << termekeny << "\n";
        std::cout << "  Termeketlen: " << (termeketlen + egyhonapos) << "\n";

        termekeny -= eladott_termekeny;

        // Termeketlen = (√∫jsz√ºl√∂tt + egyhonapos), √∫jraosztjuk:
        ull marado_termeketlen = termeketlen + egyhonapos - eladott_termeketlen;
        egyhonapos = 0;
        termeketlen = marado_termeketlen;

        std::cout << "  Elad√°s ut√°n:\n";
        std::cout << "    Termekeny: " << termekeny << "\n";
        std::cout << "    Termeketlen: " << termeketlen << "\n";
    }

    std::cout << "\n√ñsszesen sz√ºks√©ges ny√∫lt√°p (3 √©vre): " << total_tap << " zs√°k\n";

    return 0;
}
// 3.47.1. Egy 30 f≈ës oszt√°lyban minden tanul√≥r√≥l tudjuk, hogy 
// informatik√°b√≥l mennyi a jegyeinek az √°tlaga. √çrjon programot, amely 
// billenty≈±zetr≈ël beolvassa a 30 √°tlagot, majd ki√≠rja a k√©perny≈ëre, hogy 
// volt-e buk√°s id√©n! Az bukik meg, akinek az √°tlaga kevesebb, mint 1.5. 
// 3.47.1.

#include <iostream>
#include <vector>

constexpr int N = 30;
constexpr double BUKAS_HATAR = 1.5;

int main() {
    std::vector<double> atlagok(N);
    bool voltBukas = false;

    for (int i = 0; i < N; ++i) {
        std::cout << "A(z) " << (i + 1) << ". atlag: ";
        std::cin >> atlagok[i];
        if (atlagok[i] < BUKAS_HATAR) {
            voltBukas = true;
        }
    }

    std::cout << "\n" << (voltBukas ? "Volt bukas!" : "Nem volt bukas!") << "\n";

    return 0;
}
// 3.47.2. M√≥dos√≠tsa az el≈ëz≈ë programot √∫gy, hogy addig olvassa be az 
// √°tlagokat, am√≠g bukott embert nem tal√°l! Amennyiben 0-t olvasunk be, az azt 
// jelenti, hogy v√©ge a beolvas√°snak, vagyis ez nem egy √°tlag. A program ez 
// esetben is √≠rja ki, hogy bukik-e valaki! 



#include <iostream>

constexpr double BUKAS_HATAR = 1.5;

int main() {
    double atlag = 0.0;
    int sorszam = 1;
    bool voltBukas = false;

    while (true) {
        std::cout << "Kerem a(z) " << sorszam++ << ". atlagot: ";
        std::cin >> atlag;

        if (atlag == 0.0) {
            break;
        }

        if (atlag < BUKAS_HATAR) {
            voltBukas = true;
            break;
        }
    }

    std::cout << (voltBukas ? "Volt bukas!\n" : "Nem volt bukas!\n");

    return 0;
}
/* 
3.48. Marsj√°r√≥ 

A Mars Explorer 3000-es marsj√°r√≥ robot utaz√°sa sor√°n 100 m√©terenk√©nt feljegyzi, hogy a 
bolyg√≥n val√≥ lesz√°ll√≥hely√©hez viszony√≠tva milyen magasan / m√©lyen j√°r, 
√≠gy egy domborzati keresztmetszetet tov√°bb√≠t a f√∂ldi ir√°ny√≠t√≥ 
k√∂zpontba. Szeretn√©nk r√©szletesen megvizsg√°lni a bej√°rt terepet. A 
vizsg√°latra sz√°m√≠t√≥g√©pet haszn√°lunk. A domborzati magass√°gokat egy 
t√∂mbben t√°roljuk.


3.48.1. √çrjon programot, amely a t√∂mbben t√°rolt domborzati adatokb√≥l 
meghat√°rozza, hogy mekkora volt a legmagasabb, illetve legalacsonyabb 
magass√°g, ahol a marsj√°r√≥ j√°rt, valamint hogy hol voltak ezek a pontok! 
*/ 

// 3.48.1.

#include <iostream>
#include <vector>
#include <cstdlib>  // rand()
#include <ctime>    // time()

constexpr int N = 100;

int main() {
    std::srand(static_cast<unsigned int>(std::time(nullptr))); // v√©letlensz√°m inicializ√°l√°sa

    std::vector<double> magassag(N);
    
    // V√©letlenszer≈± magass√°gok gener√°l√°sa
    for (int i = 0; i < N; ++i) {
        magassag[i] = (std::rand() % 1000) / 10.0; // 0.0 - 99.9 k√∂z√∂tti √©rt√©kek
    }

    // Min/max keres√©s
    int minIndex = 0;
    int maxIndex = 0;

    for (int i = 1; i < N; ++i) {
        if (magassag[i] < magassag[minIndex]) {
            minIndex = i;
        }
        if (magassag[i] > magassag[maxIndex]) {
            maxIndex = i;
        }
    }

    std::cout << "A legmagasabb pont: " << magassag[maxIndex]
              << ", helye: " << maxIndex << '\n';
    std::cout << "A legalacsonyabb pont: " << magassag[minIndex]
              << ", helye: " << minIndex << '\n';

    return 0;
}

/*
3.48.2. K√∂zeledik a marsbeli t√©l, ez√©rt a marsj√°r√≥ f√∂ldi vezet≈ëi att√≥l 
f√©lnek, hogy azel≈ëtt le√°ll, miel≈ëtt elk√ºlden√© a leg√∫jabb 
√∂sszegy≈±jt√∂tt m√©r√©seket. Ez√©rt be√°ll√≠tj√°k, hogy minden egyes m√©r√©s 
ut√°n k√ºldje el a F√∂ldre az aktu√°lis magass√°g√°t. √çrjon programot, amibe a 
kezel≈ë szem√©ly beg√©peli az aktu√°lis kapott magass√°g √©rt√©ket √©s minden 
√∫j adat ut√°n kisz√°molja, hogy eddig mekkora volt a legmagasabb √©s 
legalacsonyabb pont √©s hol voltak azok! 

3.48.3. B≈ëv√≠tse ki az el≈ëz≈ë programot √∫gy, hogy azt is nyilv√°n tartsa a 
legmeredekebb lejt≈ë √©s emelked≈ë meredeks√©g√©t, valamint poz√≠ci√≥j√°t! 
Megjegyz√©s: k√©t m√©r√©si adat k√∂z√∂tti k√ºl√∂nbs√©g egy der√©ksz√∂g≈± 
h√°romsz√∂g egyik befog√≥j√°t hat√°rozza meg, a m√°sik befog√≥ 100 m√©ter. 

3.48.4. B≈ëv√≠tse ki az el≈ëz≈ë programot √∫gy, hogy a leghosszabb s√≠k 
ter√ºlet hossz√°t, valamint kezd≈ë √©s v√©g pontj√°nak poz√≠ci√≥j√°t keresse 
meg! S√≠k ter√ºletnek sz√°m√≠t az, ahol a terep pontjai √∂sszef√ºgg≈ëen azonos 
magass√°g√∫ak. 
*/
//3.48.2.-3.48.4.

#include <iostream>
#include <vector>
#include <cmath>
#include <cstdlib>

constexpr int N = 100;

double magassagLekerdez() {
    static int i = 0;
    double res;
    if (i >= 0 && i <= 3) res = 4;
    else if (i >= 4 && i <= 10) res = 3;
    else if (i >= 40 && i <= 60) res = 7;
    else if (i >= 70 && i <= 100) res = 2;
    else res = (std::rand() % 1000) / 10.0;
    ++i;
    return res;
}

struct Siksag {
    int kezdet = 0;
    int veg = 0;
    int hossz = 1;
};

int main() {
    std::vector<double> magassagok(N);
    int minIndex = 0, maxIndex = 0;
    int emelkedoIndex = 0;
    double minMagassag, maxMagassag;
    double maxKulonbseg = 0;
    double elozo = 0.0;

    Siksag maxSiksag;
    Siksag aktSiksag;
    aktSiksag.hossz = 0;

    for (int i = 0; i < N; ++i) {
        double magassag = magassagLekerdez();
        magassagok[i] = magassag;

        if (i == 0) {
            minMagassag = maxMagassag = elozo = magassag;
            continue;
        }

        // legmeredekebb lejt≈ë vagy emelked≈ë
        double kulonbseg = std::abs(magassag - elozo);
        if (kulonbseg > maxKulonbseg) {
            maxKulonbseg = kulonbseg;
            emelkedoIndex = i;
        }

        // max √©s min pont
        if (magassag > maxMagassag) {
            maxMagassag = magassag;
            maxIndex = i;
        }
        if (magassag < minMagassag) {
            minMagassag = magassag;
            minIndex = i;
        }

        // s√≠k szakasz
        if (std::abs(magassag - elozo) < 1e-6) {
            if (aktSiksag.hossz == 0) {
                aktSiksag.kezdet = i - 1;
                aktSiksag.veg = i;
                aktSiksag.hossz = 2;
            } else {
                aktSiksag.veg = i;
                aktSiksag.hossz++;
            }
        } else {
            if (aktSiksag.hossz > maxSiksag.hossz) {
                maxSiksag = aktSiksag;
            }
            aktSiksag.hossz = 0;
        }

        elozo = magassag;
    }

    if (aktSiksag.hossz > maxSiksag.hossz) {
        maxSiksag = aktSiksag;
    }

    // sz√∂g kisz√°m√≠t√°sa fokban (a = szintk√ºl√∂nbs√©g, b = 100 m)
    double maxFok = std::atan(maxKulonbseg / 100.0) * 180.0 / M_PI;

    // eredm√©nyek ki√≠rat√°sa
    std::cout << "A legmagasabb pont: " << maxMagassag << ", helye: " << maxIndex << '\n';
    std::cout << "A legalacsonyabb pont: " << minMagassag << ", helye: " << minIndex << '\n';
    std::cout << "A legmeredekebb emelkedo vagy lejt≈ë: " << maxFok << " fok, helye: " << emelkedoIndex << '\n';
    std::cout << "A leghosszabb s√≠k ter√ºlet:\n";
    std::cout << "\tKezdete: " << maxSiksag.kezdet << '\n';
    std::cout << "\tVege: " << maxSiksag.veg << '\n';
    std::cout << "\tHossza: " << maxSiksag.hossz << '\n';

    return 0;
}

/* c++11

3.49.1. Nemo kapit√°ny al√°mer√ºl a Nautilus tengeralattj√°r√≥val, 
hogy megvizsg√°lja a tenger √©l≈ëvil√°g√°t. 
Mer√ºl√©s k√∂zben a seg√©dei minden t√≠zedik m√©tern√©l megsz√°molj√°k, 
hogy mennyi halat l√°tnak, hogy ezt felhaszn√°lhass√°k k√©s≈ëbbi 
kutat√°saikhoz. 
A sz√°ml√°l√°sok eredm√©ny√©t egy vektorban t√°rolj√°k el, ahol az i. komponens 
a 10*i m√©ter m√©lyen v√©gzett sz√°ml√°l√°s eredm√©ny√©t t√°rolja. 
Sajnos m√©g nem √°ll rendelkez√©sre nagy mem√≥ria kapacit√°s√∫ sz√°m√≠t√≥g√©p, 
az eredm√©nyeket lyukk√°rty√°ra √≠rj√°k. Megfigyelt√©k, hogy nagyon gyakran nem 
l√°tnak egy halat sem, 
ez√©rt √∫gy gondolt√°k, oly m√≥don t√°rolj√°k az eredm√©nyeket, hogy ezt a 
t√©nyt kihaszn√°lj√°k 
√©s a ritka vektorok t√°rol√°si m√≥dszer√©hez folyamodtak, √≠gy helyet 
takar√≠tottak meg, 
√©s az adatok feldolgoz√°sa is gyorsabb. √çrjon programot, amely egy ilyen 
ritka vektorokat kezel! 
A ritka vektorok olyan vektorok, amelyek nagyon kev√©s nem 0 komponenst 
tartalmaznak. 
Ezeket c√©lszer≈± √∫gy t√°rolni, hogy csak a nem 0 elemeket t√°roljuk, azon 
vektoron bel√ºli index√©vel. 
Ennek egyik m√≥dja, ha a (sz√°m, index) p√°rokat l√°ncolt list√°ban t√°roljuk. 
A vektor dimenzi√≥ja nincs korl√°tozva. Val√≥s√≠tsa meg a k√∂vetkez≈ë 
m≈±veleteket: 
¬∑ Be√°ll√≠t(index, √©rt√©k): A vektor adott index≈± elem√©t az adott √©rt√©kre 
√°ll√≠tja be.  
  Ha az √©rt√©k 0, akkor az elem nem t√°rol√≥dik. 
¬∑ √ârt√©k(index): A m≈±velet visszaadja az adott index≈± elem √©rt√©k√©t. 
¬∑ T√∂r√∂l: A m≈±velet null√°za a teljes vektor tartalm√°t. 
¬∑ NemNull√°k: A m≈±velet visszaadja, hogy mennyi nem 0 elem van a vektorban. 
¬∑ Legutols√≥: A m≈±velet visszaadja, hogy h√°nyas indexen tal√°lhat√≥ a 
legutols√≥ nem 0 elem. 
¬∑ Megjelen√≠t: A m≈±velet ki√≠rja a k√©perny≈ëre a teljes vektort eg√©szen a 
‚ÄûLegutols√≥‚Äù √°ltal meghat√°rozott elemig.
 A 0-kat is meg kell jelen√≠teni. 

3.49.2. El≈ëfordulhat, hogy az el≈ëz≈ë vektoron bel√ºl az elemek nem j√≥ 
sorrendben k√∂vetik egym√°st. 
√©ld√°ul lehet, hogy el≈ëbb tal√°lhat√≥ meg az 5-√∂s index≈± elem a list√°ban, 
mint a 3-as. 
Implement√°lja a ‚ÄûRendez‚Äù m≈±veletet, amely az indexeknek megfelel≈ëen 
n√∂vekv≈ë sorrendbe rendezi 
a list√°n bel√ºli elemeket! 

3.49.3. B≈ëv√≠tse ki az el≈ëz≈ë programot az √∂sszead√°s √©s a szorz√°s 
m≈±veletekkel! 
Az √∂sszead√°s k√©t ritka vektort ad √∂ssze. √úgyeljen arra, hogy a 0 elemeket 
ne t√°rolja el! 
A szorz√°s 2 ritka vektort szoroz √∂ssze skal√°risan.  

3.49.1-3.49.3. */



#include <iostream>
#include <memory>

class SparseVector {
    struct Node {
        double value;
        int index;
        std::unique_ptr<Node> next;
        Node(double val, int idx) : value(val), index(idx), next(nullptr) {}
    };

    std::unique_ptr<Node> head;

    // Seg√©df√ºggv√©ny: m√©ly m√°sol√°s egy l√°ncolt list√°r√≥l
    static std::unique_ptr<Node> clone(const std::unique_ptr<Node>& src) {
        if (!src) return nullptr;
        std::unique_ptr<Node> res(new Node(src->value, src->index));
        res->next = clone(src->next);
        return res;
    }

public:
    SparseVector() = default;
    ~SparseVector() = default;

    // M√°sol√≥ konstruktor (deep copy)
    SparseVector(const SparseVector& other) : head(clone(other.head)) {}

    // M√°sol√≥ √©rt√©kad√≥ oper√°tor (deep copy)
    SparseVector& operator=(const SparseVector& other) {
        if (this != &other) {
            head = clone(other.head);
        }
        return *this;
    }

    // Be√°ll√≠t: √©rt√©ket ad egy indexhez (ha 0, akkor t√∂rli)
    void set(int idx, double val) {
        Node* prev = nullptr;
        Node* curr = head.get();

        while (curr && curr->index < idx) {
            prev = curr;
            curr = curr->next.get();
        }
        if (curr && curr->index == idx) {
            if (val == 0.0) {
                if (prev)
                    prev->next = std::move(curr->next);
                else
                    head = std::move(curr->next);
            } else {
                curr->value = val;
            }
            return;
        }
        if (val == 0.0) return;

        std::unique_ptr<Node> newNode(new Node(val, idx));
        if (prev) {
            newNode->next = std::move(prev->next);
            prev->next = std::move(newNode);
        } else {
            newNode->next = std::move(head);
            head = std::move(newNode);
        }
    }

    // Lek√©rdez√©s
    double get(int idx) const {
        Node* curr = head.get();
        while (curr && curr->index < idx)
            curr = curr->next.get();
        if (curr && curr->index == idx)
            return curr->value;
        return 0.0;
    }

    // T√∂r√∂l mindent
    void clear() {
        head.reset();
    }

    // Nem nulla elemek sz√°ma
    int nonZeros() const {
        int count = 0;
        Node* curr = head.get();
        while (curr) {
            ++count;
            curr = curr->next.get();
        }
        return count;
    }

    // Legutols√≥ nem nulla index (ha nincs, -1)
    int lastIndex() const {
        int idx = -1;
        Node* curr = head.get();
        while (curr) {
            if (curr->index > idx) idx = curr->index;
            curr = curr->next.get();
        }
        return idx;
    }

    // Megjelen√≠t (null√°kkal egy√ºtt, eg√©szen a legutols√≥ig)
    void print() const {
        int max = lastIndex();
        if (max == -1) {
            std::cout << "ures" << std::endl;
            return;
        }
        for (int i = 0; i <= max; ++i) {
            std::cout << get(i);
            if (i < max) std::cout << ", ";
        }
        std::cout << std::endl;
    }

    // Rendez√©s index szerint (Bubble-sort szer≈±en, pointerek helyett 
√©rt√©kcser√©vel)
    void sort() {
        if (!head || !head->next) return;
        bool swapped;
        do {
            swapped = false;
            Node* curr = head.get();
            while (curr->next) {
                if (curr->index > curr->next->index) {
                    std::swap(curr->index, curr->next->index);
                    std::swap(curr->value, curr->next->value);
                    swapped = true;
                }
                curr = curr->next.get();
            }
        } while (swapped);
    }

    // √ñsszead√°s
    SparseVector operator+(const SparseVector& other) const {
        SparseVector result = *this;
        Node* curr = other.head.get();
        while (curr) {
            result.set(curr->index, result.get(curr->index) + curr->value);
            curr = curr->next.get();
        }
        return result;
    }

    // Skal√°ris szorzat (dot product)
    double dot(const SparseVector& other) const {
        double sum = 0.0;
        Node* curr = head.get();
        while (curr) {
            double v = other.get(curr->index);
            sum += curr->value * v;
            curr = curr->next.get();
        }
        return sum;
    }
};

int menu() {
    std::cout << "\n1. Beallit (index, ertek)\n"
              << "2. Ertek lekerdezese\n"
              << "3. Mindet torol\n"
              << "4. Nem nullak szama\n"
              << "5. Legutolso index\n"
              << "6. Megjelenit\n"
              << "7. Rendez\n"
              << "8. Osszead masik vektorral\n"
              << "9. Skalaris szorzas masik vektorral\n"
              << "10. Kilepes\n"
              << "Valasztas: ";
    int ch;
    std::cin >> ch;
    return ch;
}

int main() {
    SparseVector v;
    SparseVector v2;
    v2.set(2, 5.0);
    v2.set(6, 1.0);
    v2.set(10, 7.0);

    int menuval;
    do {
        menuval = menu();
        if (menuval == 1) {
            int idx; double val;
            std::cout << "Index: "; std::cin >> idx;
            std::cout << "Ertek: "; std::cin >> val;
            v.set(idx, val);
        } else if (menuval == 2) {
            int idx;
            std::cout << "Index: "; std::cin >> idx;
            std::cout << "Ertek: " << v.get(idx) << "\n";
        } else if (menuval == 3) {
            v.clear();
        } else if (menuval == 4) {
            std::cout << "Nem nullak szama: " << v.nonZeros() << "\n";
        } else if (menuval == 5) {
            std::cout << "Legutolso index: " << v.lastIndex() << "\n";
        } else if (menuval == 6) {
            v.print();
        } else if (menuval == 7) {
            v.sort();
        } else if (menuval == 8) {
            v = v + v2;
        } else if (menuval == 9) {
            std::cout << "Skalaris szorzat: " << v.dot(v2) << "\n";
        }
    } while (menuval != 10);

    return 0;
}
