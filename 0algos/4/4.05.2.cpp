// c++11
// 4.5.2. Írjon metódust az aktuális mutató abszolút mozgatására, adott sorszámú elem törlésére, adott objektum törlésére, a teljes lista törlésére, aktuális mutató utáni beszúrásra! 4.6. Lista


#include <iostream>
#include <cstring> using namespace std;
class airplane { public: int id;
int passengers;
airplane(int p1=0, int p2=0) : id(p1), passengers(p2), next(0), prev(0) {} bool operator==(const airplane& para) const;
airplane *next, *prev;
};
ostream& operator<<(ostream& os, const airplane& para) { os << "(id:" << para.id << ", passengers: " << para.passengers << ")";
return os;
} bool airplane::operator==(const airplane& para) const { bool result=false;
if (id==para.id && passengers==para.passengers) result=true;
return result;
} template <typename T1> class list { T1 *head, *tail, *act;
int elemNum;
public: list() : head(0), tail(0), act(0), elemNum(0) {} ~list();
T1* search(const T1& para) const;
void insert(const T1& para);
void delAct();
void delAbs(int para);
void moveAct(int para);
void moveAbs(int para);
T1& getElem() const {return *act;} int getElemNum() const {return elemNum;} template <typename U1> friend ostream& operator<<(ostream&, const list<U1>&);
};
template <typename T1> list<T1>::~list() { T1 *temp=head, *prev;
while (temp) { prev=temp;
temp=temp->next;
delete prev;
} } template <typename T1> T1* list<T1>::search(const T1& para) const { T1* temp=head;
while (temp) { if (*temp==para) return temp;
temp=temp->next;
} } return 0;
template <typename T1> void list<T1>::insert(const T1& para) { elemNum++;
T1 *temp=new T1(para), *before;
if (head==0) { head=tail=act=temp;
return;
} before=act->prev;
if (before==0) head=temp;
else before->next=temp;
temp->next=act;
act->prev=temp;
temp->prev=before;
act=temp;
} template <typename T1> void list<T1>::delAbs(int para) { moveAbs(para);
delAct();
} template <typename T1> void list<T1>::delAct() { T1 *after, *before;
if (act==0) return;
before=act->prev;
after=act->next;
if (before==0) act=head=after;
else { before->next=after;
act=before;
} if (after==0) tail=before;
else after->prev=before;
elemNum--;
} template <typename T1> void list<T1>::moveAct(int para) { if (para>0) while (act->next && para) { act=act->next;
para--;
} else while (act->prev && para) { act=act->prev;
para++;
} } template <typename T1> void list<T1>::moveAbs(int para) { act=head;
for (int i=para;i>0;i--) { act=act->next;
} } template <typename U1> ostream& operator<< (ostream& os, const list<U1>& para) { U1* temp=para.head;
if (!temp) os << "empty";
while (temp) { os << *temp << ", ";
temp=temp->next;
} os << endl;
return os;
} int main() { airplane a(1, 500), b(2, 450), c(3, 220), d(4, 260);
list<airplane> myList;
cout << myList;
myList.insert(a);
cout << myList;
myList.insert(b);
cout << myList;
myList.insert(c);
cout << myList;
myList.insert(d);
cout << myList;
cout << "ElemNum:" << myList.getElemNum() << endl;
cout << "act elem: " << myList.getElem() << endl;
cout << "moveAct(2)" << endl;
myList.moveAct(2);
cout << "act elem: " << myList.getElem() << endl;
cout << "delAct()" << endl;
myList.delAct();
cout << myList;
cout << "moveAct(-2)" << endl;
myList.moveAct(-2);
cout << "act elem: " << myList.getElem() << endl;
cout << "delAct()" << endl;
myList.delAct();
cout << "act elem: " << myList.getElem() << endl;
cout << myList;
return 0;
} 
