8.1.1.
#include <stdio.h> void print(double* tomb, int size) { int idxI;
printf("[");
for (idxI=0;
idxI<size;
idxI++) printf("%lf ", tomb[idxI]);
printf("]");
} int minIndex(double* tomb, int size) { int minIndex = 0;
int idxI;
for (idxI=1;
idxI<size;
idxI++) if (tomb[idxI] < tomb[minIndex]) minIndex = idxI;
return minIndex;
} void swap(double* tomb, int id1, int id2) { double temp;
temp=tomb[id1];
tomb[id1]=tomb[id2];
tomb[id2]=temp;
} void minSort(double *tomb, int len) { int idxI, c;
for(idxI=0;
idxI<len;
idxI++) { c=minIndex(tomb+idxI, len-idxI);
array c=c+idxI;
swap(tomb, c, idxI);
} } void boubleSort(double *tomb, int len) { order int idxI, idxJ;
for(idxI=0;
idxI<len;
idxI++) { for (idxJ=len-1;
idxJ>idxI;
idxJ--) { if (tomb[idxJ-1]>tomb[idxJ]) swap(tomb, idxJ-1, idxJ);
} } } int main() { double myArray[]={22, 16, -7, -42, 6}, myArray2[]={22, 16, -7, -42, 6};
int size = sizeof myArray / sizeof (double);
static arrays printf("The original myArray: ");
print(myArray, size);
minSort(myArray, size);
printf("\nThe min sorted myArray: ");
print(myArray, size);
printf("\nThe original myArray: ");
print(myArray2, size);
boubleSort(myArray2, size);
printf("\nThe bubble sorted myArray: ");
print(myArray, size);
return 0;
} 
8.1.1. Írjon függvényt, amely buborék illetve minimum kiválasztásos módszerrel rendez egy tömböt! Írjon segédfüggvényeket a minIndex, swap, print (tömb kiírás) feladatokra! 
8.1.2.
#include <stdio.h> void combSort(int *, int);
void insertionSort(int *, int);
int main() { int idxI;
int myArray[] = {5,8,3,4,12,45,87};
int myArray2[] = {5,8,3,4,12,45,87};
int size = sizeof(myArray) /sizeof(int);
combSort(myArray2, size);
for (idxI = 0;
idxI < size;
++idxI) printf("%d, ", myArray2[idxI]);
printf("\n");
} insertionSort(myArray, size);
for (idxI = 0;
idxI < size;
++idxI) printf("%d, ", myArray[idxI]);
printf("\n");
return 0;
void combSort(int * myArray, int size){ int gap = size, idxI, idxJ, swap, temp;
for (;;) { gap = (gap *10) /13;
if (gap == 9 || gap == 10) gap = 11;
if (gap < 1) gap=1;
swap = 0;
for (idxI = 0;
idxI < size -gap;
idxI++) { int idxJ = idxI+gap;
if (myArray[idxI] > myArray[idxJ]) { temp = myArray[idxI];
myArray[idxI] = myArray[idxJ];
myArray[idxJ] = temp;
swap = 1;
} } if (gap == 1 && !swap) break;
} } void insertionSort (int * myArray, int size) { int idxI, idxJ, leftBorder, rightBorder, tempSize, actualElement;
for (idxI = 1;
idxI < size;
idxI++) { actualElement = myArray[idxI];
leftBorder = 0;
rightBorder = idxI-1;
while (leftBorder <= rightBorder) { tempSize = (leftBorder+rightBorder) / 2;
if (actualElement < myArray[tempSize]) rightBorder = tempSize-1;
else leftBorder = tempSize+1;
} elemeket eltolom eggyel for (idxJ = idxI-1;
idxJ >= leftBorder;
idxJ--) myArray[idxJ+1] = myArray[idxJ];
myArray[leftBorder] = actualElement;
} } 
8.1.2. Ismerje meg és valósítson meg a következő rendező függvények közül kettőt! Beszúró rendezés, shell rendezése, radix rendezés, shaker rendezés, heap rendezés, comb rendezés. 8.2. Rekurzív függvények
8.2.1.
#include <stdio.h> void print(double* tomb, int size) { int idxI;
printf("[");
for (idxI=0;
idxI<size;
idxI++) printf("%lf ", tomb[idxI]);
printf("]");
} void swap(double* tomb, int id1, int id2) { double temp;
temp=tomb[id1];
tomb[id1]=tomb[id2];
tomb[id2]=temp;
} int partition(double* tomb, int left, int right) { create a new array and copy values into the begining and ending from the old one, and copy back the values into the original array double val=tomb[left];
int lm = left-1;
int rm = right+1;
while (1) { do rm--;
while (tomb[rm] > val);
do lm++;
while(tomb[lm] < val);
if(lm < rm) swap(tomb, rm, lm);
else return rm;
} } return 0;
void quickSort(double* tomb, int left, int right) { index, right=last valid index static int level=0;
int idxI;
level++;
for (idxI=0;
idxI<level-1;
idxI++) printf("\t");
printf("Begin of quickSort at level %d, [%d, %d]\n", level, left, right);
if(left < right) { int split_pt = partition(tomb,left, right);
quickSort(tomb, left, split_pt);
quickSort(tomb, split_pt+1, right);
} for (idxI=0;
idxI<level-1;
idxI++) printf("\t");
printf("End of quickSort at level %d, [%d, %d]\n", level, left, right);
level--;
} int main() { double myArray[]={0, -6, 7, -42, 6, 9};
int size = sizeof myArray / sizeof (double);
static arrays } printf("The original myArray: ");
print(myArray, size);
quickSort(myArray, 0, size-1);
printf("\nThe quick sorted myArray: ");
print(myArray, size);
return 0;

8.2.1. Valósítsa meg a gyorsrendezést! Mindig írja ki, hogy milyen mélyen van a rekurzióban statikus változó segítségével, és hogy mely résztömböt rendezi éppen! A kiírásokat a rekurzió mélysége alapján tabulálja! 
8.2.2.
#include <stdio.h>
#include <malloc.h> void fibonacci(long int * fibonacciArray, long int first, long int second, int count) { static int level = 0;
long int sum;
int idxI;
if (count) { level++;
for (idxI = 0;
idxI < level - 1;
idxI++) printf("\t");
printf("Begin of Fibonacci series at level %d\n", level);
fibonacciArray[count + idxI + 1] = second + first;
fibonacci(fibonacciArray, second, first + second, count - 1);
for (idxI = 0;
idxI < level - 1;
idxI++) printf("\t");
printf("End of Fibonacci series at level %d\n", level);
level--;
} } int main() { int idxI;
int maxIndex;
long int *fibonacciArray;
printf("Max index of the Fibonacci series? ");
scanf("%d", &maxIndex);
if (maxIndex < 3) { for (idxI = 0;
idxI < maxIndex;
++idxI) printf("%d. element: %d\n", idxI+1, 1);
} else { fibonacciArray = (long int *) malloc (sizeof(long int) * maxIndex);
fibonacciArray[0] = fibonacciArray[1] = 1;
for (idxI = 3;
idxI <= maxIndex;
++idxI) { meghatarozasa printf("\n");
fibonacci(fibonacciArray, 1, 1, idxI-2);
} printf("\n");
for (idxI = 0;
idxI < maxIndex;
++idxI) printf("%d. element: %ld\n", idxI + 1, fibonacciArray[idxI]);
free(fibonacciArray);
} return 0;
} 
8.2.2. Valósítsa meg a Fibonacci sort rekurzívan! Az előző program szerint tabulálással jelölje, hogy milyen mélyen van a rekurzióban! 8.3. Névsor
8.3.1. Feladat: Írjon programot, amely abc sorrendbe rendez neveket! Kérje be, hogy hány nevet akar rendezni, ezután kérje be a neveket! Rendezze a neveket buborék rendezéssel! Ötlet: használja az stricmp függvényt! 
8.3.1.
#include <stdio.h>
#include <string.h> int main() { int n, idxI, idxJ;
char name[10][30], tempName[30];
} printf("Number of names: ");
scanf("%d",&n);
for(idxI = 0;
idxI < n;
idxI++) { printf("%d. name:", idxI+1);
scanf("%s", name[idxI]);
} for(idxI = 0;
idxI < n;
idxI++) for(idxJ = 0;
idxJ < n;
idxJ++) { if (strcmp(name[idxI], name[idxJ]) < 0) { strcpy(tempName, name[idxI]);
strcpy(name[idxI], name[idxJ]);
strcpy(name[idxJ], tempName);
} } printf("\nThe ordered names are:\n");
for(idxI = 0;
idxI < n;
idxI++) printf("%s\n", name[idxI]);
return 0;

8.3.2.
#include <stdio.h>
#include <string.h> int main() { int numberOfNames, idxI, idxJ;
char name[10][30], prefix[10][30], tempName[30];
printf("Number of names: ");
scanf("%d", &numberOfNames);
for (idxI = 0;
idxI < numberOfNames;
idxI++) { printf("%d. prefix: ", idxI + 1);
scanf("%s", prefix[idxI]);
printf("%d. name:", idxI + 1);
scanf("%s", name[idxI]);
} for (idxI = 0;
idxI < numberOfNames;
idxI++) { for (idxJ = 0;
idxJ < numberOfNames;
idxJ++) { if (strcmp(name[idxI], name[idxJ]) < 0) { strcpy(tempName, name[idxI]);
strcpy(name[idxI], name[idxJ]);
strcpy(name[idxJ], tempName);
strcpy(tempName, prefix[idxI]);
strcpy(prefix[idxI], prefix[idxJ]);
strcpy(prefix[idxJ], tempName);
} } } } printf("\nThe ordered names are:\n");
for (idxI = 0;
idxI < numberOfNames;
idxI++) printf("%s %s\n", prefix[idxI], name[idxI]);
return 0;

8.3.2. Módosítsa úgy a programot, hogy a különböző előtagok (Dr., prof., PhD., …) ne befolyásolják a sorrendet! 8.4. Rendezett láncolt lista
8.4.1.
#include <stdio.h>
#include <malloc.h>
#include <string.h> typedef struct { int ID;
double size;
char origin[100];
} DataType;
typedef struct le { DataType* data;
struct le* next;
struct le* prev;
} listElem;
typedef struct { struct le head;
struct le tail;
} List;
void displayListElem(DataType* data) { printf("(ID: %d, ", data->ID);
printf("size: %lf, ", data->size);
printf("origin: %s)", data->origin);
} void deleteList(List* myList) { listElem *act;
act = myList->head.next;
if (act == &myList->tail) return;
while (act != &myList->tail) { act = act->next;
free(act->prev);
} } void listList(List* myList) { listElem *act=myList->head.next;
printf("List elments: ");
while (act != &myList->tail) { displayListElem(act->data);
act = act->next;
if (act != &myList->tail) printf(", ");
} } printf("\n");
void insert(List* myList, DataType* newData) { listElem *act=myList->head.next, *newElem=NULL, *beforeElem=NULL, *afterElem=NULL;
while (act != &myList->tail && act->data->ID > newData->ID) { check it's ID field act = act->next;
} afterElem = act;
beforeElem = act->prev;
newElem = (listElem*)malloc(sizeof(listElem));
newElem->data = newData;
beforeElem->next = newElem;
newElem->next = afterElem;
afterElem->prev = newElem;
newElem->prev = beforeElem;
} int main() { List myList={NULL};
myList.head.next = &myList.tail;
myList.tail.prev = &myList.head;
DataType testData[]={{1, 2.3, "Hu"}, {7, 12.3, "Ro"}, {0, 45.3, "Eu"}, {5, 14.1, "Gb"} };
int idxI;
} for (idxI=0;
idxI<4;
idxI++) { printf("Insert ");
displayListElem(&testData[idxI]);
printf("\n");
insert(&myList, &testData[idxI]);
listList(&myList);
printf("\n");
} deleteList(&myList);
return 0;

8.4.1. Valósítson meg egy kétszeresen láncolt listát, amely ID alapján csökkenő sorrendben tartalmazza a rekordokat! Használjon őrszemeket a lista két végén! A listát egy struktúra reprezentálja, amely az őrszemeket tartalmazza! A lista elem tartalmazza az előre, hátra mutató mezőket és egy mutatót az adat struktúrára! Az adat struktúra tartalmazza következő mezőket: ID, méret, származási hely. 
8.4.2. Egészítse ki a lista struktúrát egy egésszel, amely az elemek számát mutatja a listában! Módosítsa a függvényeket, hogy azok kezeljék az új adattagot! 8.5. Kupacrendezés
8.4.2.
#include <stdio.h>
#include <malloc.h>
#include <string.h> typedef struct { int ID;
double size;
char origin[100];
} DataType;
typedef struct le { DataType* data;
struct le* next;
struct le* prev;
} listElem;
typedef struct { struct le head;
struct le tail;
int count;
} List;
void displayListElem(DataType* data) { printf("(ID: %d, ", data->ID);
printf("size: %lf, ", data->size);
printf("origin: %s)", data->origin);
} void deleteList(List* myList) { listElem *act;
act = myList->head.next;
if (act == &myList->tail) return;
while (act != &myList->tail) { act = act->next;
free(act->prev);
} } void listList(List* myList) { listElem *act=myList->head.next;
printf("List elments: ");
while (act != &myList->tail) { displayListElem(act->data);
act = act->next;
if (act != &myList->tail) printf(", ");
} printf("\n");
printf("Element count: %d\n", myList->count);
} void insert(List* myList, DataType* newData) { listElem *act=myList->head.next, *newElem=NULL, *beforeElem=NULL, *afterElem=NULL;
while (act != &myList->tail && act->data->ID > newData->ID) { check it's ID field act = act->next;
} afterElem = act;
beforeElem = act->prev;
newElem = (listElem*)malloc(sizeof(listElem));
newElem->data = newData;
beforeElem->next = newElem;
newElem->next = afterElem;
afterElem->prev = newElem;
newElem->prev = beforeElem;
} int main() { List myList={NULL};
myList.count = 0;
myList.head.next = &myList.tail;
myList.tail.prev = &myList.head;
DataType testData[]={{1, 2.3, "Hu"}, {7, 12.3, „Ro”}, {0, 45.3, "Eu"}, {5, 14.1, "Gb"} };
int idxI;
for (idxI=0;
idxI<4;
idxI++) { printf("Insert ");
displayListElem(&testData[idxI]);
printf("\n");
insert(&myList, &testData[idxI]);
myList.count += 1;
listList(&myList);
printf("\n");
} printf("Count: %d\n", myList.count);
deleteList(&myList);
return 0;
} 
8.5.1.
#include <stdio.h>
#include <malloc.h> typedef struct { int ID;
char name[50];
float price;
} headphone;
void exchange(headphone** a, int i, int j) { headphone *temp=a[i];
a[i]=a[j];
a[j]=temp;
} void downheap(headphone** a, int size, int parent) { int left=2*parent+1, right=2*parent+2, maxChild=left;
if (left>=size) return;
if (right<size && a[right]->ID > a[left]->ID) maxChild=right;
maxChild if (a[parent]->ID >= a[maxChild]->ID) return;
else { exchange(a, parent, maxChild);
downheap(a, size, maxChild);
subtree } } void buildheap(headphone** a, int n) { int v;
for (v=n/2-1;
v>=0;
v--) downheap(a, n, v);
} void heapsort(headphone** a, int n) { buildheap(a, n);
while (n>1) { n--;
exchange(a, 0, n);
array downheap(a, n, 0);
} } void printHeadphone(headphone* node) { if (!node) return;
printf("[ID: %3d, ", node->ID);
printf("name: %10s, ", node->name);
printf("price: %6.2f]", node->price);
} void printArray(headphone** array, int size) { int idxI=0;
for (;idxI<size;idxI++) { printHeadphone(array[idxI]);
printf("\n");
} } int main() { headphone b={23, "Genius", 2710}, c={7, "MS", 3250}, d={63, "Verano", 1160}, e={11, "LG", 6980}, f={9, "Samsung", 2370}, g={42, "Ele", 1260}, h={12, "Azona", 1230};
headphone* a[]={&b, &c, &d, &e, &f, &g, &h};
int size = sizeof (a) / sizeof(headphone*);
printf("Unordered heap:\n");
printArray(a, size);
heapsort(a, size);
printf("\nOrdered heap:\n");
printArray(a, size);
return 0;
} 
8.5.1. Valósítsa meg a kupacrendezést! A kupac legyen tömbbel reprezentálva! Minden tömbelem mutasson egy fejhallgató típusú struktúrára, amelynek az adattagjai: azonosító - egész, név - sztring, ár - lebegőpontos. Írja meg a következő függvényeket: egy fejhallgató adatainak kiírása, kupac kiírása (minden fejhallgató külön sorba, az azonos mezők egy oszlopban legyenek), a mutató tömb két elemének felcserélése, felszivárog, kupacépítés, kupacrendezés! 8.6. Szavak rendezése
8.6.1.
#include <stdio.h>
#include <stdlib.h>
#include <string.h> #define DEFAULT_INPUTFILE "words.txt" #define MAX_LENGTH 16 #define TRUE 1 #define FALSE 0 typedef char TWord[MAX_LENGTH];
int Greater(char * A, char * B) { int i;
int sa = strlen(A);
int sb = strlen(B);
int min = sa < sb ? sa : sb;
for (i = 0;
i < min;
i++) { if (A[i] > B[i]) return TRUE;
if (A[i] < B[i]) return FALSE;
} return sa > sb;
} int ReadWords(FILE * fd, TWord ** W) { int num, i;
fscanf(fd, "%d", &num);
(*W) = (TWord *)malloc(sizeof(TWord) * num);
for (i = 0;
i < num;
i++) fscanf(fd, "%s", (*W)[i]);
return num;
} void PrintWords(TWord * W, int num) { int i;
for (i = 0;
i < num;
i++) printf("\t%d.: %s\n", i + 1, W[i]);
} void Sort(TWord * W, int num) { int min, i, j;
TWord Temp;
for (i = 0;
i < num - 1;
i++) { min = i;
for (j = i;
j < num;
j++) { if (Greater(W[min], W[j])) min = j;
} strcpy(Temp, W[min]);
strcpy(W[min], W[i]);
strcpy(W[i], Temp);
} } int main(int argc, char * argv[]) { TWord * Words;
int WNum;
FILE * fd = fopen(argc > 1 ? argv[1] : DEFAULT_INPUTFILE, "r");
if (fd == NULL) { perror(„Error”);
return 0;
} WNum = ReadWords(fd, &Words);
} fclose(fd);
printf("Read words:\n");
PrintWords(Words, WNum);
Sort(Words, WNum);
printf("\n***************\nSorted words:\n");
PrintWords(Words, WNum);
free(Words);
Words = NULL;
return 0;
7 WARIOR APPLE SZOKOZSHIP BOOK SZOKOZ PHISIC LIMON 
8.6.1. Írjon programot, amely szavakat rendez növekvő sorrendbe az strcmp függvény használata nélkül! A szavak csak nagybetűkből állnak. A program olvassa be fájlból a szavakat, és írja ki azokat a képernyőre növekvő sorrendben. Ha egy szó megegyezik egy másik, hosszabb szó elejével, akkor a hosszabb szó szerepel később. Például: SO < SOAP. A szavak maximális hossza 15 karakter. Használjon dinamikus tömböket a szavak tárolásához! A sorrendnél a betűk ASCII kódja számít. Az input fájl formátuma: Első sor: A szavak száma. A többi sor egy-egy szót tartalmaz. Példa bemenet: 7 WARIOR APPLE SZOKOZSHIP BOOK SZOKOZ PHISIC LIMON Kimenet: Read words: 1.: WARIOR 2.: APPLE 3.: SOAP 4.: BOOK 5.: SO 6.: PHISIC 7.: LIMON *************** Sorted words : 1.: APPLE 2.: BOOK 3.: LIMON 4.: PHISIC 5.: SO 6.: SOAP 7.: WARIOR 8.7. Emlékeztetők
8.7.1.
#include <stdio.h>
#include <stdlib.h>
#include <memory.h> #define DEFAULT_INPUTFILE "memo1.txt" #define MAX_MEMO_LEN 21 #define TRUE 1 #define FALSE (!TRUE) struct TMemo { int Year;
int Month;
int Day;
int Hour;
char m[MAX_MEMO_LEN];
};
int ReadMemos(FILE * fd, struct TMemo ** M) { int c, i;
struct TMemo * mptr;
fscanf(fd, "%d", &c);
(*M) = mptr = (struct TMemo*)malloc(sizeof(struct TMemo) * c);
for (i = 0;
i < c;
i++) { fscanf(fd,"%d %d %d %d", &mptr->Year, &mptr->Month, &mptr->Day, &mptr->Hour);
fscanf(fd, "%s", mptr->m);
mptr++;
} return c;
} void PrintMemos(struct TMemo * M, int c) { int i;
for (i = 0;
i < c;
i++) { printf("Year: %d\nMonth: %d\nDay: %d\nHour: %d\n\t %s\n\n", M->Year, M->Month, M->Day, M->Hour, M->m);
M++;
} } int Greater(struct TMemo * A, struct TMemo * B) { if (A->Year != B->Year) { return (A->Year > B->Year);
} else { if (A->Month != B->Month) { return (A->Month > B->Month);
} else { if (A->Day != B->Day) { return (A->Day > B->Day);
} else { if (A->Hour > B->Hour) return (A->Hour > B->Hour);
} } } return FALSE;
} void Sort(struct TMemo * M, int c) { int i, j, mini;
struct TMemo tmp;
for (i = 0;
i < c - 1;
i++) { mini = i;
for (j = i;
j < c;
j++) { if (Greater( M + mini, M + j)) mini = j;
} memcpy(&tmp, M + mini, sizeof(struct TMemo));
memcpy(M + mini, M + i, sizeof(struct TMemo));
memcpy(M + i, &tmp, sizeof(struct TMemo));
} } int main(int argc, char * argv[]) { struct TMemo * Memos;
int MCount = 0;
FILE * fd = fopen(argc > 1 ? argv[1] : DEFAULT_INPUTFILE, "r");
if (fd == NULL) { perror("Error");
return 0;
} } MCount = ReadMemos(fd, &Memos);
fclose(fd);
Sort(Memos, MCount);
PrintMemos(Memos, MCount);
free(Memos);
Memos = NULL;
return 0;

8.7.1. James nagyon feledékeny, ezért emlékeztetőket szokott írni magának. Egy emlékeztető egy dátumot tartalmaz (év, hónap, nap), egy időpontot (órát), és egy emlékeztető kulcsszót. Az emlékeztetők összekeveredtek, ezért programot kell írni azok rendezésére. Az emlékeztetőket fájlból olvassa be! Írja ki a képernyőre a rendezett emlékeztetősorozatot! Tárolja az emlékeztetőket struktúrában, illetve dinamikus tömbökben! Az input fájl formátuma: Első sor: az emlékeztetők száma. A további sorok az emlékeztetőket tárolják a következő formátumban: Év Hónap Nap Óra Kulcsszó Az év, hónap, nap és óra értékei pozitív egészek. A szó maximális hossza 20 karakter. A sorokban az adatok szóköz karakterekkel vannak elválasztva. Példa bemenet: 2 2008 11 20 12 Bank 2008 10 16 16 Dentist Kimenet: Year: 2008 Month: 10 Day: 16 Hour: 16 Dentist Year: 2008 Month: 11 Day: 20 Hour: 12 Bank 


